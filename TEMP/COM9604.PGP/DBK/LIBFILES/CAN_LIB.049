%%
1,0:1
%%
.1
    Funktionen der CAN-Library V1.50
    @020[CANopen ] CAN - Initialisieren des CAN-Controllers
    @030[CANwrite] CAN - Daten senden
    @040[CANread ] CAN - Daten lesen
    @050[CANdftab] CAN - Variablen-Tabelle definieren
    @060[CANrwtab] CAN - Variablen-Tabelle bearbeiten
    @070[CANnode ] CAN - CAN-Knotennummer lesen
    @075[CANxnode] CAN - CAN-Knotennummer des x-ten CAN-Knotenschalters lesen
    @150[CANqueue] CAN - Definieren einer Empfangsqueue fÅr einen CAN Identifier
    @155[CANrd   ] CAN - Auslesen von Nachrichten aus der Queue
    @160[CANexcep] CAN - VerknÅpfen einer Exceptionstask mit einer CAN Nachricht
    @165[CANgetid] CAN - Lesen der CAN Daten aus der getriggerten Exceptiontask
    @170[CANrtr  ] CAN - Senden eines RTR Request
    @175[CANupd  ] CAN - Modifizieren des RTR Sendepuffer
    @180[CANngp  ] CAN - Node Guarding Fub fÅr NMT Slave Knoten (CAL)
    @182[CANbtreg] CAN - Bit Timing Register setzen
    @080[CMSinit ] CAN - Liste von CMS-Objekten definieren
    @140[CMSmain ] CAN - Liste von CMS-Objekten bearbeiten
    @185[CMSdlreq] CAN - Multiplexed Domain Download Request laut CAL
    @190[CMSdlcon] CAN - Multiplexed Domain Download Confirmation laut CAL

    @002[ Fortsetzung ]                      @200[ ANHANG ]                  @999[ HILFE beenden ]
.2
    Funktionen der CAN-Library (Fortsetzung)
    @195[GetNdNr]  SYS - Lesen der im CRM gespeicherten Knotennummer
    @196[SetNdNr]  SYS - Setzen einer Knotennummer im CRM fÅr den Hochlauf

  …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
  ∫ ACHTUNG: Da die CAN-Library AVT-Funktionen enthÑlt, kînnen die Funk-      ∫
  ∫          tionen dieser Library nur verwendet werden, wenn das Library-    ∫
  ∫          Runtime-Modul (B&R-Modul CAN_LIB.BR) auf der CPU (Anwender-ROM)  ∫
  ∫          vorhanden ist!                                                   ∫
  »ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº











                                       @200[ ANHANG ]                      @001[ öbersicht ]
.20
    CANopen - Initialisieren des CAN-Controllers

    @021[CANopen] (enable,baud_rate,cob_anz,adr(error_adr),device,info,
             us_ident,status)

    Parameter-Datentypen :
    ->  enable    : BIT           Der Funktionsblock wird nur ausgefÅhrt, wenn
                                  enable = 1 ist
    ->  @025[baud_rate ]: BYTE          Baudrate
    ->  @026[cob_anz   ]: WORD          Anzahl der mîglichen Kommunikationsobjekte
    <-> error_adr : WORD          Fehler-PV:
                                  $4000 ... Daten-Overflow im Empfangspuffer
                                            des CAN-Controllers
                                  $8000 ... CAN-Bus im BusOff-Zustand
                                  Der Wert der Fehler-PV wird von der Funktion
                                  CANopen() nicht automatisch rÅckgesetzt.
                                  D.h. nach dem Auswerten der Fehler-PV mu· der
                                  Anwender den Wert der PV auf 0 rÅcksetzen.



                                     @021[ Fortsetzung ]                   @001[ öbersicht ]
.21
    CANopen - Initialisieren des CAN-Controllers (Fortsetzung)

    Parameter-Datentypen (Fortsetzung) :
    ->  @027[device    ]: LONG          An diesem Eingang wird die Adresse eines
                                  Strings Åbergeben, welcher die verwendete
                                  CAN-Schnittstelle eindeutig beschreibt.
    ->  info      : WORD          Dieser Parameter hat derzeit noch keine
                                  Funktion (Reserve).
    <-  us_ident  : LONG          Anwender-Ident. Diese Ident-Nummer wird fÅr
                                  die anderen Funktionen der CAN-Library be-
                                  nîtigt.
    <-  @029[status    ]: WORD          Fehlernummer (0 = kein Fehler)

    Mit der Funktion CANopen() wird der CAN-Controller initialisiert und die
    benîtigten Ressourcen (z.B. Speicher) werden angefordert.
    Da die Ressourcenvergabe und Initialisierung zeitaufwendig ist, wird die
    Funktion CANopen() im INIT-UP (Initialisierungs-Unterprogramm) der Task
    aufgerufen. FÅr jede CAN-Schnittstelle ist nur ein CANopen-Aufruf im INIT-
    UP zulÑssig.


                                                                     @001[ öbersicht ]
.25
    CANopen - Initialisieren des CAN-Controllers (Fortsetzung)

    -> Parameter <baud_rate >: BYTE

    Mit dem Parameter "baud_rate" wird die Baudrate festgelegt. Die Baudrate
    wird in Einheiten zu 10000 Bit/s (z.B. 25 = 250 kBit/s) angegeben:

             1 ..... 10 kBit/s
             2 ..... 20 kBit/s
             5 ..... 50 kBit/s
            10 .... 100 kBit/s
            12 .... 125 kBit/s
            25 .... 250 kBit/s (B&R-Standard)
            50 .... 500 kBit/s
           100 ... 1000 kBit/s






                                       @020[ CANopen ]                     @001[ öbersicht ]
.26
    CANopen - Initialisieren des CAN-Controllers (Fortsetzung)

    -> Parameter <cob_anz   >: WORD

    Mit dem Parameter "cob_anz" wird die maximale Anzahl von mîglichen COBs
    (COB = Kommunikationsobjekt) angegeben.
    Die Anzahl der mîglichen COBs mu· grî·er oder gleich der Summe aller ver-
    wendeten CAN-Identifier sein (CAN-Identifier, die der Funktion CANdftab()
    in einer Variablen-Tabelle Åbergeben werden + CAN-Identifier, welche tem-
    porÑr fÅr CANwrite() und CANread() benîtigt werden).
    Die Summe der verwendeten CAN-Identifier ist auf 2047 beschrÑnkt, d.h. fÅr
    den Parameter "cob_anz" mu· ein Wert kleiner oder gleich 2047 angegeben
    werden. FÅr die COB-Verwaltung ("cob_anz") werden pro COB 56 Byte Speicher
    benîtigt.







                                       @020[ CANopen ]                     @001[ öbersicht ]
.27
    CANopen - Initialisieren des CAN-Controllers (Fortsetzung)

    -> Parameter <device    >: LONG

    An diesem Eingang wird die Adresse eines Strings Åbergeben, welcher die
    verwendete CAN-Schnittstelle eindeutig beschreibt.

    Format des Strings:
    [SL<x>].[SS<x>].[IF<x>]
    SL: Slot (Steckplatz) mit der Nummer <x>. Die mîglichen Steckplatznummern
        bewegen sich von 0 (CPU-Steckplatz) bis 15 (letzter Systembussteck-
        platz).
    SS: Subslot mit der Nummer <x>. Der Subslot beschreibt den Steckplatz
        innerhalb eines Moduls (CP260, CP472: <x> = 1 oder 2).
    IF: Schnittstelle mit der Nummer <x>.

    Als Trennzeichen der Argumente ist ein Punkt (".") vorgeschrieben. Es kann
    aber auch jedes andere Åbliche Trennzeichen verwendet werden.
    Zwischen Gro·- und Kleinschreibung wird nicht unterschieden.


                                     @028[ Fortsetzung ]                   @001[ öbersicht ]
.28
    CANopen - Initialisieren des CAN-Controllers (Fortsetzung)

    Anmerkung:
    Wenn "device" = 0 ist (keine String-Adresse angegeben), wird die Standard-
    CAN-Schnittstelle verwendet. Die Standard-CAN-Schnittstelle wird aber auch
    verwendet, wenn fÅr "device" statt der Adresse eines Strings in der Form
    "[SL<x>].[SS<x>].[IF<x>]" die Adresse des Strings "CAN" Åbergeben wird.














                                       @020[ CANopen ]                     @001[ öbersicht ]
.29
    CANopen - Initialisieren des CAN-Controllers (Fortsetzung)

    <- Parameter <status    >: WORD

    Fehlernummern der Funktion CANopen():
    3090    "device" <> 0 ist im Basissystem V1.10 nicht zulÑssig
    8801    Kein Speicher fÅr Ressourcen im Anwender-RAM frei
            ("cob_anz" verringern bzw. Speicher vergrî·ern)
    8813    CAN-Treiber (CAN2000.BR) nicht installiert
    8815    UnzulÑssige Baudrate
    8816    "cob_anz" = 0 oder zu gro· (max. 2047)
    8826    CAN-Treiber (CAN2000.BR) ist zu alt (< V1.50)

    Eine Liste aller mîglichen Fehlermeldungen der CAN-Library finden Sie im
    Anhang @300[Fehlermeldungen].






                                       @020[ CANopen ]                     @001[ öbersicht ]
.30
    CANwrite - Daten senden

    @031[CANwrite] (enable,us_ident,can_id,adr(data_adr),data_lng,status)

    Parameter-Datentypen :
    ->  enable    : BIT           Der Funktionsblock wird nur ausgefÅhrt, wenn
                                  enable = 1 ist
    ->  us_ident  : LONG          Anwender-Ident (von @020[CANopen])
    ->  can_id    : LONG          CAN-Identifier
    ->  data_adr  : @250[ALLE]          Daten (max. 8 Byte), die gesendet werden
                                  sollen
    ->  data_lng  : BYTE          LÑnge der Daten in Byte (max. 8 Byte)
    <-  @035[status    ]: WORD          Fehlernummer (0 = kein Fehler)

    Durch die Funktion CANwrite() wird eine CAN-Nachricht mit dem angegebenen
    CAN-Identifier (Eingangsparameter "can_id") dem CAN-Controller zum Senden
    Åbergeben. Erst wenn diese CAN-Nachricht erfolgreich gesendet wurde, wird
    der Status der Funktion (Parameter "status") auf 0 gesetzt. Die Funktion
    ist vom Benutzer zyklisch aufzurufen, damit Åber den Ausgang "status" das
    erfolgreiche Senden des Puffers kontrolliert werden kann.

                                     @031[ Fortsetzung ]                   @001[ öbersicht ]
.31
    CANwrite - Daten senden (Fortsetzung)

    Nachrichten werden aber nur dann gesendet, wenn der Ausgang "status" 0
    ist. D.h. solange der zuletzt Åbergebene CAN-Identifier nicht ausgesendet
    wurde, wird kein weiterer Puffer Åbernommen. Ist der Sendepuffer des CAN-
    Controllers gerade besetzt ("busy"), so werden weitere Nachrichten in eine
    Sende-Queue gelegt. Es kînnen maximal 64 EintrÑge in der Sende-Queue
    zwischengespeichert werden. Ist die Sende-Queue voll, wird am Ausgang
    "status" eine entsprechende Fehlernummer (8810) ausgegeben.
    Im Sende-Interrupt wird die Sende-Queue abgearbeitet (FIFO = "First In,
    First Out"). Die Sende-Queue wird auch voll, wenn der Knoten nicht am CAN-
    Bus ist, oder wenn sich kein aktiver Knoten im Netzwerk befindet. Wird der
    Funktion CANwrite() ein neuer CAN-Identifier Åbergeben, wird der zuvor ge-
    setzte CAN-Identifier aus der CAN-Treiber-Verwaltung gelîscht (ca. 1 ms).

    Wenn in einer Task die Funktion CANwrite() mehrmals mit dem gleichen CAN-
    Identifier verwendet wird, so ist darauf zu achten, da· nur ein gleich-
    zeitiger Auftrag pro CAN-Identifier mîglich ist (sonst Fehler 8809). In
    der Funktion selbst wird fÅr jeden CAN-Identifier (beim ersten Aufruf)
    intern ein temporÑres COB (COB = Kommunikationsobjekt) angelegt.

                                      @032[ Beispiel ]                     @001[ öbersicht ]
.32
    CANwrite - Daten senden (Beispiel)

    Es wird eine CAN-Nachricht mit dem CAN-Identifier $100 auf den CAN-Bus
    gesendet. Der CAN-Treiber wird im INIT-UP der Task mit CANopen() geîffnet:

    INIT-UP der Task:
      enable = 1
      baud_rate = 25       ; Baudrate = 250 kBit/s
      cob_anz = 10
      CANopen(enable,baud_rate,cob_anz,adr(error_adr),0,0,us_ident,rc_open)

    Zyklischer Teil der Task:
      if (rc_open = 0) then
          ; Sende Daten (8 Byte) mit CAN-Identifier $100
          CANwrite(enable,us_ident,$100,adr(data_adr),8,rc_write)
          if ((rc_write <> 0) AND (rc_write <> 1)) then
              ; Fehlerbehandlung CANwrite()
          endif
      endif


                                                                     @001[ öbersicht ]
.35
    CANwrite - Daten senden (Fortsetzung)

    <- Parameter <status    >: WORD

    Fehlernummern der Funktion CANwrite():
    0       Daten wurden erfolgreich am CAN-Bus versendet
    1       Funktion noch aktiv (Senden)
    8800    Zuwenig COBs vorhanden
            ("cob_anz" in CANopen() vergrî·ern)
    8804    Falscher CAN-Identifier (> 2047)
    8805    Falscher "us_ident"
    8806    CAN-Identifier wird im System schon verwendet
    8809    CAN-Auftrag mit dem gleichen CAN-Identifier in Arbeit (busy)
    8810    Sende-Queue voll oder kein aktiver Knoten im Netz
    8811    CAN-Bus ist BusOff
    8813    CAN-Treiber (CAN2000.BR) nicht installiert
    8814    LÑnge der Daten > 8 Byte

    Eine Liste aller mîglichen Fehlermeldungen der CAN-Library finden Sie im
    Anhang @300[Fehlermeldungen].

                                      @030[ CANwrite ]                     @001[ öbersicht ]
.40
    CANread - Daten lesen

    @041[CANread] (enable,us_ident,can_id,adr(data_adr),data_lng,status)

    Parameter-Datentypen :
    ->  enable    : BIT           0 -> 1 ... Puffer fÅr den CAN-Identifier
                                             definieren
                                  1 -> 0 ... Puffer fÅr den CAN-Identifier
                                             wieder lîschen
                                  1 ........ Daten vom Controller Åbernehmen
    ->  us_ident  : LONG          Anwender-Ident (von @020[CANopen])
    ->  can_id    : LONG          CAN-Identifier
    <-> data_adr  : 8 BYTE (FELD) Feldvariable, in der die gelesenen Daten
                                  gespeichert werden
    <-  data_lng  : BYTE          LÑnge der Daten in Byte
    <-  @045[status    ]: WORD          Fehlernummer (0 = kein Fehler)

    Mit der Funktion CANread() kînnen CAN-Nachrichten aus dem CAN-Controller
    ausgelesen werden.


                                     @041[ Fortsetzung ]                   @001[ öbersicht ]
.41
    CANread - Daten lesen (Fortsetzung)

    Mit dem Eingang "enable" wird dem CAN-Controller mitgeteilt, ob ein Puffer
    fÅr den angegebenen CAN-Identifier definiert ("enable" 0 -> 1) bzw. wieder
    gelîscht ("enable" 1 -> 0) werden soll. Wenn "enable" = 1 ist, werden die
    aktuellen Daten vom CAN-Controller Åbernommen.
    Mit der Funktion CANread() kînnen maximal 13 verschiedene CAN-Identifier
    gleichzeitig definiert werden. Die Funktion CANread() hat gegenÅber der
    Funktion CANdftab() den Vorteil, da· fÅr diese CAN-Identifier kein
    Interrupt auf der CPU ausgelîst wird und daher die CPU-Belastung durch
    den CAN-Bus reduziert wird.
    In der Funktion selbst wird fÅr jeden CAN-Identifier (beim ersten Aufruf)
    intern ein temporÑres COB (COB = Kommunikationsobjekt) angelegt.








                                      @042[ Beispiel ]                     @001[ öbersicht ]
.42
    CANread - Daten lesen (Beispiel)

    Es wird eine CAN-Nachricht mit dem CAN-Identifier $100 gelesen.
    Der CAN-Treiber wird im INIT-UP der Task mit CANopen() geîffnet:

    INIT-UP der Task:
      enable = 1
      r_enable = 1
      baud_rate = 25       ; Baudrate = 250 kBit/s
      cob_anz = 10
      CANopen(enable,baud_rate,cob_anz,adr(error_adr),0,0,us_ident,rc_open)

    Zyklischer Teil der Task:
      if (rc_open = 0) then
          ; Hole neue Daten von CAN-Identifier $100
          CANread(r_enable,us_ident,$100,adr(data_adr),data_lng,rc_read)
          if (rc_read = 0) then
              ; Sende Daten Åber CAN-Identifier $200
              CANwrite(enable,us_ident,$200,adr(data_adr),8,rc_write)
          endif
     endif
                                                                     @001[ öbersicht ]
.45
    CANread - Daten lesen (Fortsetzung)

    <- Parameter <status    >: WORD

    Fehlernummern der Funktion CANread():
    0       Daten erhalten
    8804    Falscher CAN-Identifier (> 2047)
    8805    Falscher "us_ident"
    8811    CAN-Bus ist BusOff
    8812    Kein Puffer mehr frei (max. 13 mîglich)
    8813    CAN-Treiber (CAN2000.BR) nicht installiert
    8859    LÑnge der Nachricht ist falsch
    8872    Nachricht ging verloren (Puffer wurde bereits Åberschrieben), Daten
            sind aber konsistent
    8875    Nachricht ist inkonsistent (wÑhrend CANread() wurden neue Daten
            empfangen)
    8877    Keine Nachricht vorhanden

    Eine Liste aller mîglichen Fehlermeldungen der CAN-Library finden Sie im
    Anhang @300[Fehlermeldungen].

                                       @040[ CANread ]                     @001[ öbersicht ]
.50
    CANdftab - Variablen-Tabelle definieren

    @051[CANdftab] (enable,us_ident,adr(table_adr),tab_num,tab_ident,status)

    Parameter-Datentypen :
    ->  enable    : BIT           Der Funktionsblock wird nur ausgefÅhrt, wenn
                                  enable = 1 ist
    ->  us_ident  : LONG          Anwender-Ident (von @020[CANopen])
    ->  @055[table_adr ]: @250[ALLE]          Variablen-Tabelle. Die Variablen-Tabelle kann
                                  Åber ein Strukturfeld oder ein Datenmodul
                                  erstellt werden.
    ->  tab_num   : WORD          Anzahl der EintrÑge in der Variablen-Tabelle
    <-  tab_ident : LONG          Tabellen-Identifier fÅr CANrwtab()
    <-  @059[status    ]: WORD          Fehlernummer (0 = kein Fehler)

    Durch diese Funktion wird eine vom Anwender definierte @055[Variablenliste]
    (Variablen-Tabelle) mit Daten Åber den CAN-Bus versorgt.
    Die Daten kînnen sowohl gelesen als auch geschrieben werden. öber eine
    Event-Variable (Event-PV) kann der Anwender Sende- oder Lese-Aktionen
    kontrollieren.

                                     @051[ Fortsetzung ]                   @001[ öbersicht ]
.51
    CANdftab - Variablen-Tabelle definieren (Fortsetzung)

    Beim Senden (WRITE) werden die Daten der Variablen nur gesendet, wenn die
    Event-Variable auf 1 gesetzt ist. Wurde die CAN-Nachricht versendet, so
    wird die Event-Variable wieder auf 0 gesetzt. Umgekehrt wird beim Lesen
    (READ) eines angegebenen CAN-Identifiers der Wert der Event-Variable auf 1
    gesetzt, wenn Daten gelesen wurden.
    Um Zykluszeitprobleme zu vermeiden, wird die Funktion CANdftab() nur ein-
    mal im INIT-UP (Initialisierungs-Unterprogramm) der Task aufgerufen. Das
    zyklische Senden bzw. Lesen der Daten Åbernimmt die Funktion @060[CANrwtab].











                                                                     @001[ öbersicht ]
.55
    CANdftab - Variablen-Tabelle definieren (Fortsetzung)

    -> Parameter <table_adr >: @250[ALLE] (beliebiger Datentyp)

    Variablen-Tabelle.
    Die Variablen-Tabelle kann Åber ein @056[Strukturfeld] oder ein @057[Datenmodul] im
    Programmiersystem PG2000 definiert werden. D.h. fÅr "adr(table_adr)" wird
    entweder die Adresse eines Strukturfeldes (ein Feld-Element pro Proze·-
    variable) oder die Startadresse eines Datenmoduls (ein Datenmodul-Eintrag
    pro Proze·variable) angegeben. Die Startadresse des Datenmoduls kînnen Sie
    mit der Funktion DA_info() (siehe B&R-TRAP-Library) ermitteln.










                                      @050[ CANdftab ]                     @001[ öbersicht ]
.56
    CANdftab - Variablen-Tabelle definieren (Fortsetzung)

    Format der Struktur (fÅr Variablen-Tabelle):
    can_id   : LONG               CAN-Identifier
    pv_name  : 32 BYTE (FELD)     Name der Proze·variable (PV)
    event_pv : 32 BYTE (FELD)     Name der Event-PV zum Triggern
                                  (Datentyp der Event-PV: BIT oder BYTE)
    info     : LONG               Bit 0 = 0 ... READ (Daten lesen)
                                  Bit 0 = 1 ... WRITE (Daten senden)












                                     @057[ Fortsetzung ]                   @001[ öbersicht ]
.57
    CANdftab - Variablen-Tabelle definieren (Fortsetzung)

    Format des Datenmoduls (fÅr Variablen-Tabelle):
        ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ 1.
        ≥                 ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ 2.
        ≥                 ≥                         ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ 3.
        ≥                 ≥                         ≥                 ⁄ƒƒƒƒƒ 4.
    ƒƒƒƒ¡ƒƒƒƒ ƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒ ƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒ ƒƒƒƒ¡ƒƒƒƒ
    $00000100,"motor                  ","ev_mot                 ",$00000001
    $00000101,"schalter               ","ev_sch                 ",$00000000
    $00000090,"stop                   ","ev_stop                ",$00000000

    1. CAN-Identifier
       (Dieser Eintrag mu· ein LONG sein)
    2. Name der Proze·variable (nullterminierter String)
       (31 Zeichen + Nullbyte)
    3. Name der Event-PV zum Triggern (nullterminierter String)
       (31 Zeichen + Nullbyte)
    4. Daten lesen (Bit 0 = 0) / Daten senden (Bit 0 = 1)
       (Dieser Eintrag mu· ein LONG sein)

                                     @058[ Fortsetzung ]                   @001[ öbersicht ]
.58
    CANdftab - Variablen-Tabelle definieren (Fortsetzung)

    Pro Variable der Variablen-Tabelle kînnen maximal 8 Byte Daten gelesen oder
    gesendet werden. Die Datenkonsistenz ist fÅr die einfachen Datentypen (BIT,
    INT8, INT16, usw.) garantiert. FÅr Strukturen und Felder mu· der Anwender
    die Datenkonsistenz kontrollieren.
    WÑhrend dem Lesen der Variablen kann der Anwender ein öberschreiben der
    zu lesenden Daten durch Setzen der Event-Variable (Event-PV) auf $FF ver-
    hindern. Nach dem Lesen mu· der Anwender die Event-Variable wieder auf 0
    setzen.
    FÅr jede Variable der Variablen-Tabelle werden zur Verwaltung 22 Byte
    Speicher des Anwender-RAMs benîtigt.

    Anmerkung:
    Eine mit READ definierte Variable wird vom CAN-Treiber beim Eintreffen
    eines Frames Åberschrieben (interruptgesteuert), au·er die Event-PV ist
    auf $FF gesetzt. Damit ein Knoten im CAN-Netzwerk aktiv ist, mu· zumindest
    ein CAN-Identifier definiert werden.



                                      @050[ CANdftab ]                     @001[ öbersicht ]
.59
    CANdftab - Variablen-Tabelle definieren (Fortsetzung)

    <- Parameter <status    >: WORD

    Fehlernummern der Funktion CANdftab():
    8800    Zuwenig COBs vorhanden
            ("cob_anz" in CANopen() vergrî·ern)
    8802    Falscher Tabellen-Identifier ("tab_ident")
            (lokaler Funktionsblock-Speicher zerstîrt)
    8804    Falscher CAN-Identifier (> 2047)
    8805    Falscher "us_ident"
    8806    COB schon definiert
    8811    CAN-Bus ist BusOff
    8813    CAN-Treiber (CAN2000.BR) nicht installiert
    8826    CAN-Treiber (CAN2000.BR) ist zu alt (< V1.50)

    Eine Liste aller mîglichen Fehlermeldungen der CAN-Library finden Sie im
    Anhang @300[Fehlermeldungen].



                                      @050[ CANdftab ]                     @001[ öbersicht ]
.60
    CANrwtab - Variablen-Tabelle bearbeiten

    @061[CANrwtab] (enable,tab_ident,status)

    Parameter-Datentypen :
    ->  enable    : BIT           Der Funktionsblock wird nur ausgefÅhrt, wenn
                                  enable = 1 ist
    ->  tab_ident : LONG          Tabellen-Identifier von @050[CANdftab]
    <-  @065[status    ]: WORD          Fehlernummer (0 = kein Fehler)

    Mit dieser Funktion wird die mit der Funktion CANdftab() definierte Liste
    von Variablen (Variablen-Tabelle) bearbeitet (lesen bzw. senden). Die Funk-
    tion CANrwtab() mu· zyklisch aufgerufen werden (zyklischer Teil der Task).

    Beim Senden (WRITE) werden die Daten der Variablen nur gesendet, wenn die
    Event-Variable auf 1 gesetzt ist. Wurde die CAN-Nachricht versendet, so
    wird diese Event-Variable von der Funktion wieder auf 0 gesetzt. Umgekehrt
    wird beim Lesen (READ) eines angegebenen CAN-Identifiers der Wert der
    Event-Variable von der Funktion auf 1 gesetzt, wenn Daten gelesen wurden.


                                     @061[ Fortsetzung ]                   @001[ öbersicht ]
.61
    CANrwtab - Variablen-Tabelle bearbeiten (Fortsetzung)

    Geht der CAN-Bus in den BusOff-Zustand, wird bei jedem Aufruf von
    CANrwtab() der CAN-Controller wieder neu initialisiert.

















                                      @062[ Beispiel ]                     @001[ öbersicht ]
.62
    CANrwtab - Variablen-Tabelle bearbeiten (Beispiel)

    Es wird eine definierte Liste von Variablen gelesen und beschrieben:

    INIT-UP der Task:
      enable = 1
      ev_sch = 0          ; Event-PV "ev_sch" initialisieren
      ev_mot = 0          ; Event-PV "ev_mot" initialisieren
      ev_stop = 0         ; Event-PV "ev_stop" initialisieren
      rc_def = 1          ; "rc_def" auf 1 initialisieren fÅr zykl. Teil
      baud_rate = 25      ; Baudrate = 250 kBit/s
      CANopen(enable,baud_rate,10,adr(error_adr),0,0,us_ident,rc_open)
      if (rc_open = 0) then
          ; Tabelle mit 3 EintrÑgen wurde im Datenmodul "cantab" erstellt
          status = DA_ident("cantab",0,adr(da_ident))
          if (status = 0) then
              status = DA_info(da_ident,adr(table),adr(len),adr(ram))
              if (status = 0) then
                  CANdftab(enable,us_ident,table,3,tab_id,rc_def)
              endif
          endif
      endif                    @063[ Fortsetzung - Beispiel ]              @001[ öbersicht ]
.63
    CANrwtab - Variablen-Tabelle bearbeiten (Beispiel - Fortsetzung)

    Datenmodul "cantab" erstellt im PG2000:
      ; Die LÑnge der Variablennamen ist 31 Byte + 1 Nullbyte (nullterminiert)
      ; Variable "motor" mit CAN-Identifier $100 und Event-PV "ev_mot" WRITE
      ; Variable "schalter" mit CAN-Identifier $101 und Event-PV "ev_sch" READ
      ; Variable "stop" mit CAN-Identifier $90 und Event-PV "ev_stop" READ
      $00000100, "motor                  ","ev_mot                 ",$00000001
      $00000101, "schalter               ","ev_sch                 ",$00000000
      $00000090, "stop                   ","ev_stop                ",$00000000











                               @064[ Fortsetzung - Beispiel ]              @001[ öbersicht ]
.64
    CANrwtab - Variablen-Tabelle bearbeiten (Beispiel - Fortsetzung)

    Zyklischer Teil der Task:
      if (rc_def = 0) then
          if (ev_stop <> 0) then         ; STOP
              ev_stop = 0
              motor = 0                  ; Motor aus
              ev_mot = 1
          else if (ev_sch <> 0) then
              ev_sch = 0
              motor = 1                  ; Motor einschalten
              ev_mot = 1
          endif
          ; Zykl. Update der Daten z.B. alle 50 ms in der Taskklasse TC#2
          CANrwtab(enable,tab_id,rc_rw)
          if (rc_rw <> 0) then
              ; Fehlerbehandlung CANrwtab()
          endif
      endif


                                                                     @001[ öbersicht ]
.65
    CANrwtab - Variablen-Tabelle bearbeiten (Fortsetzung)

    <- Parameter <status    >: WORD

    Fehlernummern der Funktion CANrwtab():
    8802    Falscher Tabellen-Identifier ("tab_ident")
            (lokaler Funktionsblock-Speicher zerstîrt)
    8810    Sende-Queue voll
    8811    CAN-Bus ist BusOff
    8814    LÑnge einer Write-PV > 8 Byte

    Eine Liste aller mîglichen Fehlermeldungen der CAN-Library finden Sie im
    Anhang @300[Fehlermeldungen].








                                      @060[ CANrwtab ]                     @001[ öbersicht ]
.70
    CANnode - CAN-Knotennummer lesen

    @070[CANnode] (enable,node_nr,status)

    Parameter-Datentypen :
    ->  enable    : BIT           Der Funktionsblock wird nur ausgefÅhrt, wenn
                                  enable = 1 ist
    <-  node_nr   : BYTE          Knotennummer der CAN-Station ($00 bis $FF)
    <-  @071[status    ]: WORD          Fehlernummer (0 = kein Fehler)

    Bei einigen Modulen mit CAN-Schnittstellen wird die CAN-Knotennummer Åber
    zwei Hex-Schalter eingestellt. Mit der Funktion CANnode() kann die (mit
    Hilfe der Hex-Schalter) eingestellte CAN-Knotennummer ermittelt werden.
    Wenn kein Hex-Schalter fÅr die Knotennummer vorhanden ist, wird am Ausgang
    "status" eine entsprechende Fehlernummer ausgegeben.






                                                                     @001[ öbersicht ]
.71
    CANnode - CAN-Knotennummer lesen (Fortsetzung)

    <- Parameter <status    >: WORD

    Fehlernummern der Funktion CANnode():
    8825    Kein Nummernschalter vorhanden oder CAN2000-Treiber (CAN2000.BR)
            nicht installiert (< V1.40)

    Eine Liste aller mîglichen Fehlermeldungen der CAN-Library finden Sie im
    Anhang @300[Fehlermeldungen].











                                       @070[ CANnode ]                     @001[ öbersicht ]
.75
    CANxnode - CAN-Knotennummer des x-ten Knotenschalters lesen

    @075[CANxnode] (enable,us_ident,node_nr,status)

    Parameter-Datentypen :
    ->  enable    : BIT           Der Funktionsblock wird nur ausgefÅhrt, wenn
                                  enable = 1 ist
    ->  us_ident  : LONG          Anwender-Ident (von @020[CANopen])
    <-  node_nr   : BYTE          Knotennummer der CAN-Station ($00 bis $FF)
    <-  @076[status    ]: WORD          Fehlernummer (0 = kein Fehler)

    Bei einigen Modulen mit CAN-Schnittstellen wird die CAN-Knotennummer Åber
    zwei Hex-Schalter (sog. CAN-Knotenschalter) eingestellt. Mit der Funktion
    CANxnode() kann die, mit dem x-ten CAN-Knotenschalter eingestellte, Knoten-
    nummer ermittelt werden. Wenn der entsprechende CAN-Knotenschalter nicht
    vorhanden ist, wird am Ausgang "status" eine entsprechende Fehlernummer
    ausgegeben.
    FÅr IF-Module, die nur einen CAN-Knotenschalter, aber zwei CAN-Controller
    haben (z.B. IF672), wird fÅr den zweiten CAN-Controller die eingestellte
    Knotennummer plus 1 (Knotennummer + 1) zurÅckgegeben.

                                                                     @001[ öbersicht ]
.76
    CANxnode - CAN-Knotennummer des x-ten Knotenschalters lesen (Fortsetzung)

    <- Parameter <status    >: WORD

    Fehlernummern der Funktion CANxnode():
    8805    Falscher "us_ident"
    8825    Kein Nummernschalter vorhanden oder CAN2000-Treiber (CAN2000.BR)
            nicht installiert (< V1.40)

    Eine Liste aller mîglichen Fehlermeldungen der CAN-Library finden Sie im
    Anhang @300[Fehlermeldungen].










                                      @075[ CANxnode ]                     @001[ öbersicht ]
.80
    CMSinit - Liste von CMS-Objekten definieren

    @081[CMSinit] (enable,us_ident,user_type,queue_cnt,adr(modul_name),cms_entry,
             cms_ident,status)

    Parameter-Datentypen :
    ->  enable    : BIT           Der Funktionsblock wird nur ausgefÅhrt, wenn
                                  enable = 1 ist
    ->  us_ident  : LONG          Anwender-Ident (von @020[CANopen])
    ->  user_type : BYTE          0 ... CMS_k_CLIENT
                                  1 ... CMS_k_SERVER
    ->  queue_cnt : WORD          Dieser Parameter hat derzeit noch keine
                                  Funktion (Reserve).
    ->  modul_name: LONG          Name des Datenmoduls mit den CMS-Objekten
    <-  cms_entry : WORD          Fehler-Eintragsnummer oder Anzahl der
                                  CMS-Objekte im CMS-Datenmodul
    <-  cms_ident : LONG          CMS-Identifier fÅr @140[CMSmain]
    <-  @085[status    ]: WORD          Fehlernummer (0 = kein Fehler)



                                     @081[ Fortsetzung ]                   @001[ öbersicht ]
.81
    CMSinit - Liste von CMS-Objekten definieren (Fortsetzung)

    Mit Hilfe der Funktionsblîcke CMSinit() und CMSmain() kînnen CMS-Objekte
    gesendet und empfangen werden. Die CMS-Objekte werden in einem @110[Datenmodul]
    definiert, welches sowohl fÅr den Client als auch fÅr den Server verwendet
    werden kann. Die Unterscheidung zwischen Client und Server erfolgt in der
    Funktion CMSinit() durch den Eingangsparameter "user_type" (0 = Knotentyp
    Client, 1 = Knotentyp Server). Werden beide Typen (Client und Server) auf
    einem Knoten benîtigt, so mÅssen zwei Datenmodule erstellt werden.
    Die CMS-Dienst-Anforderung bzw. -Erkennung wird Åber sog. @090[Event-Variablen]
    (Event-PVs) gesteuert.

    Um Zykluszeitverletzungen zu vermeiden, sollte die Funktion CMSinit() nur
    im INIT-UP (Initialisierungs-Unterprogramm) der Task aufgerufen werden.
    Der Speicherbedarf fÅr die Verwaltung betrÑgt pro Eintrag im Datenmodul
    22 Byte + 54 Byte pro verwendeter CAN-ID. FÅr Multiplexed Variablen werden
    noch zusÑtzlich (Max-Multiplexer*2) Byte pro CAN-ID benîtigt.
    FÅr die Verwaltung im CAN2000-Treiber werden pro verwendetem Block 512 Byte
    allokiert, wobei die Bits 8 bis 10 der CAN-ID die Block-Nummer bestimmen.


                                     @082[ Fortsetzung ]                   @001[ öbersicht ]
.82
    CMSinit - Liste von CMS-Objekten definieren (Fortsetzung)

    Der Parameter "cms_ident" wird fÅr den Funktionsblock CMSmain() benîtigt.
    Mit dem Parameter "cms_entry" kann man von der Applikation aus fehlerhafte
    EintrÑge erkennen. Werden Variablen, welche im CMS-Datenmodul angegeben
    wurden, auf der RPS nicht gefunden, so wird am Ausgang "status" eine ent-
    sprechende Fehlernummer ausgegeben (der Funktionsblock wird aber trotzdem
    weiter abgearbeitet).













                                                                     @001[ öbersicht ]
.85
    CMSinit - Liste von CMS-Objekten definieren (Fortsetzung)

    <- Parameter <status    >: WORD

    Fehlernummern der Funktion CMSinit():
    3019    Datenmodul ("modul_name") nicht vorhanden
    8800    Zuwenig COBs vorhanden
            ("cob_anz" in CANopen() vergrî·ern)
    8801    Kein Speicher fÅr Ressourcen im Anwender-RAM frei
    8802    Falscher CMS-Identifier ("cms_ident")
            (lokaler Funktionsblock-Speicher zerstîrt)
    8804    Falscher CAN-Identifier (> 2047)
    8805    Falscher "us_ident"
    8806    COB schon definiert
    8813    CAN-Treiber (CAN2000.BR) nicht installiert
    8814    Falscher Datentyp der Event-PV (BYTE) oder ungÅltige
            DatenlÑnge der PV
    8821    Falscher "user_type"
            ("user_type" = 0 ... Client, "user_type" = 1 ... Server)


                                     @086[ Fortsetzung ]                   @001[ öbersicht ]
.86
    CMSinit - Liste von CMS-Objekten definieren (Fortsetzung)

    8822    Syntax-Fehler bei der Definition der CMS-Objekte im Datenmodul
            (siehe "cms_entry")
    8823    Komplexe Struktur nicht erlaubt
    147xx   Variable fehlt oder Syntax des Variablennamens falsch
            (xx ist ein Wert zwischen 00 und 15)

    Eine Liste aller mîglichen Fehlermeldungen der CAN-Library finden Sie im
    Anhang @300[Fehlermeldungen].











                                       @080[ CMSinit ]                     @001[ öbersicht ]
.90
    CMSinit - Liste von CMS-Objekten definieren (Fortsetzung)

    Steuerung der CMS-Objekte Åber Event-Variablen:
    Die Event-Variablen werden entweder von der Applikation aus gesetzt, um
    bestimmte CAN-Nachrichten Åber den Funktionsblock CMSmain() zu versenden,
    oder sie werden beim Empfang von CAN-Nachrichten vom CAN2000-Treiber im
    CAN2000-Interrupt wieder rÅckgesetzt.

    @091[Steuerung der Event-Variablen am Client]
    @098[Steuerung der Event-Variablen am Server]

    Achtung:
    Das RÅcksetzen der Event-Variablen erfolgt im CAN-Interrupt asynchron zur
    zyklischen RPS-Task, d.h. es kînnen sehr wohl mehrere CAN-Nachrichten
    zwischen zwei CMSmain() Aufrufen auf dasselbe CMS-Objekt gesendet werden,
    wobei nur die letzten Daten in der zugewiesenen Variable gepuffert werden.
    Es mu· daher von der Applikation aus am CAN-Bus garantiert werden, da· die
    Inhibite-Zeiten eingehalten werden und somit keine Daten verloren gehen
    kînnen.


    @110[ CMS-Datenmodul ]       @120[ COB-Vergabe fÅr die CMS-Objekte ]         @001[ öbersicht ]
.91
    CMSinit - Liste von CMS-Objekten definieren (Fortsetzung)

    Steuerung der Event-Variablen am Client:
    In der folgenden Tabelle sind die öbergÑnge der Event-Variable fÅr die an-
    gegebenen CMS-Objekte angegeben.
    In der Tabelle werden folgende AbkÅrzungen verwendet:
    R.O. ....... ReadOnly
    W.O. ....... WriteOnly
    B.Var. ..... Basic Variable
    M.Var. ..... Multiplexed Variable
    R/W Var. ... R/W Variable
 …ÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
 ∫ Client ≥          ≥     Zustand der Event-Variable     ≥                   ∫
 «ƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
 ∫ Dienst ≥ Objekt-  ≥   Appli-   ≥ CMSmain  ≥  CAN2000   ≥ Ereignis          ∫
 ∫        ≥ typ      ≥   kation   ≥          ≥            ≥                   ∫
 ÃÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ
 ∫ R.O.   ≥ B.Var.   ≥   0 -> 1   ≥          ≥            ≥ RTR-Request ist   ∫
 ∫        ≥          ≥            ≥          ≥            ≥ zu senden         ∫
 »ÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº

                                     @092[ Fortsetzung ]                   @001[ öbersicht ]
.92
    CMSinit - Liste von CMS-Objekten definieren (Fortsetzung)

 …ÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
 ∫ Client ≥          ≥     Zustand der Event-Variable     ≥                   ∫
 «ƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
 ∫ Dienst ≥ Objekt-  ≥   Appli-   ≥ CMSmain  ≥  CAN2000   ≥ Ereignis          ∫
 ∫        ≥ typ      ≥   kation   ≥          ≥            ≥                   ∫
 ÃÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ
 ∫ R.O.   ≥ B.Var.   ≥            ≥ 1 -> $40 ≥            ≥ RTR-Request wird  ∫
 ∫        ≥          ≥            ≥          ≥            ≥ gesendet          ∫
 «ƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
 ∫ R.O.   ≥ B.Var.   ≥            ≥          ≥  $40 -> 0  ≥ Confirmation      ∫
 ∫        ≥          ≥            ≥          ≥            ≥ wurde empfangen   ∫
 «ƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
 ∫ W.O.   ≥ B.Var.   ≥   0 -> 1   ≥          ≥            ≥ Request ist zu    ∫
 ∫        ≥          ≥            ≥          ≥            ≥ senden            ∫
 «ƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
 ∫ W.O.   ≥ B.Var.   ≥            ≥ 1 -> $40 ≥            ≥ Request wird      ∫
 ∫        ≥          ≥            ≥          ≥            ≥ gesendet          ∫
 »ÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº

                                     @093[ Fortsetzung ]                   @001[ öbersicht ]
.93
    CMSinit - Liste von CMS-Objekten definieren (Fortsetzung)

 …ÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
 ∫ Client ≥          ≥     Zustand der Event-Variable     ≥                   ∫
 «ƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
 ∫ Dienst ≥ Objekt-  ≥   Appli-   ≥ CMSmain  ≥  CAN2000   ≥ Ereignis          ∫
 ∫        ≥ typ      ≥   kation   ≥          ≥            ≥                   ∫
 ÃÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ
 ∫ W.O.   ≥ B.Var.   ≥            ≥          ≥  $40 -> 0  ≥ Request wurde am  ∫
 ∫        ≥          ≥            ≥          ≥            ≥ CAN-Bus gesendet  ∫
 «ƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
 ∫ R.O.   ≥ M.Var.   ≥   0 -> 1   ≥          ≥            ≥ Request ist zu    ∫
 ∫        ≥          ≥            ≥          ≥            ≥ senden            ∫
 «ƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
 ∫ R.O.   ≥ M.Var.   ≥            ≥ 1 -> $40 ≥            ≥ Request wird      ∫
 ∫        ≥          ≥            ≥          ≥            ≥ gesendet          ∫
 «ƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
 ∫ R.O.   ≥ M.Var.   ≥            ≥          ≥ $40 -> $80 ≥ Request wurde     ∫
 ∫        ≥          ≥            ≥          ≥            ≥ gesendet          ∫
 »ÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº

                                     @094[ Fortsetzung ]                   @001[ öbersicht ]
.94
    CMSinit - Liste von CMS-Objekten definieren (Fortsetzung)

 …ÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
 ∫ Client ≥          ≥     Zustand der Event-Variable     ≥                   ∫
 «ƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
 ∫ Dienst ≥ Objekt-  ≥   Appli-   ≥ CMSmain  ≥  CAN2000   ≥ Ereignis          ∫
 ∫        ≥ typ      ≥   kation   ≥          ≥            ≥                   ∫
 ÃÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ
 ∫ R.O.   ≥ M.Var.   ≥            ≥          ≥ $80 -> 0   ≥ Confirmation      ∫
 ∫        ≥          ≥            ≥          ≥            ≥ wurde empfangen   ∫
 «ƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
 ∫ W.O.   ≥ M.Var.   ≥   0 -> 1   ≥          ≥            ≥ Request ist zu    ∫
 ∫        ≥          ≥            ≥          ≥            ≥ senden            ∫
 «ƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
 ∫ W.O.   ≥ M.Var.   ≥            ≥ 1 -> $40 ≥            ≥ Request wird      ∫
 ∫        ≥          ≥            ≥          ≥            ≥ gesendet          ∫
 «ƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
 ∫ W.O.   ≥ M.Var.   ≥            ≥          ≥ $40 -> 0   ≥ Request wurde am  ∫
 ∫        ≥          ≥            ≥          ≥            ≥ CAN-Bus gesendet  ∫
 »ÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº

                                     @095[ Fortsetzung ]                   @001[ öbersicht ]
.95
    CMSinit - Liste von CMS-Objekten definieren (Fortsetzung)

 …ÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
 ∫ Client ≥          ≥     Zustand der Event-Variable     ≥                   ∫
 «ƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
 ∫ Dienst ≥ Objekt-  ≥   Appli-   ≥ CMSmain  ≥  CAN2000   ≥ Ereignis          ∫
 ∫        ≥ typ      ≥   kation   ≥          ≥            ≥                   ∫
 ÃÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ
 ∫ Read   ≥ R/W Var. ≥   0 -> 1   ≥          ≥            ≥ Read Request      ∫
 ∫        ≥          ≥            ≥          ≥            ≥ ist zu senden     ∫
 «ƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
 ∫ Read   ≥ R/W Var. ≥            ≥ 1 -> $40 ≥            ≥ Read Request      ∫
 ∫        ≥          ≥            ≥          ≥            ≥ wird gesendet     ∫
 «ƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
 ∫ Read   ≥ R/W Var. ≥            ≥          ≥ $40 -> $80 ≥ Read Request      ∫
 ∫        ≥          ≥            ≥          ≥            ≥ wurde gesendet    ∫
 «ƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
 ∫ Read   ≥ R/W Var. ≥            ≥          ≥  xx -> $FF ≥ Failure Frame     ∫
 ∫        ≥          ≥            ≥          ≥            ≥ empfangen         ∫
 »ÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº

                                     @096[ Fortsetzung ]                   @001[ öbersicht ]
.96
    CMSinit - Liste von CMS-Objekten definieren (Fortsetzung)

 …ÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
 ∫ Client ≥          ≥     Zustand der Event-Variable     ≥                   ∫
 «ƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
 ∫ Dienst ≥ Objekt-  ≥   Appli-   ≥ CMSmain  ≥  CAN2000   ≥ Ereignis          ∫
 ∫        ≥ typ      ≥   kation   ≥          ≥            ≥                   ∫
 ÃÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ
 ∫ Read   ≥ R/W Var. ≥            ≥          ≥ $80 -> 0   ≥ Read Confirmation ∫
 ∫        ≥          ≥            ≥          ≥            ≥ wurde empfangen   ∫
 «ƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
 ∫ Write  ≥ R/W Var. ≥   0 -> 2   ≥          ≥            ≥ Write Request     ∫
 ∫        ≥          ≥            ≥          ≥            ≥ ist zu senden     ∫
 «ƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
 ∫ Write  ≥ R/W Var. ≥            ≥ 2 -> $40 ≥            ≥ Write Request     ∫
 ∫        ≥          ≥            ≥          ≥            ≥ wird gesendet     ∫
 «ƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
 ∫ Write  ≥ R/W Var. ≥            ≥          ≥ $40 -> $80 ≥ Write Request     ∫
 ∫        ≥          ≥            ≥          ≥            ≥ wurde gesendet    ∫
 »ÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº

                                     @097[ Fortsetzung ]                   @001[ öbersicht ]
.97
    CMSinit - Liste von CMS-Objekten definieren (Fortsetzung)

 …ÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
 ∫ Client ≥          ≥     Zustand der Event-Variable     ≥                   ∫
 «ƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
 ∫ Dienst ≥ Objekt-  ≥   Appli-   ≥ CMSmain  ≥  CAN2000   ≥ Ereignis          ∫
 ∫        ≥ typ      ≥   kation   ≥          ≥            ≥                   ∫
 ÃÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ
 ∫ Write  ≥ R/W Var. ≥            ≥          ≥  xx -> $FF ≥ Failure Frame     ∫
 ∫        ≥          ≥            ≥          ≥            ≥ empfangen         ∫
 «ƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
 ∫ Write  ≥ R/W Var. ≥            ≥          ≥ $80 -> 0   ≥ Write Confirmation∫
 ∫        ≥          ≥            ≥          ≥            ≥ wurde empfangen   ∫
 »ÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº







                                   @090[ Event-Variable ]                  @001[ öbersicht ]
.98
    CMSinit - Liste von CMS-Objekten definieren (Fortsetzung)

    Steuerung der Event-Variablen am Server:
    In der folgenden Tabelle sind die öbergÑnge der Event-Variable fÅr die an-
    gegebenen CMS-Objekte angegeben.
    In der Tabelle werden folgende AbkÅrzungen verwendet:
    R.O. ....... ReadOnly
    W.O. ....... WriteOnly
    B.Var. ..... Basic Variable
    M.Var. ..... Multiplexed Variable
    R/W Var. ... R/W Variable
 …ÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
 ∫ Client ≥          ≥   Zustand der Event-Variable   ≥                     ∫
 «ƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
 ∫ Dienst ≥ Objekt-  ≥  Appli-  ≥ CMSmain  ≥ CAN2000  ≥ Ereignis            ∫
 ∫        ≥ typ      ≥  kation  ≥          ≥          ≥                     ∫
 ÃÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ
 ∫ R.O.   ≥ B.Var.   ≥  0 -> 1  ≥          ≥          ≥ Daten in CMSmain in ∫
 ∫        ≥          ≥          ≥          ≥          ≥ Controller kopieren ∫
 »ÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº

                                     @099[ Fortsetzung ]                   @001[ öbersicht ]
.99
    CMSinit - Liste von CMS-Objekten definieren (Fortsetzung)

 …ÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
 ∫ Client ≥          ≥   Zustand der Event-Variable   ≥                     ∫
 «ƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
 ∫ Dienst ≥ Objekt-  ≥  Appli-  ≥ CMSmain  ≥ CAN2000  ≥ Ereignis            ∫
 ∫        ≥ typ      ≥  kation  ≥          ≥          ≥                     ∫
 ÃÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ
 ∫ R.O.   ≥ B.Var.   ≥          ≥  1 -> 0  ≥          ≥ Daten wurden in den ∫
 ∫        ≥          ≥          ≥          ≥          ≥ Controller kopiert  ∫
 «ƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
 ∫ W.O.   ≥ B.Var.   ≥          ≥          ≥  xx -> 1 ≥ Write Indication    ∫
 ∫        ≥          ≥          ≥          ≥          ≥ wurde empfangen     ∫
 «ƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
 ∫ R.O.   ≥ M.Var.   ≥          ≥          ≥  xx -> 1 ≥ Read-Indication     ∫
 ∫        ≥          ≥          ≥          ≥          ≥ wurde empfangen     ∫
 «ƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
 ∫ R.O.   ≥ M.Var.   ≥          ≥ 1 -> $40 ≥          ≥ Read-Response       ∫
 ∫        ≥          ≥          ≥          ≥          ≥ wird gesendet       ∫
 »ÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº

                                     @100[ Fortsetzung ]                   @001[ öbersicht ]
.100
    CMSinit - Liste von CMS-Objekten definieren (Fortsetzung)

 …ÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
 ∫ Client ≥          ≥   Zustand der Event-Variable   ≥                     ∫
 «ƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
 ∫ Dienst ≥ Objekt-  ≥  Appli-  ≥ CMSmain  ≥ CAN2000  ≥ Ereignis            ∫
 ∫        ≥ typ      ≥  kation  ≥          ≥          ≥                     ∫
 ÃÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ
 ∫ R.O.   ≥ M.Var.   ≥          ≥          ≥ $40 -> 0 ≥ Read-Response       ∫
 ∫        ≥          ≥          ≥          ≥          ≥ wird gesendet       ∫
 «ƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
 ∫ W.O.   ≥ M.Var.   ≥          ≥          ≥  xx -> 1 ≥ Write-Indication    ∫
 ∫        ≥          ≥          ≥          ≥          ≥ wurde empfangen     ∫
 «ƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
 ∫ Read   ≥ R/W Var. ≥          ≥          ≥  xx -> 1 ≥ Read-Indication     ∫
 ∫        ≥          ≥          ≥          ≥          ≥ wurde empfangen     ∫
 «ƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
 ∫ Read   ≥ R/W Var. ≥          ≥ 1 -> $40 ≥          ≥ Read-Response       ∫
 ∫        ≥          ≥          ≥          ≥          ≥ wird gesendet       ∫
 »ÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº

                                     @101[ Fortsetzung ]                   @001[ öbersicht ]
.101
    CMSinit - Liste von CMS-Objekten definieren (Fortsetzung)

 …ÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
 ∫ Client ≥          ≥   Zustand der Event-Variable   ≥                     ∫
 «ƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
 ∫ Dienst ≥ Objekt-  ≥  Appli-  ≥ CMSmain  ≥ CAN2000  ≥ Ereignis            ∫
 ∫        ≥ typ      ≥  kation  ≥          ≥          ≥                     ∫
 ÃÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ
 ∫ Read   ≥ R/W Var. ≥          ≥          ≥ $40 -> 0 ≥ Read-Response       ∫
 ∫        ≥          ≥          ≥          ≥          ≥ wurde gesendet      ∫
 «ƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
 ∫ Write  ≥ R/W Var. ≥          ≥          ≥  xx -> 2 ≥ Write-Indication    ∫
 ∫        ≥          ≥          ≥          ≥          ≥ wurde empfangen     ∫
 «ƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
 ∫ Write  ≥ R/W Var. ≥          ≥ 2 -> $40 ≥          ≥ Write-Response      ∫
 ∫        ≥          ≥          ≥          ≥          ≥ wird gesendet       ∫
 «ƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
 ∫ Write  ≥ R/W Var. ≥          ≥          ≥ $40 -> 0 ≥ Write-Response      ∫
 ∫        ≥          ≥          ≥          ≥          ≥ wurde gesendet      ∫
 »ÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº

                                   @090[ Event-Variable ]                  @001[ öbersicht ]
.110
    CMSinit - Liste von CMS-Objekten definieren (Fortsetzung)

    CMS-Datenmodul fÅr Client und Server:
    Das Datenmodul kann im PG2000 definiert werden und beinhaltet alle CMS-
    Objekte, welche im CAN-Netzwerk verwendet werden kînnen. Dieses Datenmodul
    kann sowohl fÅr den Client als auch fÅr den Server verwendet werden. Die
    Unterscheidung zwischen Client und Server erfolgt in der Funktion CMSinit()
    durch den Eingangsparameter "user_type" (0 = Client, 1 = Server).
    Werden fÅr mehrere CMS-Server-Knoten unterschiedliche Datenmodule benîtigt,
    so werden diese auch am CMS-Client-Knoten mit der Funktion CMSinit() Åber-
    geben. Bei der Definition der Identifier fÅr Client und Server ist darauf
    zu achten, da· die COBs fÅr diese Identifier nur einmal pro Knoten
    definiert werden kînnen.








                                     @111[ Fortsetzung ]                   @001[ öbersicht ]
.111
    CMSinit - Liste von CMS-Objekten definieren (Fortsetzung)

      ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ @112[ 1.]
      ≥      ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ @112[ 2.]
      ≥      ≥         ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ @112[ 3.]
      ≥      ≥         ≥      ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ @113[ 4.]
      ≥      ≥         ≥      ≥   ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ @113[ 5.]
      ≥      ≥         ≥      ≥   ≥   ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ @114[ 6.]
      ≥      ≥         ≥      ≥   ≥   ≥      ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ @114[ 7.]
      ≥      ≥         ≥      ≥   ≥   ≥      ≥        ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ @114[ 8.]
      ≥      ≥         ≥      ≥   ≥   ≥      ≥        ≥         ⁄ƒƒƒƒƒƒƒƒƒƒƒ @116[ 9.]
      ≥      ≥         ≥      ≥   ≥   ≥      ≥        ≥         ≥         ⁄ƒ @116[10.]
     ƒ¡ƒ ƒƒƒƒ¡ƒƒƒƒ ƒƒƒƒ¡ƒƒƒƒ ƒ¡ƒ ƒ¡ƒ ƒ¡ƒ ƒƒƒƒ¡ƒƒƒ ƒƒƒƒ¡ƒƒƒƒ ƒƒƒƒ¡ƒƒƒƒ ƒƒƒƒ¡ƒƒƒƒƒ
    "%%P",$00000300,$00000000,'R','B',000,00000000,$00000000,"bvar_re","ebvar_re"
    "%%P",$00000101,$00000201,'R','M',001,00000000,$00000000,"mvar_re","emvar_re"
    "%%P",$00000000,$00000202,'W','B',000,00000000,$0000000c,"bvar_wr","ebvar_wr"
    ; hochpriores Objekt !
    "%%P",$00000103,$00000203,'W','M',002,00000000,$00000000,"mvar_wr","emvar_wr"



    @090[ Event-Variable ]       @120[ COB-Vergabe fÅr die CMS-Objekte ]         @001[ öbersicht ]
.112
    CMSinit - Liste von CMS-Objekten definieren (Fortsetzung)

     1. Bezeichnung:  start_str
        Datentyp:     BYTE (FELD)
        LÑnge:        3
        Beschreibung: Kennung fÅr neuen CMS-Eintrag ("%%P")

     2. Bezeichnung:  client_id
        Datentyp:     LONG
        LÑnge:        4
        Beschreibung: Client-CAN-Identifier

     3. Bezeichnung:  server_id
        Datentyp:     LONG
        LÑnge:        4
        Beschreibung: Server-CAN-Identifier





    @111[ CMS-Datenmodul ]                 @113[ Fortsetzung ]                   @001[ öbersicht ]
.113
    CMSinit - Liste von CMS-Objekten definieren (Fortsetzung)

     4. Bezeichnung:  access_typ
        Datentyp:     BYTE
        LÑnge:        1
        Beschreibung: Zugriff auf das Objekt (ReadOnly, WriteOnly, Read/Write,
                      DL, UL, usw.):
                      'R' ... ReadOnly
                      'W' ... WriteOnly
                      'A' ... Read/Write

     5. Bezeichnung:  object_typ
        Datentyp:     BYTE
        LÑnge:        1
        Beschreibung: Typ des Objektes (Basic Variable, Multiplexed Variable,
                      Domain, Events, usw.):
                      'B' ... Basic Variable
                      'M' ... Multiplexed Variable



    @111[ CMS-Datenmodul ]                 @114[ Fortsetzung ]                   @001[ öbersicht ]
.114
    CMSinit - Liste von CMS-Objekten definieren (Fortsetzung)

     6. Bezeichnung:  mux_nr
        Datentyp:     BYTE
        LÑnge:        1
        Beschreibung: Multiplexer fÅr Multiplexed Variable (0 - 127)

     7. Bezeichnung:  len
        Datentyp:     LONG
        LÑnge:        4
        Beschreibung: LÑnge der Daten (z.B. bei Domains)

     8. Bezeichnung:  info
        Datentyp:     LONG
        LÑnge:        4
        Beschreibung: ZusÑtzliche Informationen:
                      Bit 0 = 0   CMS-Format laut CiA/DS202-3
                      Bit 0 = 1   B&R-Format: keine Konvertierung laut CiA,
                                  daher bessere Leistung in der Interrupt-
                                  behandlung von Feldern und Strukturen.

                                     @115[ Fortsetzung ]                   @001[ öbersicht ]
.115
    CMSinit - Liste von CMS-Objekten definieren (Fortsetzung)

                                  Dieses Format kann bei der Kommunikation
                                  B&R2000 CPU <-> B&R2000 CPU verwendet werden.
                      Bit 1       Reserve
                      Bit 2 = 0   StandardprioritÑt: Transmit-Behandlung Åber
                                  Sende-Queue (Transmit Queue) siehe CANwrite().
                      Bit 2 = 1   Hochpriores Objekt: Pro CAN-Knoten kînnen
                                  max. 13 Objekte definiert werden, welche im
                                  CAN-Controller einen eigenen Puffer zugeteilt
                                  bekommen (ist nur fÅr Sende-Richtung mîglich).
                                  Achtung: Auch Basic Variablen mit ReadOnly-
                                  Zugriff werden in diesen Pufferbereich gelegt.
                      Bit 3 = 1   Overwrite-Modus: FÅr hochpriore Objekte kann
                                  in diesem Modus der Puffer im CAN-Controller
                                  jederzeit Åberschrieben werden. Es erfolgt
                                  keine Kontrolle, ob die zuletzt Åbergebenen
                                  Daten gesendet wurden.



    @111[ CMS-Datenmodul ]                 @116[ Fortsetzung ]                   @001[ öbersicht ]
.116
    CMSinit - Liste von CMS-Objekten definieren (Fortsetzung)

     9. Bezeichnung:  pv_name
        Datentyp:     BYTE (FELD)
        LÑnge:        max. 32
        Beschreibung: Name der PV (Syntax wie PG2000)

    10. Bezeichnung:  ev_pv_name
        Datentyp:     BYTE (FELD)
        LÑnge:        max. 32
        Beschreibung: Name der Event-PV (Syntax wie PG2000)










                                   @111[ CMS-Datenmodul ]                  @001[ öbersicht ]
.120
    CMSinit - Liste von CMS-Objekten definieren (Fortsetzung)

    COB-Vergabe der CMS-Objekte fÅr Client und Server:
    FÅr die im Datenmodul definierten CMS-Objekte werden Kommunikationsobjekte
    (COB = Kommunikationsobjekt) am Client- und am Server-Knoten (abhÑngig vom
    "@113[object_typ]" und vom "@113[access_typ]") definiert. Die COBs mit den angegebenen
    Identifiern kînnen pro Knoten nur einmal definiert werden.
    FÅr die RTR-Dienste stehen pro Knoten maximal 13 Objekte (freie Puffer im
    CAN-Controller) zur VerfÅgung.

    Basic Variable:
     - @121[ReadOnly  ]
     - @122[WriteOnly ]
     - @123[Read/Write]

    Multiplexed Variable
     - @125[ReadOnly  ]
     - @126[WriteOnly ]
     - @127[Read/Write]


    @090[ Event-Variable ]               @110[ CMS-Datenmodul ]                  @001[ öbersicht ]
.121
    CMSinit - Liste von CMS-Objekten definieren (Fortsetzung)

    Basic Variable: ReadOnly
    Dieser Dienst wird Åber eine RTR-Anforderung (RTR-Request) abgebildet
    (max. 10 pro Knoten).

    Client-Knoten:                                           Server-Knoten:
    --------------                                           --------------
    COB-Definition                                           COB-Definition
    Receive RTR-COB                                          Transmit RTR-COB
    mit Client-ID                                            mit Client-ID

                             ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø
    ev_pv=1 + CMSmain    --->≥    RTR mit Client-ID     ≥
                             ¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ
                         ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø
                         ≥    Data mit Client-ID    ≥<---    RTR Response des
                         ¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ        CAN-Controllers



                           @120[ COB-Vergabe fÅr die CMS-Objekte ]         @001[ öbersicht ]
.122
    CMSinit - Liste von CMS-Objekten definieren (Fortsetzung)

    Basic Variable: WriteOnly

    Client-Knoten:                                           Server-Knoten:
    --------------                                           --------------
    COB-Definition                                           COB-Definition
    Transmit COB                                             Receive COB
    mit Server-ID                                            mit Server-ID

                             ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø
    ev_pv=1 + CMSmain    --->≥    Data mit Server-ID    ≥    ev_pv=1
    ev_pv=0 (CAN2000)        ¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ








                           @120[ COB-Vergabe fÅr die CMS-Objekte ]         @001[ öbersicht ]
.123
    CMSinit - Liste von CMS-Objekten definieren (Fortsetzung)

    Basic Variable: Read/Write

    Client-Knoten:                                           Server-Knoten:
    --------------                                           --------------
    COB-Definition                                           COB-Definition
    Receive COB mit                                          Transmit COB mit
    Client-ID                                                Client-ID
    Transmit COB mit                                         Receive COB mit
    Server-ID                                                Server-ID

    Read:
                             ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø
    ev_pv=1 + CMSmain    --->≥  ReadReq. mit Server-ID  ≥    ev_pv=1 (CAN2000)
                             ¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ
                         ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø
    ev_pv=0 (CAN2000)    ≥    Data mit Client-ID    ≥<---    CMSmain
                         ¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ        ev_pv=0 (CAN2000)


                                     @124[ Fortsetzung ]                   @001[ öbersicht ]
.124
    CMSinit - Liste von CMS-Objekten definieren (Fortsetzung)

    Write:
                             ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø
    ev_pv=2 + CMSmain    --->≥    Data mit Server-ID    ≥    ev_pv=2 (CAN2000)
                             ¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ
                         ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø
    ev_pv=0 (CAN2000)    ≥ WriteResp. mit Client-ID ≥<---    CMSmain
                         ¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ        ev_pv=0 (CAN2000)












                           @120[ COB-Vergabe fÅr die CMS-Objekte ]         @001[ öbersicht ]
.125
    CMSinit - Liste von CMS-Objekten definieren (Fortsetzung)

    Multiplexed Variable: ReadOnly

    Client-Knoten:                                           Server-Knoten:
    --------------                                           --------------
    COB-Definition                                           COB-Definition
    Receive COB mit                                          Transmit COB mit
    Client-ID                                                Client-ID
    Transmit COB mit                                         Receive COB mit
    Server-ID                                                Server-ID

                             ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø
    ev_pv=1 + CMSmain    --->≥ ReadReq. mit Server-ID ≥      ev_pv=1 (CAN2000)
                             ¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ
                         ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø
    ev_pv=0 (CAN2000)    ≥   Data mit Client-ID   ≥<---      CMSmain
                         ¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ          ev_pv=0 (CAN2000)



                           @120[ COB-Vergabe fÅr die CMS-Objekte ]         @001[ öbersicht ]
.126
    CMSinit - Liste von CMS-Objekten definieren (Fortsetzung)

    Multiplexed Variable: WriteOnly

    Client-Knoten:                                           Server-Knoten:
    --------------                                           --------------
    COB-Definition                                           COB-Definition
    Transmit COB mit                                         Receive COB mit
    Server-ID                                                Server-ID

                             ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø
    ev_pv=1 + CMSmain    --->≥   Data mit Server-ID   ≥      ev_pv=1
                             ¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ








                           @120[ COB-Vergabe fÅr die CMS-Objekte ]         @001[ öbersicht ]
.127
    CMSinit - Liste von CMS-Objekten definieren (Fortsetzung)

    Multiplexed Variable: Read/Write

    Client-Knoten:                                           Server-Knoten:
    --------------                                           --------------
    COB-Definition                                           COB-Definition
    Receive COB mit                                          Transmit COB mit
    Client-ID                                                Client-ID
    Transmit COB mit                                         Receive COB mit
    Server-ID                                                Server-ID

    Read:
                             ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø
    ev_pv=1 + CMSmain    --->≥  ReadReq. mit Server-ID  ≥    ev_pv=1 (CAN2000)
                             ¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ
                         ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø
    ev_pv=0 (CAN2000)    ≥    Data mit Client-ID    ≥<---    CMSmain
                         ¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ


                                     @128[ Fortsetzung ]                   @001[ öbersicht ]
.128
    CMSinit - Liste von CMS-Objekten definieren (Fortsetzung)

    Write:
                             ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø
    ev_pv=2 + CMSmain    --->≥    Data mit Server-ID    ≥    ev_pv=2 (CAN2000)
                             ¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ
                         ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø
    ev_pv=0 (CAN2000)    ≥ WriteResp. mit Client-ID ≥<---    CMSmain
                         ¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ












                           @120[ COB-Vergabe fÅr die CMS-Objekte ]         @001[ öbersicht ]
.140
    CMSmain - Liste von CMS-Objekten bearbeiten

    @141[CMSmain] (enable,cms_ident,cms_mode,status)

    Parameter-Datentypen :
    ->  enable    : BIT           Der Funktionsblock wird nur ausgefÅhrt, wenn
                                  enable = 1 ist
    ->  cms_ident : LONG          CMS-Identifier (von @080[CMSinit])
    ->  cms_mode  : LONG          2 ... Senden/Update der Daten
    <-  @145[status    ]: WORD          Fehlernummer (0 = kein Fehler)

    Mit der Funktion CMSmain() kann die mit CMSinit() definierte Liste von
    CMS-Objekten bearbeitet werden. Die Funktion CMSmain() ist vom Benutzer
    zyklisch aufzurufen, um fÅr die CMS-Objekte die entsprechenden Aktionen
    einzuleiten. öber die @090[Event-PVs] kînnen die Ereignisse von der Applikation
    aus gesteuert und kontrolliert werden. Ein Senden der Daten wird dadurch
    angezeigt, da· die Applikation die Event-PV auf den Wert 1 (oder 2) setzt.
    Wurden die Daten erfolgreich Åber den CAN-Bus gesendet, so wird diese
    Event-PV vom CAN2000-Treiber im CAN-Interrupt wieder auf 0 gesetzt.


                                      @141[ Beispiel ]                     @001[ öbersicht ]
.141
    CMSmain - Liste von CMS-Objekten bearbeiten (Beispiel)

    Beispiel mit CMSinit() und CMSmain():
    Im PG2000 mu· ein Datenmodul mit den CMS-Objekten angelegt werden.

    Datenmodul "cms_s1" erstellt im PG2000:

    ;str≥client-ID≥server-ID≥acc≥obj≥mul≥  len   ≥  info   ≥variable ≥ event_pv
    ;ƒƒƒ≈ƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒ≈ƒƒƒ≈ƒƒƒ≈ƒƒƒ≈ƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ
    "%%P",$00000300,$00000000,'R','B',000,00000000,$00000000,"bvar_re","ebvar_re"
    "%%P",$00000101,$00000201,'R','M',001,00000000,$00000000,"mvar_re","emvar_re"
    "%%P",$00000000,$00000202,'W','B',000,00000000,$0000000c,"bvar_wr","ebvar_wr"
    ; hochpriores Objekt !
    "%%P",$00000103,$00000203,'W','M',002,00000000,$00000000,"mvar_wr","emvar_wr"







                               @142[ Fortsetzung - Beispiel ]              @001[ öbersicht ]
.142
    CMSmain - Liste von CMS-Objekten bearbeiten (Beispiel - Fortsetzung)

    INIT-UP der Task:
      enable = 1
      ebvar_re = 0            ; Event-PV initialisieren
      emvar_re = 0            ; Event-PV initialisieren
      ebvar_wr = 0            ; Event-PV initialisieren
      emvar_wr = 0            ; Event-PV initialisieren
      rc_def = 1              ; rc_def fÅr den zyklischen Teil auf 1
                              ; inititialisieren
      baud_rate = 25          ; Baudrate = 250kBit/s
      cob_anz = 10
      CANopen(enable,baud_rate,cob_anz,adr(error),0,0,op_ident,rc_open)
      if (rc_open = 0) then
          ; Einstellung fÅr Client- oder Server-Knoten
          usertyp = CLIENT    ; 0 = Client
          usertyp = SERVER    ; 1 = Server
          queue_cnt = 0       ; Keine Receive-Queue anlegen
          CMSinit(enable,op_ident,user_typ,queue_cnt,"cms_s1",cms_entry,
                  cms_ident,ci_status)
      endif
                               @143[ Fortsetzung - Beispiel ]              @001[ öbersicht ]
.143
    CMSmain - Liste von CMS-Objekten bearbeiten (Beispiel - Fortsetzung)

    Zyklischer Teil der Task:
      if (ci_status = 0) then
          if usertyp = CLIENT then
              ; Basic Variable - ReadOnly         ID=$300
              if ebvar_re = 0 then
                  ebvar_re = 1
              endif
              ; Basic Variable - WriteOnly        ID=$202
              bvar_wr = bvar_wr + 1
              if ebvar_wr = 0 then
                  ebvar_wr = 1
              endif
              ; Multiplexed Variable - WriteOnly  ID=$203
              mvar_wr = mvar_wr + 1
              if emvar_wr = 0 then
                  emvar_wr = 1
              endif


                               @144[ Fortsetzung - Beispiel ]              @001[ öbersicht ]
.144
    CMSmain - Liste von CMS-Objekten bearbeiten (Beispiel - Fortsetzung)

              ; Read Variable - Read/Write         ID=$210
              if ebvar0rw = 0 then
                  ebvar0rw = READ
              endif
          else
              ; Server
              ebvar_re = 1    ; Update RTR-Puffer
          endif
          CMSmain(1,cms_ident,WRITE,cm_status)
      endif









                                                                     @001[ öbersicht ]
.145
    CMSmain - Liste von CMS-Objekten bearbeiten (Fortsetzung)

    <- Parameter <status    >: WORD

    Fehlernummern der Funktion CMSmain():
    8802    Falscher CMS-Identifier ("cms_ident")
    8810    Sende-Queue voll
    8811    CAN-Bus ist BusOff
    8824    Falscher "cms_mode"
    8876    Sendepuffer nicht frei (busy), wenn z.B. hochpriores Objekt ohne
            Overwrite-Modus definiert wurde

    Eine Liste aller mîglichen Fehlermeldungen der CAN-Library finden Sie im
    Anhang @300[Fehlermeldungen].







                                       @140[ CMSmain ]                     @001[ öbersicht ]
.150
    CANqueue - Definieren einer Empfangsqueue fÅr einen CAN Identifier

    @0151[CANqueue] (enable,us_ident,can_id,size,q_ident,status)

    Parameter-Datentypen :
    ->  enable    : BIT           Der Funktionsblock wird nur ausgefÅhrt, wenn
                                  enable = 1 ist
    ->  us_ident  : LONG          Anwender-Ident (von @020[CANopen])
    ->  can_id    : LONG          CAN-Identifier fÅr die Empfangsqueue
    ->  size      : WORD          Anzahl der Telegramme in der Queue
                                  size=0 -> Inhalt der Queue lîschen
    <-  q_ident   : LONG          Identifier fÅr den Fub CANrd
    <-  @0152[status    ]: WORD          Fehlernummer (0 = kein Fehler)

    Mit der Funktion CANqueue kann fÅr einen CAN Identifier eine Queue in
    Leserichtung installiert werden. Wird fÅr size ein Wert grî·er Null
    angegeben, wird eine Empfangsqueue fÅr die angegebene CAN Identifier
    eingerichtet. Gelîscht wird die Queue und der zugehîrige COB durch
    nochmaligen Aufruf mit enable=0. Mit dem Wert Null am Eingang size und
    enable=1 wird der Inhalt der Queue gelîscht.

                                     @151[ Fortsetzung ]                   @001[ öbersicht ]
.151
    CANqueue - Definieren einer Empfangsqueue  (Fortsetzung)

    Dieser FUB kann auch im LOOP aufgerufen werden, wenn sich die can_id im
    LOOP Ñndert. Wenn die Queue voll ist, werden keine weiteren Telegramme mehr
    aufgenommen (status=8810).
    Pro Eintrag (size) werden 10 Byte im Speicher fÅr die Queue benîtigt

    Fehlernummern der Funktion CANqueue():
    0       Queue wurden erfolgreich angelegt
    8801    Kein Speicher fÅr Ressourcen in der MEMCL_USER vorhanden
            - size verringern bzw. Speicherklasse MEMCL_USER vergrî·ern
    8803    Queue wurde fÅr diese can_id schon angelegt
    8805    Falscher "us_ident"
    8806    CAN-Identifier wird im System schon verwendet
    8808    Fub Speicher wurde zerstîrt (handle)
    8813    CAN-Treiber (CAN2000.BR) nicht installiert


    Eine Liste aller mîglichen Fehlermeldungen der CAN-Library finden Sie im
    Anhang @300[Fehlermeldungen].

                                                                     @001[ öbersicht ]
.155
    CANrd - Auslesen von Nachrichten aus der mit CANqueue definierten Queue

    @0156[CANrd] (enable,q_ident,adr(data_adr),size,status)

    Parameter-Datentypen :
    ->  enable    : BIT           Der Funktionsblock wird nur ausgefÅhrt, wenn
                                  enable = 1 ist
    ->  q_ident   : LONG          Queue-Ident (von @150[CANqueue])
    <-> data_adr  : 8 BYTE (FELD) Feldvariable, in der die gelesenen Daten
                                  gespeichert werden
    <-  size      : WORD          LÑnge des Telegramms in der Queue
    <-  @0156[status    ]: WORD          Fehlernummer (0 = kein Fehler)

    Um mit der Funktion CANrd arbeiten zu kînnen, mu· zuvor mit der Funktion
    CANqueue eine Empfangsqueue eingerichtet werden. Existiert keine Empfangs
    Queue oder ist diese leer, liefert die Funktion einen Fehler im Status.
    Befinden sich Daten in der Queue, werden diese in dem Puffer am Eingang
    data kopiert. Am Ausgang size, wird die LÑnge des Telegramms zurÅckgegeben.



                                     @156[ Fortsetzung ]                   @001[ öbersicht ]
.156
    CANrd - Auslesen von Nachrichten aus der mit CANqueue definierten Queue

    Ist die Empfangs Queue voll (status=8810), so werden keine weiteren
    Telegramme in die Queue aufgenommen, bis  die Queue mit dem FUB CANrd
    ausgelesen wurde.
    Dieser FUB kann auch im LOOP aufgerufen werden, wenn sich die can_id im

    Fehlernummern der Funktion CANrd():
    0       Daten aus der Queue gelesen
    8802    q_ident = 0 (es wurde z.B. kein CANqueue ausgefÅhrt)
    8808    Fub Speicher wurde zerstîrt (handle)
	8810	Empfangs Queue ist voll (die Daten sind aber ok)
    8826    data_adr ist 0 (NIL Pointer)
	8877	Keine Daten in der Empfangs Queue


    Eine Liste aller mîglichen Fehlermeldungen der CAN-Library finden Sie im
    Anhang @300[Fehlermeldungen].



                                                                     @001[ öbersicht ]
.160
    CANexcep - VerknÅpfen einer Exceptionstask mit einer CAN Nachricht

    @0161[CANexcep] (enable,us_ident,can_id, exc_nr,status)

    Parameter-Datentypen :
    ->  enable    : BIT           Der Funktionsblock wird nur ausgefÅhrt, wenn
                                  enable = 1 ist
    ->  us_ident  : LONG          Anwender-Ident (von @020[CANopen])
    ->  can_id    : LONG          CAN Identifier fÅr die auszulîsende Exception
    ->  exc_nr    : BYTE          Nummer der Exception fÅr die Exceptiontask
                                  (208-223 sind fÅr CAN reserviert)
    <-  @0161[status    ]: WORD          Fehlernummer (0 = kein Fehler)

    Mit der Funktion CANexcep wird bei Empfang eines Frames mit dem CAN
    Identifier can_id eine zuvor installierte Exceptionstask mit der
    angegebenen exc_nr aktiviert. Es ist dabei zu berÅcksichtigen, dass diese
    Exceptionstask im Kontext des CAN-Interrupt Handlers (Callback) aufgerufen
    wird. Der Overhead fÅr die Exceptiontaskklasse liegt bei einer CP15x bei
    ca. 150 ms. Hinzu kommt noch der Applikationsteil der Task.


                                     @161[ Fortsetzung ]                   @001[ öbersicht ]
.161
    CANexcep - VerknÅpfen einer Exceptionstask mit einer CAN Nachricht

    Daher ist dieser Fub in einem zyklischen System sehr kritisch. Es kînnen
    auch mehrere CAN-Identifier fÅr ein und die selbe exc_nr definiert werden,
    da in der Exceptiontask die can_id mit der Funktion CANgetid() ermittelt
    werden kann.

    Fehlernummern der Funktion CANexcep():
    0	    Exception wurde mit dem CAN Identifier verknÅpft
	8800	UngÅltige exc_nr (208-223)
	8805	Falscher user_ident
    8807    Falscher CAN Identifier (>2047)
	8808	Fub Speicher wurde zerstîrt (handle)
	8813	CAN Driver nicht installiert (CAN2000.br)


    Eine Liste aller mîglichen Fehlermeldungen der CAN-Library finden Sie im
    Anhang @300[Fehlermeldungen].



                                                                     @001[ öbersicht ]
.165
    CANgetid - Lesen der CAN Daten aus der getriggerten Exceptiontask

    @0166[CANgetid] (enable,adr(data_adr),data_len,can_id,status)

    Parameter-Datentypen :
    ->  enable    : BIT           Der Funktionsblock wird nur ausgefÅhrt, wenn
                                  enable = 1 ist
    <-> data_adr  : 8 BYTE (FELD) Feldvariable, in der die gelesenen Daten
                                  gespeichert werden
    <-  data_lng  : BYTE          LÑnge der Daten in Byte
    <-  can_id    : LONG          CAN Identifier welche die Excpetion auslîste
    <-  @0166[status    ]: WORD          Fehlernummer (0 = kein Fehler)

    Mit dieser Funktion kann im Kontext der Exceptiontask die can_id bestimmt
    werden, welche die Exception ausgelîst hat. Es kînnen somit auch mehrere
    CAN-Identifier fÅr ein und die selbe exc_nr mit der Funktion CANexcep()
    definiert werden. Dem Fub wird ein Datenbereich mit einer LÑnge von 8 Byte
    Åbergeben, in welchen die empfangenen Daten mit der LÑnge data_len kopiert
    werden


                                     @166[ Fortsetzung ]                   @001[ öbersicht ]
.166
    CANgetid - Lesen der CAN Daten aus der getriggerten Exceptiontask

    Fehlernummern der Funktion CANgetid():

    0       Daten gelesen
    8813    CAN Driver nicht installiert (CAN2000.br)











    Eine Liste aller mîglichen Fehlermeldungen der CAN-Library finden Sie im
    Anhang @300[Fehlermeldungen].


                                                                     @001[ öbersicht ]
.170
    CANrtr - Senden eines RTR Request

    @0171[CANrtr] (enable,request,us_ident,can_id,adr(data_adr),data_lng,status)

    Parameter-Datentypen :
    ->  enable    : BIT           Der Funktionsblock wird nur ausgefÅhrt, wenn
                                  enable = 1 ist
    ->  request   : BIT           0...Datenpuffer pollen, 1...RTR Request senden
    ->  us_ident  : LONG          Anwender-Ident (von @020[CANopen])
    ->  can_id    : LONG          CAN-Identifier
    <-> data_adr  : 8 BYTE (FELD) Feldvariable, in der die gelesenen Daten
                                  gespeichert werden
    <-  data_lng  : BYTE          LÑnge der Daten in Byte
    <-  @0171[status    ]: WORD          Fehlernummer (0 = kein Fehler)

    Mit der Funktion CANrtr kann ein RTR-Request Frame am CAN Bus gesendet
    werden. FÅr das Senden des RTR-Request mu· der Parameter request auf 1
    gesetzt werden. Der Fub ist danach solange aufzurufen (mit request=0), bis
    Daten empfangen wurden (status=0).


                                     @171[ Fortsetzung ]                   @001[ öbersicht ]
.171
    CANrtr - Senden eines RTR Request

    Mit dem öbergang enable 1->0 kann der COB im Speicher wieder gelîscht werden
    und somit kînnen beliebig viele RTR Identifier im System verwaltet werden.
    WÑhrend das Anforderungtelegramm (Remote Frame Request) von mehreren
    EmpfÑngerknoten gesendet werden kann, darf es fÅr die angeforderte
    Nachricht aber nur einem Sendeknoten geben (CANupd).

    Fehlernummern der Funktion CANrtr():
	0	    Daten erhalten
	1	    FUB working, keine Response erhalten
	8800	Zuwenig COB's vohanden (cob_anz in CANopen vergrî·ern)
	8805	falscher user_ident
    8807    CAN-Identifier wird im System schon verwendet
	8808	us_ident nicht gÅltig
	8811	CAN Bus ist BusOff
	8813	CAN Driver nicht installiert (CAN2000.br)
	8814	LÑnge > 8 Byte

    Eine Liste aller mîglichen Fehlermeldungen der CAN-Library finden Sie im
    Anhang @300[Fehlermeldungen].
                                                                     @001[ öbersicht ]
.175
    CANupd - Modifizieren des RTR Sendepuffer

    @0176[CANupd] (enable,us_ident,can_id,adr(data_adr),data_lng,status)

    Parameter-Datentypen :
    ->  enable    : BIT           Der Funktionsblock wird nur ausgefÅhrt, wenn
                                  enable = 1 ist
    ->  us_ident  : LONG          Anwender-Ident (von @020[CANopen])
    ->  can_id    : LONG          CAN-Identifier
    <-> data_adr  : 8 BYTE (FELD) Adresse auf die Update Daten
    ->  data_lng  : BYTE          LÑnge der Update Daten Byte
    <-  @0176[status    ]: WORD          Fehlernummer (0 = kein Fehler)

    Mit der Funktion CANupd kann fÅr ein RTR-Request Anforderungstelegramm die
    Nachricht fÅr die Antwort am Sendeknoten bereit gestellt werden. Mit dem
    öbergang enable 1->0 kann der COB im Speicher gelîscht werden und somit
    kînnen beliebig viele Identifier im System verwaltet werden. WÑhrend das
    Anforderungtelegramm (Remote Frame Request) von mehreren EmpfÑngerknoten
    gesendet werden kann, darf es fÅr die angeforderte Nachricht aber nur einem
    Sendeknoten geben (CANupd).

                                     @176[ Fortsetzung ]                   @001[ öbersicht ]
.176
    CANupd - Modifizieren des RTR Sendepuffer


    Fehlernummern der Funktion CANupd():
	0	    Daten modifiziert
	8800	Zuwenig COB's vohanden (cob_anz in CANopen vergrî·ern)
	8805	falscher user_ident
    8808    CAN-Identifier wird im System schon verwendet
	8808	us_ident nicht gÅltig
	8811	CAN Bus ist BusOff
	8813	CAN Driver nicht installiert (CAN2000.br)
	8814	LÑnge > 8 Byte






    Eine Liste aller mîglichen Fehlermeldungen der CAN-Library finden Sie im
    Anhang @300[Fehlermeldungen].

                                                                     @001[ öbersicht ]
.180
    CANngp - Node Guarding Fub fÅr NMT Slave Knoten (CAL)

    @0181[CANngp] (enable,us_ident,can_id,nd_state,status)

    Parameter-Datentypen :
    ->  enable    : BIT           Der Funktionsblock wird nur ausgefÅhrt, wenn
                                  enable = 1 ist
    ->  us_ident  : LONG          Anwender-Ident (von @020[CANopen])
    ->  can_id    : LONG          CAN-Identifier
    ->  nd_state  : BYTE          Knoten Status
    <-  @0181[status    ]: WORD          Fehlernummer (0 = kein Fehler)

    Dieser FUB kann fÅr das Node Guarding Protocol laut CAL am NMT-Slave
    verwendet werden. Von dem Parameter nd_state werden nur die unteren 7 bit
    (bit0-6) Åbernommen. Das Toggle Bit wird im Transmit Interrupt der Node
    Guard Response behandelt. öber den status (=0) kann vom Benutzer von einem
    zum nÑchsten FUB Aufruf kontrolliert werden, ob ein neuer RTR-Request
    empfangen wurde. Wurde kein RTR Request empfangen so ist der status (8877)
    gesetzt, der nd_state wird aber Åbernommen.


                                     @181[ Fortsetzung ]                   @001[ öbersicht ]
.181
    CANngp - Node Guarding Fub fÅr NMT Slave Knoten (CAL)

    Mit dem öbergang enable 1->0 kann der COB im Speicher wieder gelîscht werden
    und somit kînnen beliebig viele Identifier im System verwaltet werden.
    WÑhrend das Anforderungtelegramm (Remote Frame Request mit CANrtr) von
    mehreren EmpfÑngerknoten gesendet werden kann, darf es fÅr die angeforderte
    Nachricht aber nur einem Sendeknoten geben.

    Fehlernummern der Funktion CANngp():
    0	    Es wurde ein RTR Request seit dem letzten Aufruf erhalten
	8800	Zuwenig COB's vohanden (cob_anz in CANopen vergrî·ern)
	8805	falscher user_ident
    8809    CAN-Identifier wird im System schon verwendet
	8808	us_ident nicht gÅltig
	8811	CAN Bus ist BusOff
	8813	CAN Driver nicht installiert (CAN2000.br)
    8814    LÑnge > 8 Byte
	8877	Kein RTR Request empfangen, nd_state wird aber gesetzt

    Eine Liste aller mîglichen Fehlermeldungen der CAN-Library finden Sie im
    Anhang @300[Fehlermeldungen].
                                                                         @001[ öbersicht ]
.182
    CANbtreg - Setze die Bit Timing Register Werte

    @0183[CANbtreg] (enable,us_ident,treg0,treg1,status)

    Parameter-Datentypen :
    ->  enable    : BIT           Der Funktionsblock wird nur ausgefÅhrt, wenn
                                  enable = 1 ist
    ->  us_ident  : LONG          Anwender-Ident (von @020[CANopen])
    ->  treg0     : LONG          Bit Timing Register 0
                                  bit0-5: BRP Baud Rate Prescaler
                                  bit6-7: SJW Synchronization Jump Width
    ->  treg1     : LONG          Bit Timing Register 1
                                  bit0-3: TSEG1 Time Segment1
                                  bit4-6: TSEG2 Time Segment2
                                  bit7:   SPL	Sampling Mode
    <-  @0184[status    ]: WORD          Fehlernummer (0 = kein Fehler)





                                     @183[ Fortsetzung ]                   @001[ öbersicht ]
.183
    CANbtreg - Setze die Bit Timing Register Werte

    Dieser FUB dient zur Konfiguration spezieller Bit Timing Register Werte fÅr
    den CAN Kontroller (Intel 82527).Es ist somit mîglich beliebige Baudraten
    au·erhalb der Standard Baudraten einzustellen. Der FUB mu· nach dem CANopen
    zur öbernahme der eingestellten Werte einmal aufgerufen werden. Der CAN
    Kontroller wird wÑhrend der Konfiguration gestoppt, neu initialisiert und
    danach wieder gestartet. Es ist darauf zu achten, dass im Hochlauf der RPS
    der CAN Kontroller auch von der INA Kommunikation mit den Standard
    Baudraten (siehe auch CANopen) initialisiert wird. Dies kann u.U. zu einer
    Bus Stîrung im Hochlauf fÅhren. öber die Konfiguration im sysconf Modul der
    RPSSW kann die INA Kommunikation fÅr CAN disabled werden. Wird unter dem
    Punkt Kommunikation kein Device (=0) angegeben, so werden default zwei
    serielle und eine CAN Schnittstelle eingerichtet. Nur wenn man explizit
    Devices fÅr die INA Kommunikation angibt, dann werden auch nur diese
    eingerichtet. Somit kann das CAN Device disabled werden.





                                     @184[ Fortsetzung ]                   @001[ öbersicht ]
.184
    CANbtreg - Setze die Bit Timing Register Werte

    Fehlernummern der Funktion CANbtreg():

    0	    Die neuen Bit Timing Register wurden gesetzt
	8805	falscher user_ident
	8808	us_ident nicht gÅltig
	8813	CAN Driver nicht installiert (CAN2000.br)
	8815	FUB wird von dieser Systemsoftware nicht unterstÅtzt (< V2.20)










    Eine Liste aller mîglichen Fehlermeldungen der CAN-Library finden Sie im
    Anhang @300[Fehlermeldungen].
                                                                     @001[ öbersicht ]
.185
    CMSdlreq - Multiplexed Domain Download Request laut CAL

    @0186[CMSdlreq] (enable,initiate,us_ident,client_id,server_id,mux,
                     adr(data_adr),add_code,err_class,err_code,dl_len,status)

    Parameter-Datentypen :
    ->  enable    : BIT     Der Funktionsblock wird nur ausgefÅhrt, wenn
                            enable = 1 ist
    ->  initiate  : BIT     1=Neuer Domain Initiate Request
    ->  us_ident  : LONG    Anwender-Ident (von @020[CANopen])
    ->  client_id : LONG    CAN Ident. fÅr den Sende-COB vom Client zum Server
    ->  server_id : LONG    CAN Ident. fÅr den Sende-COB vom Server zum Client
    ->  mux       : LONG    Multiplexer (siehe unten)
    ->  data_adr  : ADR     Adresse auf die Download Daten
    ->  data_lng  : LONG    LÑnge der Download Daten
    <-  add_code  : WORD    Additional Code bei Abort
    <-  err_class : BYTE    Fehlerklasse laut CANopen
    <-  err_code  : BYTE    Fehler laut CANopen
    <-  dl_len    : LONG    LÑnge der bereits gesendeten Daten
    <-  @0187[status    ]: WORD          Fehlernummer (0 = kein Fehler)

                                     @186[ Fortsetzung ]                   @001[ öbersicht ]
.186
    CMSdlreq - Multiplexed Domain Download Request laut CAL

    Mit diesem FUB kann ein "multiplexed Domain" Objekt mit beliebiger
    DatenlÑnge vom Client zum Server Åbertragen werden. Die Segmentierung der
    Daten auf einzelne CAN Frames erfolgt laut der CAL Spezifikation CiA/DS202-2
    (CMS MULTIPLEXED DOMAIN PROTOCOLS). Wenn die DatenlÑnge < 5 Byte ist,
    erfolgt die öbertragung mit dem "expedited Domain Download" Protokoll. Mit
    dem Parameter initiate=1 wird ein neuer Initiate Domain Transfer gestartet
    und ein u.U. noch aktives Domain Download unterbrochen. FÅr die öbertragung
    der Daten mu· der FUB zyklisch aufgerufen werden, bis der Domain Transfer
    fertig ist (status=0). In jedem FUB Aufruf wird ein Segment (Domain Request)
    mit max. 8 Daten Byte Åber den CAN BUS Åbertragen, wenn fÅr das letzte
    Segment eine Confirmation empfangen wurde. öber den Parameter dl_len kann
    die LÑnge der bereits gesendeten Daten kontrolliert werden. öber das enable
    Bit (fallende Flanke) werden die COB's und die FUB Verwaltung wieder frei
    gegeben werden.





                                     @187[ Fortsetzung ]                   @001[ öbersicht ]
.187
    CMSdlreq - Multiplexed Domain Download Request laut CAL

    Fehlernummern der Funktion CMSdlreq():
    0       Download wurde erfolgreich durchgefÅhrt
    1       Download aktiv und noch nicht fertig (dl_len != data_len)
	8805	Falscher user_ident
    8808    Falscher CAN Identifier (>2047)
    8809    Falscher user_ident
	8808	Fub Speicher wurde zerstîrt (handle)
    8813    CAN Driver nicht installiert (CAN2000.br)
    8828    Abort Protokoll wurde an der Server gesendet (>add_code)
    8829    Abort Protokoll wurde vom Server empfangen

    Error Class:	    5	Service Error
                        6   Access Error

    Error code:	        3	Parameter inconsist
                        7   Type Conflict



                                     @188[ Fortsetzung ]                   @001[ öbersicht ]
.188
    CMSdlreq - Multiplexed Domain Download Request laut CAL

    Additional Code:    16	Toggle Bit Fehler
                        18  Buffer am Server fÅr Domain zu klein
                    	49	Mehr Domaindaten gesendet als in Domain Initiate
                    	    Protokoll eingetragen

    Eine Liste aller mîglichen Fehlermeldungen der CAN-Library finden Sie im
    Anhang @300[Fehlermeldungen].












                                                                     @001[ öbersicht ]
.190
    CMSdlcon - Multiplexed Domain Download Confirmation laut CAL

    @0191[CMSdlcon] (enable,initiate,us_ident,client_id,server_id,mux,
                     adr(data_adr),add_code,err_class,err_code,dl_len,status)

    Parameter-Datentypen :
    ->  enable    : BIT     Der Funktionsblock wird nur ausgefÅhrt, wenn
                            enable = 1 ist
    ->  initiate  : BIT     1=Neuer Domain Initiate Request
    ->  us_ident  : LONG    Anwender-Ident (von @020[CANopen])
    ->  client_id : LONG    CAN Ident. fÅr den Sende-COB vom Client zum Server
    ->  server_id : LONG    CAN Ident. fÅr den Sende-COB vom Server zum Client
    ->  mux       : LONG    Multiplexer (siehe unten)
    ->  data_adr  : ADR     Adresse auf die Download Daten
    ->  data_lng  : LONG    LÑnge der Download Daten
    <-  add_code  : WORD    Additional Code bei Abort
    <-  err_class : BYTE    Fehlerklasse laut CANopen
    <-  err_code  : BYTE    Fehler laut CANopen
    <-  dl_len    : LONG    LÑnge der bereits gesendeten Daten
    <-  @192[status    ]: WORD          Fehlernummer (0 = kein Fehler)

                                     @191[ Fortsetzung ]                   @001[ öbersicht ]
.191
    CMSdlcon - Multiplexed Domain Download Confirmation laut CAL

    Mit diesem FUB kann ein "multiplexed Domain" Objekt mit beliebiger
    DatenlÑnge am Server empfangen werden. Die Segmentierung der Daten auf
    einzelne CAN Frames erfolgt laut der CAL Spezifikation CiA/DS202-2
    (CMS MULTIPLEXED DOMAIN PROTOCOLS). Wenn die DatenlÑnge < 5 Byte ist,
    erfolgt die öbertragung mit dem "expedited Domain Download" Protokoll.
    FÅr den Empfang der Daten mu· der FUB zyklisch aufgerufen werden, bis der
    Domain Transfer fertig ist (status=0). Mit dem Parameter initiate=1 wird
    der FUB fÅr den Empfang einer neuen Domain aktiviert. öber den Parameter
    dl_len kann die LÑnge der bereits empfangenen Daten kontrolliert werden.
    öber das enable Bit (fallende Flanke) werden die COB's und die FUB
    Verwaltung wieder frei gegeben. FÅr die zu empfangende Domain mu·
    ein entsprechend gro·er Speicherblock an den FUB angeschlossen werden
    (data_adr, data_len).






                                     @192[ Fortsetzung ]                   @001[ öbersicht ]
.192
    CMSdlcon - Multiplexed Domain Download Confirmation laut CAL

    Fehlernummern der Funktion CMSdlreq():
    0       Download wurde erfolgreich durchgefÅhrt
    1       Download aktiv und noch nicht fertig (dl_len != data_len)
	8805	Falscher user_ident
    8810    Falscher CAN Identifier (>2047)
    8811    Falscher user_ident
	8808	Fub Speicher wurde zerstîrt (handle)
	8813	CAN Driver nicht installiert (CAN2000.br)
	8828	Abort Protokoll wurde an der Client gesendet (>add_code)
	8829	Abort Protokoll wurde vom Client empfangen

    Error Class:	    5	Service Error
                        8   Access Error

    Error code:	        3	Parameter inconsist
                        9   Type Conflict



                                     @193[ Fortsetzung ]                   @001[ öbersicht ]
.193
    CMSdlcon - Multiplexed Domain Download Confirmation laut CAL

    Additional Code:    16	Toggle Bit Fehler
                        19  Buffer am Server fÅr Domain zu klein
                    	49	Mehr Domaindaten gesendet als in Domain Initiate
                    	    Protokoll eingetragen







    Eine Liste aller mîglichen Fehlermeldungen der CAN-Library finden Sie im
    Anhang @300[Fehlermeldungen].






                                                                     @001[ öbersicht ]
.195
    GetNdNr - Lesen der im CRM gespeicherten Knotennummer

    GetNdNr (enable,adr(dev_adr),nodenr,status)

    Parameter-Datentypen :
     -> enable    : BIT         1... FUB aktivieren
    <-> dev_adr   : LONG        16 Byte Buffer fÅr Device String
    							z.B.: "SLx.SSx.IFx"
	<-	nodenr    : BYTE		gespeicherte Knotennummer



		status:		0			Knotennummer wurde gelesen
					14901		keine Knotennummer im CRM gespeichert

	Mit dieser Funktion wird die abgespeicherte Knotennummer und die Device
	Beschreibung unabhaengig vom aussen eingestellten Knotenschalter aus dem
	CRM (critical memory) gelesen.



                                     @197[ Fortsetzung ]                   @001[ öbersicht ]
.196
    SetNdNr - Setzen einer neuen Knotennummer im CRM

    SetNdNr (enable,adr(device),nodenr,status)

    Parameter-Datentypen :
     -> enable    : BIT         1... FUB aktivieren
     -> device    : LONG        Device String 	z.B.: "SL0.SS1.IF2"
	 -> nodenr    : BYTE		Neue Knotennummer



		status:		0			Knotennummer wurde gespeichert
					8252 		Device Beschreibung ungueltig

	Mit dieser Funktion wird die neue Knotennummer und die Device Beschreibung
	unabhaengig vom aussen eingestellten Knotenschalter im	CRM (critical
	memory) gespeichert.




                                     @197[ Fortsetzung ]                   @001[ öbersicht ]
.197
  GetNdNr und SetNdNr

Mit den Fubs SetNdNr() und GetNdNr() besteht die Moeglichkeit die Knotennummer
auf der RPS in einem Batterie gebufferten RAM-Speicher (CRM=critical memory)
hochlauffest zu speichern. Diese Nummer wird ab der RPSSW V2.21 im nÑchsten
Hochlauf Åbernommen, sofern die externe Knotennummer auf $FE eingestellt ist.

Es gelten folgende Bedingungen fÅr die dynamische Knotennummer Vergabe:

* Die Knotennummer Vergabe im Hochlauf wird ab der RPSSW Version V2.21 (X4.01)
  unterstÅtzt
* Durch die Einstellung $FE am externen Knotennummerschalter wird die
  Knotennummervergabe aktiviert (d.h. im  nÑchsten Hochlauf Åbernommen). Ist
  im CRM keine Knotennummer (=0) gesetzt, so wird die externe Knotennummer
  Åbernommen ($FE).
* Es kann nur eine Knotennummer fÅr ein Device Åber den Hochlauf  gespeichert
  und verÑndert werden.
* Die Ablage erfolgt im CRM (Knotennummer und Devicedescriptor "SLx.SSx.IFx")
* Die Knotennummer kann fÅr ein beliebiges Medium und IF verÑndert werden


                                     @198[ Fortsetzung ]                   @001[ öbersicht ]
.198
  Fortsetzung GetNdNr und SetNdNr

* Die neue Knotennummer wird in jedem Hochlauf (Kaltstart, Warmstart,
  Diagnose, Service) Åbernommen.
* Dem FUB CANnode und CANxnode wird die neue Knotennummer Åbergeben
* Nach der Knotennummer Neueinstellung Åber den FUB SetNdNr() mu· ein
  Warmstart (bzw. ein Hochlauf) ausgelîst werden.
* Die im CRM gespeicherte Knotennummer kann durch den FUB SetNdNr (nodenr=0)
  bzw. durch öbertragen des Systems im Bootstrap Mode (bei externer
  Knotenschalterstellung=0) gelîscht und deaktiviert werden. Wird das System
  im Run Mode auf die RPS Åbertragen, so wird das CRM und die Knotennummer
  nicht gelîscht
* Mit den Fubs CANnode, CANxnode und GetNdNr wird immer die im CRM hinterlegte
  Knotennummer gelesen, sofern extern $FE im letzten Hochlauf eingestellt war







                                                                     @001[ öbersicht ]
.200
    ANHANG : LIBRARY-Informationen


    @201[< Allgemeines     >]      Voraussetzungen etc.

    @210[< Interruptzeiten >]      Interruptzeiten

    @250[< Syntax          >]      Syntax fÅr die ErklÑrung der Funktionen

    @300[< Fehlernummern   >]      Zusammenfassung aller Fehlernummern

    @379[< History         >]      Neue FunktionalitÑten und VersionsÑnderungen









                                                                     @001[ öbersicht ]
.201
    CAN-Library : Allgemeines

    FÅr den Zugriff auf den CAN-Bus am B&R 2000 System werden in der CAN-
    Library Funktionen zur VerfÅgung gestellt, mit denen CAN-Frames (maximal
    8 Byte) gelesen oder beschrieben werden kînnen. Es werden nur Einzel-
    Frames gesendet.
    Es besteht die Mîglichkeit, Variablen-Tabellen an den Funktionsblock
    CANdftab() anzuschlie·en und diese Variablen-Tabellen anschlie·end mit
    dem Funktionsblock CANrwtab() zyklisch zu aktualisieren.
    Mit Hilfe der Funktionsblîcke CMSinit() und CMSmain() kînnen CMS-Objekte
    gesendet und empfangen werden. Die CMS-Objekte werden in einem Datenmodul
    definiert, welches sowohl fÅr den Client als auch fÅr den Server verwendet
    werden kann. Die Unterscheidung zwischen Client und Server erfolgt in der
    Funktion CMSinit() durch den Eingangsparameter "user_type" (0 = Client,
    1 = Server). Die CMS-Dienst-Anforderung bzw. -Erkennung wird Åber sog.
    Event-Variablen (Event-PVs) gesteuert.
    Die Funktionsblîcke CANopen(), CANdftab() und CMSinit() sind aus Laufzeit-
    grÅnden im Initialisierungs-Unterprogramm (INIT-UP) der Task aufzurufen.
    Alle anderen Funktionsblîcke kînnen im zyklischen Teil der Task verwendet
    werden.

                                     @202[ Fortsetzung ]                   @001[ öbersicht ]
.202
    CAN-Library : Allgemeines (Fortsetzung)

    Im CAN2000-Treiber wird die Maskierung von Identifiern unterstÅtzt, d.h.
    es wird nur fÅr die mit den Funktionsblîcken CANdftab() und CMSinit()
    definierten Receive-Identifier ein Interrupt auf der CPU ausgelîst.
    Alle anderen CAN-Empfangsnachrichten lîsen keinen Interrupt aus.
    Generell ist zu beachten, da· der CAN-Controller als Standalone Controller
    von der RPS-CPU aus betrieben wird und somit jedes Read oder Write von
    CAN-Nachrichten (der definierten Identifier) einen Interrupt auf der RPS-
    CPU auslîst. Weiters werden nur Standard-CAN-Identifier vom CAN2000-Treiber
    unterstÅtzt.










                                     @203[ Fortsetzung ]                   @001[ öbersicht ]
.203
    CAN-Library : Allgemeines (Fortsetzung)

    Anmerkungen:
    - Bevor Sie die Funktionen der CAN-Library in Ihrem Projekt verwenden
      kînnen, mÅssen Sie diese Library in die entsprechende Projekt-Datenbank
      importieren.

    - Die Funktionen dieser Library kînnen nur verwendet werden, wenn der CAN-
      Treiber CAN2000.BR auf der Zentraleinheit (Anwender-ROM) vorhanden ist!

    - Da die CAN-Library AVT-Funktionen enthÑlt, kînnen die Funktionen dieser
      Library nur verwendet werden, wenn das Library-Runtime-Modul (B&R-Modul
      CAN_LIB.BR) auf der Zentraleinheit (Anwender-ROM) vorhanden ist!

    - Alle Funktionen der CAN-Library liefern im Fehlerfall als Ergebnis eine
      @300[Fehlernummer].





                                       @200[ ANHANG ]                      @001[ öbersicht ]
.210
    CAN-Library : Interruptzeiten

    Die Zeiten in der folgenden Tabelle wurden auf einem IP151-Modul mit dem
    Profiler gemessen und entsprechen der Laufzeit des CAN-Interrupthandlers
    (CAN2000 V1.50). FÅr die Worst-Case-Zeit ist zusÑtzlich die angefÅhrte
    @213[Interrupt-Latenzzeit] zu berÅcksichtigen. Bei einer hîheren Buslast ist
    unter UmstÑnden noch die Sende-Queue-Behandlung (siehe CANwrite) im CAN-
    Interrupthandler zu berÅcksichtigen. Der Sende-Auftrag aus der Sende-
    Queue an den CAN-Controller beansprucht zusÑtzlich ca. 35 Ês (IP151) in
    der Sende-Interruptbehandlung.

 …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
 ∫ Interruptzeiten fÅr IP151  ≥      CLIENT [Ês]      ≥      SERVER [Ês]      ∫
 ÃÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕπ
 ∫ Class  ≥ Access ≥ Datentyp ≥ Transm.IRQ ≥ Rec.IRQ  ≥ Transm.IRQ ≥ Rec.IRQ  ∫
 ÃÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕπ
 ∫ B.Var. ≥ R.O.   ≥   LONG   ≥            ≥ 111 (40) ≥            ≥          ∫
 ∫ B.Var. ≥ W.O.   ≥   LONG   ≥   61 (17)  ≥          ≥            ≥   111    ∫
 ∫ B.Var. ≥ Read   ≥   LONG   ≥   61 (16)  ≥ 117 (44) ≥     61     ≥    80    ∫
 »ÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕº

                                     @211[ Fortsetzung ]                   @001[ öbersicht ]
.211
    CAN-Library : Interruptzeiten (Fortsetzung)

 …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
 ∫ Interruptzeiten fÅr IP151  ≥      CLIENT [Ês]      ≥      SERVER [Ês]      ∫
 ÃÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕπ
 ∫ Class  ≥ Access ≥ Datentyp ≥ Transm.IRQ ≥ Rec.IRQ  ≥ Transm.IRQ ≥ Rec.IRQ  ∫
 ÃÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕπ
 ∫ B.Var. ≥ Write  ≥   LONG   ≥   61 (17)  ≥  82 (32) ≥     61     ≥   115    ∫
 ∫ M.Var. ≥ R.O.   ≥   LONG   ≥   66 (21)  ≥ 118 (47) ≥     65     ≥    76    ∫
 ∫ M.Var. ≥ W.O.   ≥   LONG   ≥   66 (21)  ≥          ≥            ≥   117    ∫
 ∫ M.Var. ≥ Read   ≥   LONG   ≥   71 (22)  ≥ 120 (47) ≥     66     ≥   122    ∫
 ∫ M.Var. ≥ Write  ≥   LONG   ≥   71 (21)  ≥  86 (33) ≥     65     ≥   123    ∫
 »ÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕº

    In der Tabelle wurden folgende AbkÅrzungen verwendet:
    R.O. ....... ReadOnly
    W.O. ....... WriteOnly
    B.Var. ..... Basic Variable
    M.Var. ..... Multiplexed Variable


                                     @212[ Fortsetzung ]                   @001[ öbersicht ]
.212
    CAN-Library : Interruptzeiten (Fortsetzung)

    Bei Strukturen und Feldern erhîht sich die Interruptzeit zirka um den
    Faktor 1,2.

    Um die Interruptzeiten fÅr die verschiedenen CPU-Typen zu erhalten, mÅssen
    Sie die auf dem IP151-Modul gemessenen Interruptzeiten mit den unten an-
    gegebenen Faktoren multiplizieren:

    …ÕÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕÕÕª
    ∫ CPU-Typ ∫ Faktor ∫
    ÃÕÕÕÕÕÕÕÕÕŒÕÕÕÕÕÕÕÕπ
    ∫  IF100  ∫  1,00  ∫
    ∫  CP104  ∫  1,20  ∫
    ∫  IF152  ∫  1,00  ∫
    ∫  CP472  ∫  1,00  ∫
    ∫  XP152  ∫  1,20  ∫
    ∫  CP260  ∫  0,30  ∫
    »ÕÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕÕÕº


                                     @213[ Fortsetzung ]                   @001[ öbersicht ]
.213
    CAN-Library : Interruptzeiten (Fortsetzung)

    Die Interrupt-Latenzzeiten fÅr den CAN-Interrupt liegen im Bereich 10 bis
    30 Ês (IF152/IP151/XP152/CP472). Wenn die RPSSW Version V1.10 verwendet
    wird (CP104/C220), kann sich die Latenzzeit bei zusÑtzlichen PV-Zugriffen
    Åber die serielle Schnittstelle auf 100 Ês erhîhen.















                                       @200[ ANHANG ]                      @001[ öbersicht ]
.250
    CAN-Library : Syntaxbeschreibung

    Datentypen:
    FÅr viele Funktionen sind bestimmte Gruppen von Datentypen zulÑssig. Um
    bei der Funktionsbeschreibung nicht alle zulÑssigen Datentypen anfÅhren
    zu mÅssen, werden folgende Gruppenbezeichnungen eingefÅhrt:
    …ÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕª
    ∫ Gruppe ∫  BIT  ≥ INT8  ≥ BYTE  ≥ INT16 ≥ WORD  ≥ INT32 ≥ LONG  ≥ FLOAT ∫
    ÃÕÕÕÕÕÕÕÕŒÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕπ
    ∫ BASIS  ∫       ≥   x   ≥   x   ≥   x   ≥   x   ≥   x   ≥   x   ≥       ∫
    «ƒƒƒƒƒƒƒƒ◊ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ∂
    ∫ NICHT  ∫   x   ≥   x   ≥   x   ≥   x   ≥   x   ≥   x   ≥   x   ≥       ∫
    ∫ FLOAT  ∫       ≥       ≥       ≥       ≥       ≥       ≥       ≥       ∫
    «ƒƒƒƒƒƒƒƒ◊ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ∂
    ∫ ALLE   ∫   x   ≥   x   ≥   x   ≥   x   ≥   x   ≥   x   ≥   x   ≥   x   ∫
    «ƒƒƒƒƒƒƒƒ◊ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ∂
    ∫ FELD   ∫  [x]  ≥  [x]  ≥  [x]  ≥  [x]  ≥  [x]  ≥  [x]  ≥  [x]  ≥  [x]  ∫
    »ÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕÕœÕÕÕÕÕÕÕœÕÕÕÕÕÕÕœÕÕÕÕÕÕÕœÕÕÕÕÕÕÕœÕÕÕÕÕÕÕœÕÕÕÕÕÕÕœÕÕÕÕÕÕÕº
      x  Datentyp ist zulÑssig
     [x] Datentyp ist zulÑssig als Feldvariable oder Zeichenkette (String)

                                     @251[ Fortsetzung ]                   @001[ öbersicht ]
.251
    CAN-Library : Syntaxbeschreibung (Fortsetzung)

    Pfeile:
    FÅr die Darstellung von Eingangs- und Ausgangsparametern werden Pfeile
    verwendet. Dabei gilt folgende Vereinbarung:
    …ÕÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
    ∫  Pfeil  ∫  Bedeutung                                                   ∫
    ÃÕÕÕÕÕÕÕÕÕŒÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ
    ∫   ->    ∫  Eingangsparameter                                           ∫
    «ƒƒƒƒƒƒƒƒƒ◊ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
    ∫   <->   ∫  Ein-/Ausgangsparameter. Funktionell ist es ein Ausgangs-    ∫
    ∫         ∫  parameter. öblicherweise wird er aber vor dem Aufruf der    ∫
    ∫         ∫  Funktion mit einer bestimmten Information geladen (z.B.     ∫
    ∫         ∫  einer Adresse). Meist wird die Adresse einer Variable mit   ∫
    ∫         ∫  adr() [PL2000] oder einem Adre·kontakt [KOP] angeschlossen. ∫
    «ƒƒƒƒƒƒƒƒƒ◊ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
    ∫   <-    ∫  Ausgangsparameter                                           ∫
    »ÕÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº



                                     @252[ Fortsetzung ]                   @001[ öbersicht ]
.252
    CAN-Library : Syntaxbeschreibung (Fortsetzung)

    Funktionsblîcke:
    Funktionsblîcke sind in dieser Online-Hilfe nicht grafisch dargestellt.
    Sie finden aber alle fÅr Funktionsblîcke relevanten Informationen, wie
    Eingangsparameter (->), Ein-/Ausgangsparameter (<->) und Ausgangsparameter
    (<-) in der Online-Hilfe.














                                       @200[ ANHANG ]                      @001[ öbersicht ]
.300
    CAN-Library : Fehlernummern der CAN-Funktionsblîcke

    Die folgende Liste ist eine Zusammenfassung aller mîglichen Fehlermeldungen
    der CAN-Library:
    3019    Datenmodul ("modul_name") nicht vorhanden
    3090    "device" <> 0 ist im Basissystem V1.10 nicht zulÑssig
    8800    Zuwenig COBs vorhanden
            ("cob_anz" in CANopen() vergrî·ern)
    8801    Kein Speicher fÅr Ressourcen im Anwender-RAM frei
            ("cob_anz" verringern bzw. Speicher vergrî·ern)
    8802    Falscher Tabellen-Identifier ("tab_ident")
            (lokaler Funktionsblock-Speicher zerstîrt)
    8804    Falscher CAN-Identifier (> 2047)
    8805    Falscher "us_ident"
    8806    CAN-Identifier wird im System schon verwendet
    8808    COB Verwaltung zerstîrt
    8809    CAN-Auftrag mit dem gleichen CAN-Identifier in Arbeit (busy)
    8810    Sende-Queue voll oder kein aktiver Knoten im Netz
    8811    CAN-Bus ist BusOff
    8812    Kein Puffer mehr frei (max. 13 mîglich)

                                     @301[ Fortsetzung ]                   @001[ öbersicht ]
.301
    CAN-Library : Fehlernummern der CAN-Funktionsblîcke (Fortsetzung)

    8813    CAN-Treiber (CAN2000.BR) nicht installiert
    8814    LÑnge der Daten > 8 Byte
    8815    UnzulÑssige Baudrate
    8816    "cob_anz" = 0 oder zu gro· (max. 2047)
    8821    Falscher "user_type"
            ("user_type" = 0 ... Client, "user_type" = 1 ... Server)
    8822    Syntax-Fehler bei der Definition der CMS-Objekte im Datenmodul
            (siehe "cms_entry")
    8823    Komplexe Struktur nicht erlaubt
    8824    Falscher "cms_mode"
    8825    Kein Nummernschalter vorhanden oder CAN2000-Treiber (CAN2000.BR)
            nicht installiert (< V1.40)
    8826    CAN-Treiber (CAN2000.BR) ist zu alt (< V1.50)
    8832	CMS Multiplexer Definitionfehler: unterschiedl. Object_typ, access_typ
            bzw. ID bzw. wird ein Multiplexer mehrfach fÅr eine ID verwendet
    8859    LÑnge der Nachricht ist falsch
    8872    Nachricht ging verloren (Puffer wurde bereits Åberschrieben), Daten
            sind aber konsistent

                                     @302[ Fortsetzung ]                   @001[ öbersicht ]
.302
    CAN-Library : Fehlernummern der CAN-Funktionsblîcke (Fortsetzung)

    8875    Nachricht ist inkonsistent (wÑhrend CANread() wurden neue Daten
            empfangen)
    8876    Sendepuffer nicht frei (busy), wenn z.B. hochpriores Objekt ohne
            Overwrite-Modus definiert wurde
    8877    Keine Nachricht vorhanden
    147xx   Variable fehlt oder Syntax des Variablennamens falsch
            (xx ist ein Wert zwischen 00 und 15)












                                       @200[ ANHANG ]                      @001[ öbersicht ]
.379
    CAN-Library : History - VersionsÑnderungen
  …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
  ∫ V1.53 -> V1.54  ≥ Fehlerbehebung                                          ∫
  «ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
  ∫ - CMSdlreq: Abort Frame von $40 auf $80 geaendert                         ∫
  ∫ - CMSdlcon: Abort Frame von $40 auf $80 geaendert                         ∫
  ∫                                                                           ∫
  ∫                                                                           ∫                                                                         ∫
  ∫                                                                           ∫
  ∫                                                                           ∫
  ∫                                                                           ∫
  ∫                                                                           ∫
  ∫                                                                           ∫
  ∫                                                                           ∫
  ∫                                                                           ∫
  ∫                                                                           ∫
  ∫                                                                           ∫
  ∫                                                                           ∫
  ∫                                                                           ∫
  ∫                                                                           ∫
  »ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº
                                     @380[ Fortsetzung ]                   @001[ öbersicht ]
.380
    CAN-Library : History - VersionsÑnderungen
  …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
  ∫ V1.52 -> V1.53  ≥ AKTUELLE VERSION: Neue FunktionalitÑten/Fehlerbehebung  ∫
  «ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
  ∫ - CANbtreg: Neuer Fub fÅr Bit Timing Register                             ∫
  ∫ - CANopen:  info=$80 -> extended Identifier                               ∫
  ∫ - CANdftab: Die Eventvariablen werden auf 0 initialisiert                 ∫
  ∫ - SetNdNr und GetNdNr: Neue Fubs fÅr dynamische Knotennummervergabe       ∫                                                                         ∫
  ∫ - CANwrite: Die CANwrite Struktur wurde um ein Byte aligned (fuer AS-IEC) ∫
  ∫ - CMSdlcon: InitiateDomainDownload Response wurde laut CAL korrigiert     ∫
  ∫                                                                           ∫
  ∫   CAN_LIB.BR ist mit einer Warmstartkennung gekennzeichnet (AS)           ∫
  ∫                                                                           ∫
  ∫                                                                           ∫
  ∫                                                                           ∫
  ∫                                                                           ∫
  ∫                                                                           ∫
  ∫                                                                           ∫
  ∫                                                                           ∫
  ∫                                                                           ∫
  »ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº
                                     @390[ Fortsetzung ]                   @001[ öbersicht ]
.390
    CAN-Library : History - VersionsÑnderungen
  …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
  ∫ V1.51 -> V1.52  ≥ AKTUELLE VERSION: Neue FunktionalitÑten/Fehlerbehebung  ∫
  «ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
  ∫ - CANqueue  Fehlerkorrekturen:                                            ∫
  ∫   1. Im Loop wurde beim 2. Aufruf der Fehler 8808 gesetzt                 ∫
  »ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº
  …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
  ∫ V1.50 -> V1.51  ≥ AKTUELLE VERSION: Neue FunktionalitÑten/Fehlerbehebung  ∫
  «ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
  ∫ - CANqueue  Fehlerkorrekturen:                                            ∫
  ∫   1. PrÅfen der Inputparameter auf 0 (wenn enable=0 -> kein status)       ∫
  ∫   2. Im Warmstart wurde Speicher mehrfach allokiert                       ∫
  ∫                                                                           ∫
  »ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº






                                     @391[ Fortsetzung ]                   @001[ öbersicht ]
.391
    CAN-Library : History - VersionsÑnderungen
  …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
  ∫ V1.42 -> V1.50  ≥ AKTUELLE VERSION: Neue FunktionalitÑten/Fehlerbehebung  ∫
  «ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
  ∫ - Neue FUBs: CANqueue,CANrd,CANexcep,CANgetid,CANrtr,CANupd,CANngp        ∫
  ∫              CMSdlreq,CMSdlcon                                            ∫
  ∫ - UnterstÅtzung der Uncontrolled Event laut CAL durch die FUBs CMSinit()  ∫
  ∫   und CMSmain()                                                           ∫                                                                         ∫
  ∫ - Modifikationen im CANwrite                                              ∫
  ∫   1. negative Flanke im enable Bit lîscht den COB                         ∫
  ∫   2. Aufruf von beliebiger Position im Source mit der selben CAN-ID im    ∫
  ∫      Source mîglich                                                       ∫
  ∫   3. LoopfÑhig mit unterschiedlicher can_id                               ∫
  ∫ - Modifikation im CANdftab():                                             ∫
  ∫   1. neg. Flanke im enable Bit lîscht die COB's und den zugeh. VW-Speicher∫
  ∫   2. internes Verriegelungsflag (Bedienung im CAN-Interrupt) wurde auf die∫
  ∫      Event Variable verlagert                                             ∫
  ∫ - Die PV-Funktionen Referenz erfolgt ab der V1.50 in die RPSSW (systrap)  ∫
  ∫ - Im FUB CMSinit wird bei Multiplexer Definitionsfehlern die Fehlernummer ∫
  ∫   8832 gesetzt (Fehler5596)                                               ∫
  »ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº
                                     @400[ Fortsetzung ]                   @001[ öbersicht ]
.400
    CAN-Library : History - VersionsÑnderungen

  …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
  ∫ V1.41 -> V1.42  ≥ AKTUELLE VERSION: Neue FunktionalitÑten/Fehlerbehebung  ∫
  «ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
  ∫ - Umstellen der Funktionen fÅr den CAN2000-Treiber V1.50 (Funktions-      ∫
  ∫   verteiler statt DE-Schnittstelle).                                      ∫
  ∫ - CANopen(): Eine Erweiterung des Funktionsblocks CANopen() ermîglicht    ∫
  ∫   den Einsatz von Modulen mit mehreren CAN-Schnittstellen (z.B. CP260).   ∫
  ∫ - Funktionsblock CANxnode() zum Lesen der Knotennummer des x-ten CAN-     ∫
  ∫   Knotenschalters.                                                        ∫
  »ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº









                                     @401[ Fortsetzung ]                   @001[ öbersicht ]
.401
    CAN-Library : History - VersionsÑnderungen (Fortsetzung)

  …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
  ∫ V1.40 -> V1.41  ≥ éLTERE VERSIONEN: Neue FunktionalitÑten/Fehlerbehebung  ∫
  «ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
  ∫ - Das RÅcksetzen von Event-Variablen in der CAN2000-Interruptbehandlung   ∫
  ∫   auf der Client-Seite erfolgt nur, wenn die Event-Variable den ent-      ∫
  ∫   sprechenden Wert haben. Damit wird sichergestellt, da· keine weiteren   ∫
  ∫   neuen AuftrÑge verloren gehen.                                          ∫
  ∫ - Am Server werden im FUB CMSmain() bei ReadyOnly Basic Variablen nur     ∫
  ∫   dann die Daten kopiert, wenn die Event-Variable = 1 ist.                ∫
  ∫ - CMSinit(): FÅr Variablen, welche im Datenmodul angegeben wurden, auf    ∫
  ∫   der RPS jedoch nicht vorhanden sind, wird im Callback eine Dummy-       ∫
  ∫   Adresse fÅr das Kopieren eingetragen.                                   ∫
  »ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº






                                     @402[ Fortsetzung ]                   @001[ öbersicht ]
.402
    CAN-Library : History - VersionsÑnderungen (Fortsetzung)

  …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
  ∫ V1.37 -> V1.40  ≥ éLTERE VERSIONEN: Neue FunktionalitÑten/Fehlerbehebung  ∫
  «ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
  ∫ - Speicheroptimierung im CAN2000-Treiber von 8-KByte auf 512-Byte-Blîcke  ∫
  ∫   abhÑngig von den Bits 8-10 der definierten CAN-Identifier.              ∫
  ∫ - Hochpriore Puffer-Behandlung von max. 13 Objekten (RTR + Hochpriore) im ∫
  ∫   CAN-Controller.                                                         ∫
  ∫ - Overflow Bit bei Nachrichtenverlust von definierten CAN-Identifiern in  ∫
  ∫   CANopen().                                                              ∫
  ∫ - Funktionsblock CANnode() zum Lesen der eingestellten Knotennummer.      ∫
  »ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº








                                     @403[ Fortsetzung ]                   @001[ öbersicht ]
.403
    CAN-Library : History - VersionsÑnderungen (Fortsetzung)

  …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
  ∫ V1.36 -> V1.37  ≥ éLTERE VERSIONEN: Neue FunktionalitÑten/Fehlerbehebung  ∫
  «ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
  ∫ - Strukturen und Felder werden im Format laut CAL - CMS Encoding Rules    ∫
  ∫   CiA/DS201-3 Åbertragen (au·er Bit-Strukturen und Bit-Felder).           ∫
  ∫ - CMSinit() und CMSmain(): énderung der Funktionen fÅr die Receive Queue, ∫
  ∫   welche aber erst ab der Version V1.40 der CAN-Library im Funktions-     ∫
  ∫   umfang enthalten ist.                                                   ∫
  ∫ - Korrektur in den PV-Funktionen (Pvx_access) fÅr den Zugriff auf Alias-  ∫
  ∫   Strukturen im CMS-Datenmodul.                                           ∫
  ∫ - Korrektur fÅr den Zugriff auf Multiplexed Variablen, wenn ein           ∫
  ∫   Multiplexer empfangen wird, der nicht im Datenmodul definiert wurde     ∫
  ∫   (falsche Event-Variable wurde bedient).                                 ∫
  ∫ - Stackerhîhung im Funktionsblock CMSinit().                              ∫
  ∫ - CMSinit() durchlÑuft alle EintrÑge des Datenmoduls, auch wenn die ange- ∫
  ∫   gebenen Variablen nicht vorhanden sind. Somit kann man mit CMSmain()    ∫
  ∫   die vorhandenen Variablen bedienen. CMSinit() liefert trotzdem einen    ∫
  ∫   Fehler.                                                                 ∫
  »ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº
                                     @404[ Fortsetzung ]                   @001[ öbersicht ]
.404
    CAN-Library : History - VersionsÑnderungen (Fortsetzung)

  …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
  ∫ V1.35 -> V1.36  ≥ éLTERE VERSIONEN: Neue FunktionalitÑten/Fehlerbehebung  ∫
  «ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
  ∫ Multiplexed Variablen kînnen Åber einen CAN-Identifier verwendet werden.  ∫
  ÃÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ
  ∫ V1.31 -> V1.35  ≥ éLTERE VERSIONEN: Neue FunktionalitÑten/Fehlerbehebung  ∫
  «ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
  ∫ - CMS-Funktionen CMSinit() und CMSmain() fÅr die Objekte Basic Variable   ∫
  ∫   und Multiplexed Variable mit den Zugriffen ReadOnly, WriteOnly und      ∫
  ∫   Read-Write.                                                             ∫
  ∫ - Automatisches Wiederaufsetzen des CAN-Controllers aus dem BusOff-       ∫
  ∫   Zustand im CAN2000-Treiber. Der BusOff-Zustand kann aber sehr wohl      ∫
  ∫   Åber die Variable "error_adr" der Funktion CANopen() erkannt werden.    ∫
  ∫ - Zugriff auf Struktur- und Feldelemente Åber den Variablennamen.         ∫
  »ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº




                                     @405[ Fortsetzung ]                   @001[ öbersicht ]
.405
    CAN-Library : History - VersionsÑnderungen (Fortsetzung)

  …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
  ∫ V1.31           ≥                                                         ∫
  «ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
  ∫ Erste Version der Online-Hilfe fÅr die CAN-Library.                       ∫
  »ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº














                                       @200[ ANHANG ]                      @001[ öbersicht ]

.End
