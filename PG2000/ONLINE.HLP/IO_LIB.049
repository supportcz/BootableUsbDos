%%
1,0:1
%%
.1
    Funktionen der I/O-Library

  …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
  ∫ ACHTUNG: Da die I/O-Library AVT-Funktionen enthÑlt, kînnen die Funktionen ∫
  ∫          dieser Library nur verwendet werden, wenn das Library-Runtime-   ∫
  ∫          Modul (B&R-Modul IO_LIB.BR) im nullspannungssicheren Speicher    ∫
  ∫          (Anwender-ROM) der Steuerung vorhanden ist!                      ∫
  »ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº













                                     @002[ Fortsetzung ]               @999[ HILFE beenden ]
.2
    Funktionen der I/O-Library (Fortsetzung)

    Nach dem Importieren der I/O-Library stehen Ihnen folgende Funktionen zur
    VerfÅgung:

    @030[IO_mphydef] Multiple physikalische Schaufelauftragsdefinition
    @040[IO_ptest  ] Physikalischen Schaufelauftragsdefinition testen
    @060[IO_data   ] I/O-Schaufelauftrag ausfÅhren
    @080[IO_info   ] Bestimmen des fehlerverursachenden I/O-Moduls
    @090[IX_info   ] Bestimmen des fehlerverursachenden Submoduls (Anpassungsmoduls)
    @100[IO_disable] Deaktivieren eines I/O-Moduls
    @110[IX_disable] Deaktivieren eines I/O-Moduls mit Subslots
    @120[IO_enable ] Aktivieren eines I/O-Moduls
    @130[IX_enable ] Aktivieren eines I/O-Moduls mit Subslots
    @140[IO_check  ] PrÅfen eines I/O-Moduls
    @150[IX_check  ] PrÅfen eines I/O-Moduls mit Subslots
    @160[IO_alloc  ] Allokieren eines I/O-Datenbereichs
    @170[IO_free   ] Freigabe eines I/O-Datenbereichs
    @180[IO_list   ] Liste aller gesteckten I/O-Module erstellen
    @200[IO_slist  ] Liste aller gesteckten Submodule (Anpassungsmodule) erstellen

                                     @003[ Fortsetzung ]                   @001[ öbersicht ]
.3
    Funktionen der I/O-Library (Fortsetzung)

    @210[SYS_list  ] Liste aller gesteckten Systemmodule erstellen
    @230[HW_list   ] Liste aller Hardware-Module erstellen

















                                       @500[ ANHANG ]                      @001[ öbersicht ]
.30
    IO_mphydef - Multiple physikalische Schaufelauftragsdefinition

    @031[IO_mphydef] (enable,adr(iop_adr),adr(sc_adr),io_index,status,ioident)

    Parameter-Datentypen :
    ->  enable    : BIT           Der Funktionsblock wird nur ausgefÅhrt, wenn
                                  "enable" = 1 ist
    ->  @035[iop_adr   ]: iop-Struktur  Struktur, in der die I/O-Parameter angegeben
                                  werden
    ->  sc_adr    : BYTE (FELD)   Datenbereich fÅr Schaufelinformation.
                                  Die LÑnge dieses BYTE-Feldes wird wie folgt
                                  berechnet:
                                  LÑnge = (Anzahl der EintrÑge) * 6 + 30
    ->  io_index  : WORD          Index des Schaufeleintrags fÅr Definition
    <-  @037[status    ]: WORD          Fehlernummer (0 = kein Fehler)
    <-  @038[ioident   ]: LONG          Identifier fÅr I/O-Schaufelauftrag (wird fÅr
                                  die Funktion IO_data() benîtigt)




                                     @031[ Fortsetzung ]                   @001[ öbersicht ]
.31
    IO_mphydef - Multiple physikalische Schaufelauftragsdefinition (Fortsetzung)

    Die Funktion IO_mphydef() baut mit Hilfe der Åbergebenen I/O-Parameter
    (siehe Struktur iop) einen Schaufelauftrag fÅr den I/O-Prozessor bzw. die
    I/O-Emulation (System B&R 2005) auf. Dabei wird der Schaufelauftrag im
    bereitgestellten Bereich "sc_adr" abgelegt. Dieser Datenbereich fÅr die
    Schaufelinformation mu· als Merker (lokal, tk_global oder rps_global)
    definiert werden, das Anfordern mit der Funktion MEM_alloc() oder
    TMP_alloc() ist nicht zulÑssig. Auch eine explizite Manipulation in der
    Applikation ist nicht zulÑssig.
    Ab Version V2.00 der I/O-Library kann der benîtigte I/O-Datenbereich mit
    der Funktion @160[IO_alloc()] allokiert werden.
    Im Datenbereich "sc_adr" kînnen mehrere SchaufeleintrÑge abgelegt werden.
    Der Parameter "io_index" gibt den Index des Schaufeleintrags im Schaufel-
    informationsbereich "sc_adr" an. Der Bereich "sc_adr" ist also das
    "GedÑchtnis" der I/O-Behandlung, das beim Aufruf von IO_data() verwendet
    wird. Damit kann die Funktion IO_mphydef() auch in einer "loop" Anweisung
    aufgerufen werden, wobei Åber die Struktur iop die I/O-Parameter fÅr den
    Eintrag "io_index" Åbergeben werden. Der Index 0 reprÑsentiert den ersten
    Eintrag.

                                     @032[ Fortsetzung ]                   @001[ öbersicht ]
.32
    IO_mphydef - Multiple physikalische Schaufelauftragsdefinition (Fortsetzung)

    Wenn das Feld "sc_adr" als RPS-globaler Merker definiert wird, und in der
    Struktur iop fÅr "data_adr" die Adresse eines RPS-globalen Merkers Åber-
    geben wird, kann die Funktion IO_mphydef() auch am Multiprozessor (MP)
    aufgerufen werden. FÅr das Schaufeln der Daten mu· dann zyklisch die
    Funktion IO_data() aufgerufen werden. Somit kann auch am Multiprozessor
    auf RPSIO zugegriffen werden, wobei natÅrlich die Busbelastung am System-
    bus steigt.

    Achtung!
    - Um die LeistungsfÑhigkeit des Systems nicht zu beeintrÑchtigen, sollte
      die Funktion IO_mphydef() nur in INIT-UPs der zyklischen Tasks bzw. in
      Taskklassen mit entsprechend gro·er Zykluszeit verwendet werden.
    - Das Definieren von SchaufelauftrÑgen am Remote I/O-Bus wird mit der
      Funktion IO_mphydef() nicht unterstÅtzt.
    - Am MP dÅrfen nur RPS-globale Merker verwendet werden!
    - Die Laufzeit der Funktion IO_mphydef() hÑngt auch davon ab, ob vor dem
      aktuell definierten Eintrag nicht verwendete EintrÑge initialisiert
      werden mÅssen (siehe dazu @650[AusfÅhrungszeiten]).

                                     @030[ IO_mphydef ]                    @001[ öbersicht ]
.35
    IO_mphydef - Multiple physikalische Schaufelauftragsdefinition (Fortsetzung)

    -> Parameter <iop_adr    >: iop-Struktur

    In der Struktur iop werden alle Parameter fÅr die Definition eines Eintrags
    angegeben. Wird fÅr adr(iop_adr) der Wert 0 Åbergeben, so wird der Eintrag
    mit dem Index "io_index" wieder deaktiviert und beim nÑchsten Aufruf von
    IO_data() nicht mehr geschaufelt. Elemente der Struktur iop:

    io_type    : BYTE    I/O-Typ:
                         0 ... 2010-IO
                         1 ... 2005-IO
                         5 ... 2003-IO
    master_no  : BYTE    Logische Nummer des IO-Masters (derzeit immer 1)
    slave_no   : BYTE    B&R 2010: immer 0
                         B&R 2005: Nummer der RÅckwand
                         0 ... BasisrÅckwand
                         1 ... ErweiterungsrÅckwand 1
                         usw.
                         B&R 2003: immer 0

                                     @036[ Fortsetzung ]                   @001[ öbersicht ]
.36
    IO_mphydef - Multiple physikalische Schaufelauftragsdefinition (Fortsetzung)

    module_adr : BYTE    Moduladresse des I/O-Moduls (in dezimaler Form)
    intern_off : BYTE    Interner Offset am Modul (wie bei Modultyp
                         "Transp. In" bzw. "Transp. Out")
    mode       : BYTE    Zugriffsmodus:
                         Bit 5 = 0 ... Schreiben des Output-Abbildes
                         Bit 5 = 1 ... Lesen des Input-Abbildes
                         Bit 6 = 0 ... Zugriff auf den normalen I/O-Bereich
                         Bit 6 = 1 ... Zugriff auf den Statusbereich des
                                       I/O-Moduls
    data_len   : BYTE    LÑnge des zu schaufelnden Datenbereichs in Byte
                         (bei BIT: Anzahl der 8-Bit-Gruppen)
    reserve    : BYTE    Reserve (wegen WORD-Ausrichtung)
    data_adr   : LONG    Adresse eines analogen Merkerbereichs (lokal,
                         tk_global oder rps_global) mit der bei data_len
                         angegebenen LÑnge. Es kann nur auf analoge Merker,
                         aber nicht auf digitale Merker geschaufelt werden.
                         D.h. digitale Daten kînnen nur gepackt (in Gruppen
                         zu 8 Bit) geschaufelt werden.

                                     @030[ IO_mphydef ]                    @001[ öbersicht ]
.37
    IO_mphydef - Multiple physikalische Schaufelauftragsdefinition (Fortsetzung)

    <- Parameter <status    >: WORD

    Fehlernummern:
    5501     Falsche Parameter
    5556     Falsche Adresse "data_adr" angegeben
    5557     Falscher Offset "intern_off" oder falsche LÑnge "data_len"
    5564     Kein Zugriff auf 2010-IO bzw. 2005-Erweiterungen
    5565     Kein 2005-Basis-IO vorhanden
    5569     SC-Adresse nicht WORD-Aligned
    5576     Fehler beim 2003-Direkt-IO
    5578     2003: Direkt-IO-Overflow
    9136     IO-Fehler 2003

    Alle anderen Fehlernummern sind im Anhang @600[Fehlermeldungen] beschrieben.





                                     @030[ IO_mphydef ]                    @001[ öbersicht ]
.38
    IO_mphydef - Multiple physikalische Schaufelauftragsdefinition (Fortsetzung)

    <- Parameter <ioident    >: LONG

    Als Ergebnis liefert die Funktion IO_mphydef() einen Identifier fÅr den
    I/O-Schaufelauftrag (Ausgangsparameter "ioident"). Dieser Identifier wird
    zum AusfÅhren des definierten I/O-Schaufelauftrags mit der Funktion
    IO_data() benîtigt. Der Identifier ist jedoch nur gÅltig, wenn der Ausgang
    "status" gleich 0 ist.












                                     @030[ IO_mphydef ]                    @001[ öbersicht ]
.40
    IO_ptest - Physikalische Schaufelauftragsdefinition testen

    @041[IO_ptest] (enable,adr(iop_adr),status,ok)

    Parameter-Datentypen :
    ->  enable    : BIT           Der Funktionsblock wird nur ausgefÅhrt, wenn
                                  "enable" = 1 ist
    ->  @045[iop_adr   ]: iop-Struktur  Struktur, in der die I/O-Parameter angegeben
                                  werden
    <-  @047[status    ]: WORD          Fehlernummer (0 = kein Fehler)
    <-  ok        : BIT           Flag, das anzeigt, ob der Schaufelauftrag
                                  korrekt durchgefÅhrt werden kann:
                                  1 ... Schaufelauftrag o.k.
                                  0 ... Schaufelauftrag nicht o.k.

    Die Funktion IO_ptest() baut mit Hilfe der Åbergebenen I/O-Parameter
    (siehe Struktur iop) einen Schaufelauftrag fÅr den I/O-Prozessor bzw. die
    I/O-Emulation (System B&R 2005) auf. Der Schaufelauftrag wird im statischen
    FUB-Bereich abgelegt. Daher kann die Funktion nur auf der Zentraleinheit,
    aber nicht am Parallelprozessor bzw. Multiprozessor aufgerufen werden.

                                     @041[ Fortsetzung ]                   @001[ öbersicht ]
.41
    IO_ptest - Physikalische Schaufelauftragsdefinition testen (Fortsetzung)

    Der Schaufelauftrag wird einmal ausgefÅhrt, um zu ermitteln, ob der Auftrag
    korrekt durchgefÅhrt werden kann, oder ob es zu einem I/O-Fehler kommt
    (I/O-Modul nicht vorhanden oder falscher I/O-Modul-Typ gesteckt).
    Wenn ein Fehler aufgetreten ist, wird am Ausgang "status" eine entspre-
    chende Fehlernummer ausgegeben und der Ausgang "ok" auf 0 gesetzt.














                                     @042[ Fortsetzung ]                   @001[ öbersicht ]
.42
    IO_ptest - Physikalische Schaufelauftragsdefinition testen (Fortsetzung)

    Achtung!
    - Um die LeistungsfÑhigkeit des Systems nicht zu beeintrÑchtigen, sollte
      die Funktion IO_ptest() nur in INIT-UPs der zyklischen Tasks bzw. in
      Taskklassen mit entsprechend gro·er Zykluszeit verwendet werden.
    - Die Funktion IO_ptest() darf in superschnellen Taskklassen nicht auf-
      gerufen werden (Ausnahme: Initialisierungs-Unterprogramme der super-
      schnellen Taskklassen).
    - Die Funktion IO_ptest() darf am Parallelprozessor bzw. Multiprozessor
      nicht verwendet werden!
    - Im System B&R 2005 kann die Funktion IO_ptest() nur fÅr die BasisrÅckwand
      verwendet werden. Bei den ErweiterungsrÅckwÑnden ist der Einsatz dieser
      Funktion nicht mîglich, da bei einem Fehler (I/O-Modul nicht vorhanden)
      die ganze ErweiterungsrÅckwand rÅckgesetzt werden mÅ·te. Ab der Version
      V1.60 der I/O-Library kann jedoch mit der Funktion IO_list() die im Hoch-
      lauf ermittelte I/O-Konfiguration von 2005-Erweiterungen festgestellt
      werden.



                                      @040[ IO_ptest ]                     @001[ öbersicht ]
.45
    IO_ptest - Physikalische Schaufelauftragsdefinition testen (Fortsetzung)

    -> Parameter <iop_adr    >: iop-Struktur

    Elemente der Struktur iop:

    io_type    : BYTE    I/O-Typ:
                         0 ... 2010-IO
                         1 ... 2005-IO
                         5 ... 2003-IO
    master_no  : BYTE    Logische Nummer des IO-Masters (derzeit immer 1)
    slave_no   : BYTE    B&R 2010: immer 0
                         B&R 2005: Nummer der RÅckwand
                         0 ... BasisrÅckwand
                         1 ... ErweiterungsrÅckwand 1
                         usw.
                         B&R 2003: immer 0
    module_adr : BYTE    Moduladresse des I/O-Moduls (in dezimaler Form)
    intern_off : BYTE    Interner Offset am Modul (wie bei Modultyp
                         "Transp. In" bzw. "Transp. Out")

                                     @046[ Fortsetzung ]                   @001[ öbersicht ]
.46
    IO_ptest - Physikalische Schaufelauftragsdefinition testen (Fortsetzung)

    mode       : BYTE    Zugriffsmodus:
                         Bit 5 = 0 ... Schreiben des Output-Abbildes
                         Bit 5 = 1 ... Lesen des Input-Abbildes
                         Bit 6 = 0 ... Zugriff auf den normalen I/O-Bereich
                         Bit 6 = 1 ... Zugriff auf den Statusbereich des
                                       I/O-Moduls
    data_len   : BYTE    LÑnge des zu schaufelnden Datenbereichs in Byte
                         (bei BIT: Anzahl der 8-Bit-Gruppen)
    reserve    : BYTE    Reserve (wegen WORD-Ausrichtung)
    data_adr   : LONG    Adresse eines analogen Merkerbereichs (lokal,
                         tk_global oder rps_global) mit der bei data_len
                         angegebenen LÑnge. Es kann nur auf analoge Merker,
                         aber nicht auf digitale Merker geschaufelt werden.
                         D.h. digitale Daten kînnen nur gepackt (in Gruppen
                         zu 8 Bit) geschaufelt werden.




                                      @040[ IO_ptest ]                     @001[ öbersicht ]
.47
    IO_ptest - Physikalische Schaufelauftragsdefinition testen (Fortsetzung)

    <- Parameter <status    >: WORD

    Fehlernummern:
    5501     Falsche Parameter
    5551     IO_ptest() in mehreren Taskklassen parallel aufgerufen
    5553     IO_ptest() darf nicht in HS-Taskklassen aufgerufen werden
    5555     I/O-Modul nicht gesteckt oder falsch
    5556     Falsche Adresse "data_adr" angegeben
    5557     Falscher Offset "intern_off" oder falsche LÑnge "data_len"
    5558     IO_ptest() darf am Parallelprozessor bzw. Multiprozessor nicht
             aufgerufen werden
    5563     IO_ptest() auf Systemen mit EX350 derzeit nicht mîglich
    5567     FUB-Daten liegen nicht im IO/Merker-Pool
    5576     Fehler beim 2003-Direkt-IO
    9136     IO-Fehler 2003

    Alle anderen Fehlernummern sind im Anhang @600[Fehlermeldungen] beschrieben.


                                      @040[ IO_ptest ]                     @001[ öbersicht ]
.60
    IO_data - I/O-Datenschaufelauftrag ausfÅhren

    @061[IO_data] (enable,ioident,status)

    Parameter-Datentypen :
    ->  enable    : BIT           Der Funktionsblock wird nur ausgefÅhrt, wenn
                                  enable = 1 ist
    ->  ioident   : LONG          Identifier fÅr I/O-Schaufelauftrag von der
                                  Funktion IO_mphydef()
    <-  @065[status    ]: WORD          Fehlernummer (0 = kein Fehler)

    Diese Funktion fÅhrt den mit IO_mphydef() definierten Schaufelauftrag
    aus. Nach dem Aufruf dieser Funktion stehen die geschaufelten Daten zur
    VerfÅgung.
    Ausnahme: Wenn am Ausgang "status" der Fehler 5559 geliefert wird, kann
    der I/O-Zugriff nicht direkt erfolgen, es wurde nur ein Auftrag abgesetzt.
    Die Funktion mu· daher im nÑchsten Zyklus noch einmal aufgerufen werden,
    bis "status" ungleich 5559 ist. Erst dann stehen die Daten zur VerfÅgung
    (2003-IO).


                                     @061[ Fortsetzung ]                   @001[ öbersicht ]
.61
    IO_data - I/O-Datenschaufelauftrag ausfÅhren (Fortsetzung)

    Die Datenbereiche, auf die geschaufelt wird, werden bei der Definition
    (physikalische oder logische Schaufelauftragsdefinition) angegeben. Dies
    sind entweder explizite Datenbereiche (analoge Merkerbereiche) oder die
    vom Programmiersystem PG2000 vergebenen Datenbereiche (implizite Daten-
    bereiche, analog oder digital).
    Werden digitale Proze·variablen explizit geschaufelt, so kînnen sie nur
    gepackt in den Analogbereich geschaufelt werden. D.h. alle Variablen, die
    der gleichen 8-Bit-Gruppe angehîren, werden beim Aufruf der Funktion
    IO_data() auf den neuesten Stand gebracht.

    Die Tasks, die die entsprechenden SchaufelauftrÑge definieren, dÅrfen nicht
    deinstalliert werden, solange die Funktion IO_data() auf diese Identifier
    ("ioident") angewandt wird, da sonst die Datenbereiche nicht mehr zur Ver-
    fÅgung stehen!





                                     @062[ Fortsetzung ]                   @001[ öbersicht ]
.62
    IO_data - I/O-Datenschaufelauftrag ausfÅhren (Fortsetzung)

    Achtung!
    - Durch die öbergabe eines falschen Identifiers fÅr den Schaufelauftrag
      (Parameter "ioident") kann eine Exception ausgelîst werden. Tritt bei
      der Definition des Schaufelauftrags ein Fehler auf, wird der Åbergebene
      Identifier fÅr den Schaufelauftrag (Parameter "ioident") auf einen un-
      gÅltigen Wert gesetzt!
    - Beim expliziten Schaufeln von digitalen Ausgangsdaten Åber explizite
      Datenbereiche wird immer eine 8-Bit-Gruppe geschaufelt. Bei nicht ver-
      wendeten KanÑlen der Gruppe sind daher Inkonsistenzen mîglich.
    - Erfolgt ein direkter Zugriff auf ein nicht vorhandenes I/O-Modul, wird
      (wie beim zyklischen Zugriff auf ein nicht gestecktes I/O-Modul) eine
      I/O-Exception (Exception-Nr. 128) ausgelîst.
    - Mit der Funktion IO_data() ist kein Zugriff auf Remote I/O-Daten mîglich!






                                       @060[ IO_data ]                     @001[ öbersicht ]
.65
    IO_data - I/O-Datenschaufelauftrag ausfÅhren (Fortsetzung)

    <- Parameter <status    >: WORD

    Fehlernummern:
    5559     Funktion IO_data() in Arbeit (Aufruf im nÑchsten Zyklus notwendig)
    5568     IO-Exception fuer 2010-IO oder 2005-Expansionen durch parallel
             aktivierten, noch nicht abgeschlossenen Auftrag, z.B. IO_check
             auf ein nicht vorhandenes IO-Modul
    9111     IO-Exception fuer 2010-IO oder 2005-Expansionen durch aktuelles
             IO_data selbst
    9136     IO-Fehler 2003
    11716    Timeout beim Schaufelauftrag (fataler Fehler)
    11717    UngÅltiger I/O-Identifier

    Alle anderen Fehlernummern sind im Anhang @600[Fehlermeldungen] beschrieben.





                                       @060[ IO_data ]                     @001[ öbersicht ]
.80
    IO_info - Bestimmen des fehlerverursachenden I/O-Moduls

    @081[IO_info] (enable,status,io_type,master_no,slave_no,module_adr,
             intern_off,mode)

    Parameter-Datentypen :
    ->  enable    : BIT           Der Funktionsblock wird nur ausgefÅhrt, wenn
                                  enable = 1 ist
    <-  @085[status    ]: WORD          Fehlernummer (0 = kein Fehler)
    <-  io_type   : BYTE          I/O-Typ: 0 ... 2010-IO
                                           1 ... 2005-IO
                                           2 ... RIO-2010
                                           3 ... RIO-2005
                                           4 ... RIO-2003
                                           5 ... 2003-IO
    <-  master_no : BYTE          Logische Nummer des IO-Masters (derzeit
                                  immer 1) bzw. des RIO-Masters
    <-  slave_no  : BYTE          Nummer des RIO-Slaves bzw. Nummer der 2005-
                                  RÅckwand (0=BasisrÅckwand, 1=Erweiterungs-
                                  rÅckwand 1, 2=ErweiterungsrÅckwand 2, usw.).

                                     @081[ Fortsetzung ]                   @001[ öbersicht ]
.81
    IO_info - Bestimmen des fehlerverursachenden I/O-Moduls (Fortsetzung)

    Parameter-Datentypen (Fortsetzung) :
                                  Bei 2010-IO und 2003-IO mu· fÅr slave_no
                                  immer der Wert 0 angegeben werden.
    <-  module_adr: BYTE          Moduladresse des I/O-Moduls
                                  (in dezimaler Form)
    <-  intern_off: BYTE          Interner Offset am Modul (wie bei Modultyp
                                  "Transp. In" bzw. "Transp. Out")
    <-  mode      : BYTE          Zugriffsmodus:
                                  Bit 5 = 0 ... Fehler beim Schreiben des
                                                Output-Abbildes
                                  Bit 5 = 1 ... Fehler beim Lesen des Input-
                                                Abbildes
                                  Bit 6 = 0 ... Fehler beim Zugriff auf den
                                                normalen I/O-Bereich
                                  Bit 6 = 1 ... Fehler beim Zugriff auf den
                                                Statusbereich des I/O-Moduls



                                     @082[ Fortsetzung ]                   @001[ öbersicht ]
.82
    IO_info - Bestimmen des fehlerverursachenden I/O-Moduls (Fortsetzung)

    Mit der Funktion IO_info() kann bei Auftreten einer I/O-Exception das
    fehlerverursachende I/O-Modul bestimmt werden. Mit den (durch den Aufruf
    dieser Funktion) erhaltenen I/O-Informationen kann das weitere Verhalten
    bei I/O-Exceptions festgelegt werden (z.B. Deaktivieren des I/O-Moduls
    mit der Funktion IO_disable()). Mit Hilfe von IO_check() kann geprÅft
    werden, ob das I/O-Modul wieder vorhanden ist.

    Die Funktion IO_info() darf nur in Exceptiontasks fÅr die I/O-Exception
    (Exception-Nr. 128) aufgerufen werden, da nur dort die I/O-Information zur
    VerfÅgung steht. Wird die Funktion in einer anderen Task verwendet, wird
    am Ausgang "status" eine entsprechende Fehlernummer (5550) ausgegeben.








                                     @083[ Fortsetzung ]                   @001[ öbersicht ]
.83
    IO_info - Bestimmen des fehlerverursachenden I/O-Moduls (Fortsetzung)

    Achtung!
    - Da Exceptiontasks in der Version 1.05 des Betriebssystems RPSSW noch
      nicht unterstÅtzt werden, ist der Einsatz der Funktion IO_info() erst
      ab Version 1.10 der RPSSW mîglich.
    - Diese Funktion kann nur verwendet werden, wenn der Exceptionhandler
      EXERMO.BR (mindestens Version 1.11) auf der Zentraleinheit (Anwender-ROM)
      vorhanden ist!
    - Die Funktion IO_info() darf nur in Exceptiontasks fÅr die I/O-Exception
      (Exception-Nr. 128) verwendet werden!










                                       @080[ IO_info ]                     @001[ öbersicht ]
.85
    IO_info - Bestimmen des fehlerverursachenden I/O-Moduls (Fortsetzung)

    <- Parameter <status    >: WORD

    Fehlernummern:
    5550     IO_info(): Keine Information vorhanden (falscher Kontext)

    Alle anderen Fehlernummern sind im Anhang @600[Fehlermeldungen] beschrieben.













                                       @080[ IO_info ]                     @001[ öbersicht ]
.90
    IX_info - Bestimmen des fehlerverursachenden Anpassungsmoduls

    @091[IX_info] (enable,status,io_type,master_no,slave_no,module_adr,slot,
             intern_off,mode)

    Parameter-Datentypen :
    ->  enable    : BIT           Der Funktionsblock wird nur ausgefÅhrt, wenn
                                  enable = 1 ist
    <-  @095[status    ]: WORD          Fehlernummer (0 = kein Fehler)
    <-  io_type   : BYTE          I/O-Typ: 0 ... 2010-IO
                                           1 ... 2005-IO
                                           2 ... RIO-2010
                                           3 ... RIO-2005
                                           4 ... RIO-2003
                                           5 ... 2003-IO
    <-  master_no : BYTE          Logische Nummer des IO-Masters (derzeit
                                  immer 1) bzw. des RIO-Masters
    <-  slave_no  : BYTE          Nummer des RIO-Slaves bzw. Nummer der 2005-
                                  RÅckwand (0=BasisrÅckwand, 1=Erweiterungs-
                                  rÅckwand 1, 2=ErweiterungsrÅckwand 2, usw.).

                                     @091[ Fortsetzung ]                   @001[ öbersicht ]
.91
    IX_info - Bestimmen des fehlerverursachenden Anpassungsmoduls (Fortsetzung)

    Parameter-Datentypen (Fortsetzung) :
                                  Bei 2010-IO und 2003-IO mu· fÅr slave_no
                                  immer der Wert 0 angegeben werden.
    <-  module_adr: BYTE          Moduladresse des I/O-Moduls
                                  (in dezimaler Form)
    <-  slot      : BYTE          Steckplatz (Subslot) des Submoduls (auch
                                  Anpassungsmodul genannt)
    <-  intern_off: BYTE          Interner Offset am Modul (wie bei Modultyp
                                  "Transp. In" bzw. "Transp. Out")
    <-  mode      : BYTE          Zugriffsmodus:
                                  Bit 5 = 0 ... Fehler beim Schreiben des
                                                Output-Abbildes
                                  Bit 5 = 1 ... Fehler beim Lesen des Input-
                                                Abbildes
                                  Bit 6 = 0 ... Fehler beim Zugriff auf den
                                                normalen I/O-Bereich
                                  Bit 6 = 1 ... Fehler beim Zugriff auf den
                                                Statusbereich des I/O-Moduls

                                     @092[ Fortsetzung ]                   @001[ öbersicht ]
.92
    IX_info - Bestimmen des fehlerverursachenden Anpassungsmoduls (Fortsetzung)

    Mit der Funktion IX_info() kann bei Auftreten einer I/O-Exception das
    fehlerverursachende Anpassungsmodul bestimmt werden. Mit den (durch den
    Aufruf dieser Funktion) erhaltenen I/O-Informationen kann das weitere
    Verhalten bei I/O-Exceptions festgelegt werden (z.B. Deaktivieren des
    Anpassungsmoduls mit der Funktion IX_disable()). Mit Hilfe von IX_check()
    kann geprÅft werden, ob das I/O-Modul wieder vorhanden ist.

    Die Funktion IX_info() darf nur in Exceptiontasks fÅr die I/O-Exception
    (Exception-Nr. 128) aufgerufen werden, da nur dort die I/O-Information zur
    VerfÅgung steht. Wird die Funktion in einer anderen Task verwendet, wird
    am Ausgang "status" eine entsprechende Fehlernummer (5550) ausgegeben.








                                     @093[ Fortsetzung ]                   @001[ öbersicht ]
.93
    IX_info - Bestimmen des fehlerverursachenden Anpassungsmoduls (Fortsetzung)

    Achtung!
    - Da Exceptiontasks in der Version 1.05 des Betriebssystems RPSSW noch
      nicht unterstÅtzt werden, ist der Einsatz der Funktion IX_info() erst
      ab Version 1.10 der RPSSW mîglich.
    - Diese Funktion kann nur verwendet werden, wenn der Exceptionhandler
      EXERMO.BR (mindestens Version 1.11) auf der Zentraleinheit (Anwender-ROM)
      vorhanden ist!
    - Die Funktion IX_info() darf nur in Exceptiontasks fÅr die I/O-Exception
      (Exception-Nr. 128) verwendet werden!










                                       @090[ IX_info ]                     @001[ öbersicht ]
.95
    IX_info - Bestimmen des fehlerverursachenden Anpassungsmoduls (Fortsetzung)

    <- Parameter <status    >: WORD

    Fehlernummern:
    5550     IX_info(): Keine Information vorhanden (falscher Kontext)

    Alle anderen Fehlernummern sind im Anhang @600[Fehlermeldungen] beschrieben.













                                       @090[ IX_info ]                     @001[ öbersicht ]
.100
    IO_disable - Deaktivieren eines I/O-Moduls

    @101[IO_disable] (enable,io_type,master_no,slave_no,module_adr,force_flag,
                dig_value,ana_value,status)

    Parameter-Datentypen :
    ->  enable    : BIT           Der Funktionsblock wird nur ausgefÅhrt, wenn
                                  enable = 1 ist
    ->  io_type   : BYTE          I/O-Typ: 0 ... 2010-IO
                                           1 ... 2005-IO
                                           2 ... RIO-2010
                                           3 ... RIO-2005
                                           4 ... RIO-2003
                                           5 ... 2003-IO
    ->  master_no : BYTE          Logische Nummer des IO-Masters (derzeit
                                  immer 1) bzw. des RIO-Masters
    ->  slave_no  : BYTE          Nummer des RIO-Slaves bzw. Nummer der 2005-
                                  RÅckwand (0=BasisrÅckwand, 1=Erweiterungs-
                                  rÅckwand 1, 2=ErweiterungsrÅckwand 2, usw.).


                                     @101[ Fortsetzung ]                   @001[ öbersicht ]
.101
    IO_disable - Deaktivieren eines I/O-Moduls (Fortsetzung)

    Parameter-Datentypen (Fortsetzung) :
                                  Bei 2010-IO und 2003-IO mu· fÅr slave_no
                                  immer der Wert 0 angegeben werden.
    ->  module_adr: BYTE          Moduladresse des I/O-Moduls
                                  (in dezimaler Form)
    ->  force_flag: BIT           Flag, mit dem festgelegt wird, ob Input-Werte
                                  im normalen I/O-Bereich fÅr die Applikation
                                  geforced werden sollen:
                                  0 ... Inputs (digital/analog) nicht forcen
                                  1 ... Inputs (digital/analog) forcen
    ->  dig_value : BIT           Force-Wert fÅr digitale Inputs des I/O-Moduls
    ->  ana_value : WORD          Force-Wert fÅr analoge Inputs des I/O-Moduls
    <-  @105[status    ]: WORD          Fehlernummer (0 = kein Fehler)

    Mit dieser Funktion werden alle zyklischen I/O-Zugriffe auf das angegebene
    I/O-Modul deaktiviert (unterbunden). Dadurch wird auf dieses I/O-Modul im
    zyklischen Betrieb nicht mehr zugegriffen, d.h. es kann keine I/O-Exception
    fÅr dieses Modul auftreten.

                                     @102[ Fortsetzung ]                   @001[ öbersicht ]
.102
    IO_disable - Deaktivieren eines I/O-Moduls (Fortsetzung)

    Damit kann der zyklische Zugriff auf I/O-Module dynamisch konfiguriert
    werden.

    Mit dem Force-Flag ("force_flag") und den Force-Werten fÅr digitale und
    analoge Inputs ("dig_value" und "ana_value") kann der Applikation statisch
    ein fixer Input-Wert aller KanÑle des deaktivierten I/O-Moduls vorge-
    spiegelt werden. Damit hat der Input auch im Fehlerfall, z.B. wenn das
    I/O-Modul entfernt wurde, einen (konfigurierbaren) definierten Wert.
    Bei digitalen Inputs werden immer alle geschaufelten KanÑle des I/O-Moduls
    auf den angegebenen digitalen Force-Wert gesetzt.
    Wenn am I/O-Modul analoge Felder verwendet werden, setzt die Funktion
    IO_disable() alle Input-Feldelemente auf den analogen Force-Wert. Felder
    kînnen nur an Hand der Byte-LÑnge erkannt werden: Ist ein analoger
    Schaufeleintrag lÑnger als ein Word, so werden alle Words auf den analogen
    Force-Wert gesetzt. Bei analogen EintrÑgen mit ungerader LÑnge bzw.
    ungerader Adresse wird am Ausgang "status" eine entsprechende Fehlernummer
    (5552) ausgegeben.


                                     @103[ Fortsetzung ]                   @001[ öbersicht ]
.103
    IO_disable - Deaktivieren eines I/O-Moduls (Fortsetzung)

    Mit Hilfe der Funktion IO_check() kînnen Sie prÅfen, ob auf das I/O-Modul
    wieder zugegriffen werden kann, mit der Funktion IO_enable() kînnen die
    Zugriffe auf das I/O-Modul wieder aktiviert werden.

    Achtung!
    - Bei Verwendung der I/O-Library-Funktionen fÅr den direkten Zugriff
      auf I/O-Module bzw. beim Einsatz anderer Funktionen mit I/O-Zugriff
      (z.B. Spool-Funktionen), mu· die Applikation durch explizite Verriegelung
      dafÅr sorgen, da· auf ein gezogenes I/O-Modul mit der jeweiligen Funktion
      nicht mehr zugegriffen wird.
    - Input-Werte aus dem Statusbereich werden beim Aufruf dieser Funktion
      nicht geforced!
    - Mit dieser Funktion werden nur die zyklischen I/O-Zugriffe von Tasks,
      die bereits im System geladen sind, deaktiviert. Somit ist ein Download
      von Tasks, die nicht vorhandene I/O-Module ansprechen, nur im SERVICE-
      Modus mîglich.



                                     @100[ IO_disable ]                    @001[ öbersicht ]
.105
    IO_disable - Deaktivieren eines I/O-Moduls (Fortsetzung)

    <- Parameter <status    >: WORD

    Fehlernummern:
    5501     Falsche Parameter
    5552     Analogdaten mit ungerader LÑnge oder ungerader Adresse kînnen
             nicht geforced werden
    5558     IO_disable() darf am Parallelprozessor bzw. Multiprozessor nicht
             aufgerufen werden
    5562     IO_enable() bei optimierter IO-Emulation derzeit nicht mîglich

    Alle anderen Fehlernummern sind im Anhang @600[Fehlermeldungen] beschrieben.








                                     @100[ IO_disable ]                    @001[ öbersicht ]
.110
    IX_disable - Deaktivieren eines I/O-Moduls mit Subslots

    @111[IX_disable] (enable,io_type,master_no,slave_no,module_adr,slot,force_flag,
                dig_value,ana_value,status)

    Parameter-Datentypen :
    ->  enable    : BIT           Der Funktionsblock wird nur ausgefÅhrt, wenn
                                  enable = 1 ist
    ->  io_type   : BYTE          I/O-Typ: 0 ... 2010-IO
                                           1 ... 2005-IO
                                           2 ... RIO-2010
                                           3 ... RIO-2005
                                           4 ... RIO-2003
                                           5 ... 2003-IO
    ->  master_no : BYTE          Logische Nummer des IO-Masters (derzeit
                                  immer 1) bzw. des RIO-Masters
    ->  slave_no  : BYTE          Nummer des RIO-Slaves bzw. der 2005-RÅckwand
                                  (0=BasisrÅckwand, 1=ErweiterungsrÅckwand 1,
                                  usw.). Bei 2010-IO und 2003-IO mu· fÅr
                                  slave_no immer der Wert 0 angegeben werden.

                                     @111[ Fortsetzung ]                   @001[ öbersicht ]
.111
    IX_disable - Deaktivieren eines I/O-Moduls mit Subslots (Fortsetzung)

    Parameter-Datentypen (Fortsetzung) :
    ->  module_adr: BYTE          Moduladresse des I/O-Moduls
                                  (in dezimaler Form)
    ->  slot      : BYTE          Steckplatz (Subslot) auf dem Modul:
                                  0 ..... ganzes Modul mit allen gesteckten
                                          Submodulen (auch Anpassungsmodule
                                          genannt)
                                  1-4 ... Submodul (auch Anpassungsmodul ge-
                                          nannt) auf dem angegebenen Steck-
                                          platz (1-4)
    ->  force_flag: BIT           Flag, mit dem festgelegt wird, ob Input-Werte
                                  im normalen I/O-Bereich fÅr die Applikation
                                  geforced werden sollen:
                                  0 ... Inputs (digital/analog) nicht forcen
                                  1 ... Inputs (digital/analog) forcen
    ->  dig_value : BIT           Force-Wert fÅr digitale Inputs des I/O-Moduls
    ->  ana_value : WORD          Force-Wert fÅr analoge Inputs des I/O-Moduls
    <-  @115[status    ]: WORD          Fehlernummer (0 = kein Fehler)

                                     @112[ Fortsetzung ]                   @001[ öbersicht ]
.112
    IX_disable - Deaktivieren eines I/O-Moduls mit Subslots (Fortsetzung)

    Mit dieser Funktion werden alle zyklischen I/O-Zugriffe auf das angegebene
    Anpassungsmodul deaktiviert (unterbunden). Dadurch wird auf dieses Modul im
    zyklischen Betrieb nicht mehr zugegriffen, d.h. es kann keine I/O-Exception
    fÅr dieses Modul auftreten. Damit kann der zyklische Zugriff auf I/O-Module
    dynamisch konfiguriert werden.
    Mit dem Force-Flag ("force_flag") und den Force-Werten fÅr digitale und
    analoge Inputs ("dig_value" und "ana_value") kann der Applikation statisch
    ein fixer Input-Wert aller KanÑle des deaktivierten I/O-Moduls vorge-
    spiegelt werden. Damit hat der Input auch im Fehlerfall, z.B. wenn das
    I/O-Modul entfernt wurde, einen (konfigurierbaren) definierten Wert.
    Bei digitalen Inputs werden immer alle geschaufelten KanÑle des I/O-Moduls
    auf den angegebenen digitalen Force-Wert gesetzt.
    Wenn am I/O-Modul analoge Felder verwendet werden, setzt die Funktion
    IX_disable() alle Input-Feldelemente auf den analogen Force-Wert. Felder
    kînnen nur an Hand der Byte-LÑnge erkannt werden: Ist ein analoger
    Schaufeleintrag lÑnger als ein Word, so werden alle Words auf den analogen
    Force-Wert gesetzt. Bei analogen EintrÑgen mit ungerader LÑnge bzw.
    ungerader Adresse wird am Ausgang "status" eine entsprechende Fehlernummer
    (5552) ausgegeben.
                                     @113[ Fortsetzung ]                   @001[ öbersicht ]
.113
    IX_disable - Deaktivieren eines I/O-Moduls mit Subslots (Fortsetzung)

    Mit Hilfe der Funktion IX_check() kînnen Sie prÅfen, ob auf das Anpassungs-
    modul wieder zugegriffen werden kann, mit der Funktion IX_enable() kînnen
    die Zugriffe auf das Anpassungsmodul wieder aktiviert werden.

    Achtung!
    - Bei Verwendung der I/O-Library-Funktionen fÅr den direkten Zugriff
      auf I/O-Module bzw. beim Einsatz anderer Funktionen mit I/O-Zugriff
      (z.B. Spool-Funktionen), mu· die Applikation durch explizite Verriegelung
      dafÅr sorgen, da· auf ein gezogenes I/O-Modul mit der jeweiligen Funktion
      nicht mehr zugegriffen wird.
    - Input-Werte aus dem Statusbereich werden beim Aufruf dieser Funktion
      nicht geforced!
    - Mit dieser Funktion werden nur die zyklischen I/O-Zugriffe von Tasks,
      die bereits im System geladen sind, deaktiviert. Somit ist ein Download
      von Tasks, die nicht vorhandene I/O-Module ansprechen, nur im SERVICE-
      Modus mîglich.



                                     @110[ IX_disable ]                    @001[ öbersicht ]
.115
    IX_disable - Deaktivieren eines I/O-Moduls mit Subslots (Fortsetzung)

    <- Parameter <status    >: WORD

    Fehlernummern:
    5501     Falsche Parameter
    5552     Analogdaten mit ungerader LÑnge oder ungerader Adresse kînnen
             nicht geforced werden
    5558     IX_disable() darf am Parallelprozessor bzw. Multiprozessor nicht
             aufgerufen werden
    5562     IX_enable() bei optimierter IO-Emulation derzeit nicht mîglich

    Alle anderen Fehlernummern sind im Anhang @600[Fehlermeldungen] beschrieben.








                                     @110[ IX_disable ]                    @001[ öbersicht ]
.120
    IO_enable - Aktivieren eines I/O-Moduls

    @121[IO_enable] (enable,io_type,master_no,slave_no,module_adr,status)

    Parameter-Datentypen :
    ->  enable    : BIT           Der Funktionsblock wird nur ausgefÅhrt, wenn
                                  enable = 1 ist
    ->  io_type   : BYTE          I/O-Typ: 0 ... 2010-IO
                                           1 ... 2005-IO
                                           2 ... RIO-2010
                                           3 ... RIO-2005
                                           4 ... RIO-2003
                                           5 ... 2003-IO
    ->  master_no : BYTE          Logische Nummer des IO-Masters (derzeit
                                  immer 1) bzw. des RIO-Masters
    ->  slave_no  : BYTE          Nummer des RIO-Slaves bzw. Nummer der 2005-
                                  RÅckwand (0=BasisrÅckwand, 1=Erweiterungs-
                                  rÅckwand 1, 2=ErweiterungsrÅckwand 2, usw.).
                                  Bei 2010-IO und 2003-IO mu· fÅr slave_no
                                  immer der Wert 0 angegeben werden.

                                     @121[ Fortsetzung ]                   @001[ öbersicht ]
.121
    IO_enable - Aktivieren eines I/O-Moduls (Fortsetzung)

    Parameter-Datentypen (Fortsetzung) :
    ->  module_adr: BYTE          Moduladresse des I/O-Moduls
                                  (in dezimaler Form)
    <-  @125[status    ]: WORD          Fehlernummer (0 = kein Fehler)

    Mit dieser Funktion werden alle zyklischen Zugriffe auf das festgelegte
    I/O-Modul aktiviert (freigegeben). Damit kann der zyklische I/O-Zugriff
    dynamisch konfiguriert werden.

    Achtung!
    Mit der Funktion IO_enable() werden alle zyklischen Zugriffe aktiviert
    (auch die mit DBTOOL.EXE oder mit dem Modul SPSIO.BR statisch deaktivierten
    Zugriffe auf I/O-Module).






                                      @120[ IO_enable ]                    @001[ öbersicht ]
.125
    IO_enable - Aktivieren eines I/O-Moduls (Fortsetzung)

    <- Parameter <status    >: WORD

    Fehlernummern:
    5501     Falsche Parameter
    5562     IO_enable() bei optimierter IO-Emulation derzeit nicht mîglich

    Alle anderen Fehlernummern sind im Anhang @600[Fehlermeldungen] beschrieben.












                                      @120[ IO_enable ]                    @001[ öbersicht ]
.130
    IX_enable - Aktivieren eines I/O-Moduls mit Subslots

    @131[IX_enable] (enable,io_type,master_no,slave_no,module_adr,slot,status)

    Parameter-Datentypen :
    ->  enable    : BIT           Der Funktionsblock wird nur ausgefÅhrt, wenn
                                  enable = 1 ist
    ->  io_type   : BYTE          I/O-Typ: 0 ... 2010-IO
                                           1 ... 2005-IO
                                           2 ... RIO-2010
                                           3 ... RIO-2005
                                           4 ... RIO-2003
                                           5 ... 2003-IO
    ->  master_no : BYTE          Logische Nummer des IO-Masters (derzeit
                                  immer 1) bzw. des RIO-Masters
    ->  slave_no  : BYTE          Nummer des RIO-Slaves bzw. Nummer der 2005-
                                  RÅckwand (0=BasisrÅckwand, 1=Erweiterungs-
                                  rÅckwand 1, 2=ErweiterungsrÅckwand 2, usw.).
                                  Bei 2010-IO und 2003-IO mu· fÅr slave_no
                                  immer der Wert 0 angegeben werden.

                                     @131[ Fortsetzung ]                   @001[ öbersicht ]
.131
    IX_enable - Aktivieren eines I/O-Moduls mit Subslots (Fortsetzung)

    Parameter-Datentypen (Fortsetzung) :
    ->  module_adr: BYTE          Moduladresse des I/O-Moduls
                                  (in dezimaler Form)
    ->  slot      : BYTE          Steckplatz (Subslot) auf dem Modul:
                                  0 ..... ganzes Modul mit allen gesteckten
                                          Submodulen (Anpassungsmodulen)
                                  1-4 ... Submodul (Anpassungsmodul) auf dem
                                          angegebenen Steckplatz (1-4)
    <-  @135[status    ]: WORD          Fehlernummer (0 = kein Fehler)

    Mit dieser Funktion werden alle zyklischen Zugriffe auf das festgelegte
    I/O-Modul aktiviert (freigegeben). Damit kann der zyklische I/O-Zugriff
    dynamisch konfiguriert werden.

    Achtung!
    Mit der Funktion IX_enable() werden alle zyklischen Zugriffe aktiviert
    (auch die mit DBTOOL.EXE oder mit dem Modul SPSIO.BR statisch deaktivierten
    Zugriffe auf I/O-Module).

                                      @130[ IX_enable ]                    @001[ öbersicht ]
.135
    IX_enable - Aktivieren eines I/O-Moduls mit Subslots (Fortsetzung)

    <- Parameter <status    >: WORD

    Fehlernummern:
    5501     Falsche Parameter
    5562     IX_enable() bei optimierter IO-Emulation derzeit nicht mîglich

    Alle anderen Fehlernummern sind im Anhang @600[Fehlermeldungen] beschrieben.












                                      @130[ IX_enable ]                    @001[ öbersicht ]
.140
    IO_check - PrÅfen eines I/O-Moduls

    @141[IO_check] (enable,io_type,master_no,slave_no,module_adr,search_typ,status,
              found_flag,module_typ)

    Parameter-Datentypen :
    ->  enable    : BIT           Der Funktionsblock wird nur ausgefÅhrt, wenn
                                  enable = 1 ist
    ->  io_type   : BYTE          I/O-Typ: 0 ... 2010-IO
                                           1 ... 2005-IO
                                           2 ... RIO-2010
                                           3 ... RIO-2005
                                           4 ... RIO-2003
                                           5 ... 2003-IO
    ->  master_no : BYTE          Logische Nummer des IO-Masters (derzeit
                                  immer 1) bzw. des RIO-Masters
    ->  slave_no  : BYTE          Nummer des RIO-Slaves bzw. der 2005-RÅckwand
                                  (0=BasisrÅckwand, 1=ErweiterungsrÅckwand 1,
                                  usw.). Bei 2010-IO und 2003-IO mu· fÅr
                                  slave_no immer der Wert 0 angegeben werden.

                                     @141[ Fortsetzung ]                   @001[ öbersicht ]
.141
    IO_check - PrÅfen eines I/O-Moduls (Fortsetzung)

    Parameter-Datentypen (Fortsetzung) :
    ->  module_adr: BYTE          Moduladresse des zu prÅfenden I/O-Moduls
                                  (in dezimaler Form)
    ->  search_typ: BYTE          Typ (@146[Typ-Code]), den das I/O-Modul mit der
                                  angegebenen Moduladresse haben mu·. Steckt
                                  an dieser Moduladresse ein I/O-Modul, das
                                  nicht den definierten Typ hat, wird ein
                                  Fehler gemeldet. Wenn der Typ des I/O-Moduls
                                  nicht geprÅft werden soll (Typ egal), mu·
                                  fÅr search_typ der Wert 0 Åbergeben werden.
    <-  @145[status    ]: WORD          Fehlernummer (0 = kein Fehler)
    <-  found_flag: BIT           Flag, das anzeigt, ob das I/O-Modul vor-
                                  handen ist:
                                  0 ... I/O-Modul mit angegebenem Typ nicht
                                        vorhanden
                                  1 ... I/O-Modul mit angegebenem Typ vor-
                                        handen
    <-  @146[module_typ]: BYTE          Typ-Code des geprÅften I/O-Moduls.

                                     @142[ Fortsetzung ]                   @001[ öbersicht ]
.142
    IO_check - PrÅfen eines I/O-Moduls (Fortsetzung)

    Mit dieser Funktion kann ÅberprÅft werden, ob das angegebene I/O-Modul
    vorhanden ist. Ist der Status der Funktion (Ausgang "status") ungleich 0,
    so ist das angegebene I/O-Modul nicht vorhanden.

    Jedes Modul der Systeme B&R 2010, B&R 2005 und B&R 2003 hat einen @146[Typ-Code],
    Åber den der Typ des Moduls eindeutig bestimmt werden kann.
    Mit dem Parameter "search_typ" kann definiert werden, welchen Typ
    (Typ-Code) das zu prÅfenden I/O-Modul haben mu·. Befindet sich an der mit
    "module_adr" festgelegten Moduladresse ein I/O-Modul, das nicht den ange-
    gebenen Typ hat, wird ein Fehler (Fehlernummer 5554) gemeldet.
    Am Ausgang "module_typ" wird der tatsÑchliche Typ-Code des zu prÅfenden
    I/O-Moduls ausgegeben.







                                     @143[ Fortsetzung ]                   @001[ öbersicht ]
.143
    IO_check - PrÅfen eines I/O-Moduls (Fortsetzung)

    Achtung!
    - Diese Funktion kann nur verwendet werden, wenn der Exceptionhandler
      EXERMO.BR (mindestens Version 1.11) auf der Zentraleinheit (Anwender-ROM)
      vorhanden ist!
    - Die Funktion IO_check() darf in superschnellen Taskklassen nicht ver-
      wendet werden (Ausnahme: Initialisierungs-Unterprogramme der super-
      schnellen Taskklassen).
    - Im System B&R 2005 kann die Funktion IO_check() nur fÅr die BasisrÅckwand
      verwendet werden. Bei den ErweiterungsrÅckwÑnden ist der Einsatz dieser
      Funktion nicht mîglich, da bei einem Fehler (I/O-Modul nicht vorhanden)
      die ganze ErweiterungsrÅckwand rÅckgesetzt werden mÅ·te. Ab der Version
      V1.60 der I/O-Library kann jedoch mit der Funktion IO_list() die im Hoch-
      lauf ermittelte I/O-Konfiguration von 2005-Erweiterungen festgestellt
      werden.





                                      @140[ IO_check ]                     @001[ öbersicht ]
.145
    IO_check - PrÅfen eines I/O-Moduls (Fortsetzung)

    <- Parameter <status    >: WORD

    Fehlernummern:
    5501     Falsche Parameter
    5551     IO_check() in mehreren Taskklassen parallel aufgerufen
    5553     IO_check() darf nicht in HS-Taskklassen aufgerufen werden
    5554     I/O-Modul gesteckt, aber Modultyp stimmt nicht
    5555     I/O-Modul nicht gesteckt
    5558     IO_check() darf am Parallelprozessor bzw. Multiprozessor nicht
             aufgerufen werden
    5563     IO_check() auf Systemen mit EX350 derzeit nicht mîglich
    5567     FUB-Daten liegen nicht im IO/Merker-Pool
    5576     Fehler beim 2003-Direkt-IO
    9136     IO-Fehler 2003

    Alle anderen Fehlernummern sind im Anhang @600[Fehlermeldungen] beschrieben.



                                      @140[ IO_check ]                     @001[ öbersicht ]
.146
    IO_check - PrÅfen eines I/O-Moduls (Fortsetzung)

    <- Parameter <module_typ >: BYTE

    Am Ausgang "module_typ" wird der tatsÑchliche Typ-Code des zu prÅfenden
    I/O-Moduls ausgegeben.
    Typ-Codes der wichtigsten I/O-Module (fÅr "search_typ" und "module_typ"):

    …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
    ∫    System B&R 2010   ∫    System B&R 2005   ∫    System B&R 2003   ∫
    «ƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ◊ƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ◊ƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ∂
    ∫ I/O-Modul ≥ Typ-Code ∫ I/O-Modul ≥ Typ-Code ∫ I/O-Modul ≥ Typ-Code ∫
    ÃÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕŒÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕŒÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕπ
    ∫   DI400   ≥   $01    ∫   DI475   ≥   $01    ∫   AI351   ≥ $02, $03 ∫
    ∫   DI401   ≥   $02    ∫   DO476   ≥   $02    ∫   AI354   ≥   $04    ∫
    ∫   DI425   ≥   $03    ∫   DO650   ≥   $03    ∫   AI774   ≥   $06    ∫
    ∫   DO426   ≥   $04    ∫   DO750   ≥   $04    ∫   AT351   ≥   $08    ∫
    ∫   DO600   ≥   $06    ∫   DI477   ≥   $05    ∫   AT662   ≥   $0A    ∫
    ∫   DO700   ≥   $07    ∫   DI450   ≥ $06, $08 ∫   AT664   ≥   $0C    ∫
    »ÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕº

                                     @147[ Fortsetzung ]                   @001[ öbersicht ]
.147
    IO_check - PrÅfen eines I/O-Moduls (Fortsetzung)

    …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
    ∫    System B&R 2010   ∫    System B&R 2005   ∫    System B&R 2003   ∫
    «ƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ◊ƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ◊ƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ∂
    ∫ I/O-Modul ≥ Typ-Code ∫ I/O-Modul ≥ Typ-Code ∫ I/O-Modul ≥ Typ-Code ∫
    ÃÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕŒÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕŒÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕπ
    ∫   AI300   ≥   $08    ∫   DI476   ≥   $07    ∫   AO352   ≥   $0E    ∫
    ∫   AI700   ≥   $09    ∫   DM455   ≥   $20    ∫   NC161   ≥   $10    ∫
    ∫   AT300   ≥   $0A    ∫   DO479   ≥   $40    ∫   DI135   ≥   $12    ∫
    ∫   AT400   ≥   $0B    ∫   DO480   ≥   $41    ∫   DO135   ≥   $14    ∫
    ∫   AT600   ≥   $0C    ∫   DI690   ≥   $60    ∫   AT352   ≥   $1A    ∫
    ∫   AT601   ≥   $0D    ∫   DO690   ≥   $61    ∫   AF451   ≥   $1E    ∫
    ∫   AT602   ≥   $0E    ∫   DM476   ≥   $62    ∫   AI261   ≥   $20    ∫
    ∫   AO725   ≥   $0F    ∫   AI375   ≥   $80    ∫   AI294   ≥   $22    ∫
    ∫   AO900   ≥   $10    ∫   AI775   ≥   $81    ∫   AF101   ≥   $C0    ∫
    ∫   AO300   ≥   $11    ∫   AI350   ≥   $82    ∫   CM471   ≥   $C1    ∫
    ∫   AM000   ≥   $12    ∫   AI350   ≥   $83    ∫   CM211   ≥   $C2    ∫
    ∫   AM001   ≥   $13    ∫   AM050   ≥   $88    ∫   CM411   ≥   $C3    ∫
    »ÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕº

                                     @148[ Fortsetzung ]                   @001[ öbersicht ]
.148
    IO_check - PrÅfen eines I/O-Moduls (Fortsetzung)

    …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
    ∫    System B&R 2010   ∫    System B&R 2005   ∫    System B&R 2003   ∫
    «ƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ◊ƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ◊ƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ∂
    ∫ I/O-Modul ≥ Typ-Code ∫ I/O-Modul ≥ Typ-Code ∫ I/O-Modul ≥ Typ-Code ∫
    ÃÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕŒÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕŒÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕπ
    ∫   NC300   ≥   $14    ∫   AM051   ≥   $89    ∫   DI435   ≥   $E1    ∫
    ∫   NC301   ≥   $15    ∫   AM374   ≥   $8A    ∫   DO720   ≥   $E2    ∫
    ∫   NC302   ≥   $16    ∫   AT650   ≥   $90    ∫   DM435   ≥   $E3    ∫
    ∫   NC303   ≥   $17    ∫   AT651   ≥   $91    ∫   DI645   ≥   $E5    ∫
    ∫   EX301   ≥   $18    ∫   AT450   ≥   $92    ∫   DO721   ≥   $E6    ∫
    ∫   EX302   ≥   $19    ∫   AT350   ≥   $93    ∫   DM438   ≥   $E7    ∫
    ∫   DS100   ≥   $1A    ∫   AT652   ≥   $94    ∫   DI439   ≥   $E9    ∫
    ∫   DS101   ≥   $1B    ∫   AT660   ≥   $95    ∫   DO435   ≥   $EB    ∫
    ∫   DS102   ≥   $1C    ∫   AI961   ≥   $96    ∫   DO722   ≥   $F2    ∫
    ∫   DO428   ≥   $1D    ∫   NC150   ≥   $98    ∫   DM465   ≥   $F7    ∫
    ∫   IP101   ≥   $1E    ∫   AO350   ≥   $A0    ∫           ≥          ∫
    ∫   DI825   ≥   $1F    ∫   AO775   ≥   $A1    ∫           ≥          ∫
    »ÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕº

                                     @149[ Fortsetzung ]                   @001[ öbersicht ]
.149
    IO_check - PrÅfen eines I/O-Moduls (Fortsetzung)

    …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
    ∫    System B&R 2010   ∫    System B&R 2005   ∫
    «ƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ◊ƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ∂
    ∫ I/O-Modul ≥ Typ-Code ∫ I/O-Modul ≥ Typ-Code ∫
    ÃÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕŒÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕπ
    ∫   DO430   ≥   $20    ∫   DO760   ≥   $B0    ∫
    ∫   UM900   ≥   $21    ∫   DI575   ≥   $B1    ∫
    ∫   DI426   ≥   $22    ∫   DI695   ≥   $B2    ∫
    ∫   NC102   ≥   $23    ∫           ≥          ∫
    ∫   AT610   ≥   $25    ∫           ≥          ∫
    ∫   DI725   ≥   $26    ∫           ≥          ∫
    ∫   DO710   ≥   $27    ∫           ≥          ∫
    ∫   AI730   ≥   $28    ∫           ≥          ∫
    »ÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕº





                                      @140[ IO_check ]                     @001[ öbersicht ]
.150
    IX_check - PrÅfen eines I/O-Moduls mit Subslots

    @151[IX_check] (enable,io_type,master_no,slave_no,module_adr,slot,search_typ,
              status,found_flag,module_typ)

    Parameter-Datentypen :
    ->  enable    : BIT           Der Funktionsblock wird nur ausgefÅhrt, wenn
                                  enable = 1 ist
    ->  io_type   : BYTE          I/O-Typ: 0 ... 2010-IO
                                           1 ... 2005-IO
                                           2 ... RIO-2010
                                           3 ... RIO-2005
                                           4 ... RIO-2003
                                           5 ... 2003-IO
    ->  master_no : BYTE          Logische Nummer des IO-Masters (derzeit
                                  immer 1) bzw. des RIO-Masters
    ->  slave_no  : BYTE          Nummer des RIO-Slaves bzw. der 2005-RÅckwand
                                  (0=BasisrÅckwand, 1=ErweiterungsrÅckwand 1,
                                  usw.). Bei 2010-IO und 2003-IO mu· fÅr
                                  slave_no immer der Wert 0 angegeben werden.

                                     @151[ Fortsetzung ]                   @001[ öbersicht ]
.151
    IX_check - PrÅfen eines I/O-Moduls mit Subslots (Fortsetzung)

    Parameter-Datentypen (Fortsetzung) :
    ->  module_adr: BYTE          Moduladresse des zu prÅfenden I/O-Moduls
                                  (in dezimaler Form)
    ->  slot      : BYTE          Steckplatz (Subslot) auf dem Modul:
                                  0 ..... Analog-Interfacemodul vorhanden?
                                  1-4 ... Submodul (auch Anpassungsmodul ge-
                                          nannt) auf dem angegebenen Steck-
                                          platz (1-4) vorhanden?
    ->  search_typ: BYTE          Typ (@156[Typ-Code]), den das I/O-Modul mit der
                                  angegebenen Moduladresse haben mu·. Steckt
                                  an dieser Moduladresse ein I/O-Modul, das
                                  nicht den definierten Typ hat, wird ein
                                  Fehler gemeldet. Wenn der Typ des I/O-Moduls
                                  nicht geprÅft werden soll (Typ egal), mu·
                                  fÅr search_typ der Wert 0 Åbergeben werden.
    <-  @155[status    ]: WORD          Fehlernummer (0 = kein Fehler)



                                     @152[ Fortsetzung ]                   @001[ öbersicht ]
.152
    IX_check - PrÅfen eines I/O-Moduls mit Subslots (Fortsetzung)

    Parameter-Datentypen (Fortsetzung) :
    <-  found_flag: BIT           Flag, das anzeigt, ob das I/O-Modul vor-
                                  handen ist:
                                  0 ... I/O-Modul mit angegebenem Typ nicht
                                        vorhanden
                                  1 ... I/O-Modul mit angegebenem Typ vor-
                                        handen
    <-  @156[module_typ]: BYTE          Typ-Code des geprÅften I/O-Moduls.

    Mit dieser Funktion kann ÅberprÅft werden, ob das angegebene I/O-Modul
    vorhanden ist. Ist der Status der Funktion (Ausgang "status") ungleich 0,
    so ist das angegebene I/O-Modul nicht vorhanden.
    Jedes Modul der Systeme B&R 2010, B&R 2005 und B&R 2003 hat einen @156[Typ-Code],
    Åber den der Typ des Moduls eindeutig bestimmt werden kann.
    Mit dem Parameter "search_typ" kann definiert werden, welchen Typ
    (Typ-Code) das zu prÅfenden I/O-Modul haben mu·. Befindet sich an der mit
    "module_adr" festgelegten Moduladresse ein I/O-Modul, das nicht den ange-
    gebenen Typ hat, wird ein Fehler (Fehlernummer 5554) gemeldet.

                                     @153[ Fortsetzung ]                   @001[ öbersicht ]
.153
    IX_check - PrÅfen eines I/O-Moduls mit Subslots (Fortsetzung)

    Am Ausgang "module_typ" wird der tatsÑchliche Typ-Code des zu prÅfenden
    I/O-Moduls ausgegeben.

    Achtung!
    - Diese Funktion kann nur verwendet werden, wenn der Exceptionhandler
      EXERMO.BR (mindestens Version 1.11) auf der Zentraleinheit (Anwender-ROM)
      vorhanden ist!
    - Auf CPUs des Systems B&R 2003 ist die Funktion IX_check() erst ab Version
      V2.00 der RPSSW lauffÑhig.
    - Die Funktion IX_check() darf in superschnellen Taskklassen nicht ver-
      wendet werden (Ausnahme: Initialisierungs-Unterprogramme der super-
      schnellen Taskklassen).
    - Im System B&R 2005 kann die Funktion IX_check() nur fÅr die BasisrÅckwand
      verwendet werden. Bei den ErweiterungsrÅckwÑnden ist der Einsatz dieser
      Funktion nicht mîglich, da bei einem Fehler (I/O-Modul nicht vorhanden)
      die ganze ErweiterungsrÅckwand rÅckgesetzt werden mÅ·te. Ab der Version
      V1.60 der I/O-Library kann jedoch mit der Funktion IO_list() die im Hoch-
      lauf ermittelte I/O-Konfiguration von 2005-Erweiterungen festgestellt
      werden.
                                      @150[ IX_check ]                     @001[ öbersicht ]
.155
    IX_check - PrÅfen eines I/O-Moduls mit Subslots (Fortsetzung)

    <- Parameter <status    >: WORD

    Fehlernummern:
    5501     Falsche Parameter
    5551     IX_check() in mehreren Taskklassen parallel aufgerufen
    5553     IX_check() darf nicht in HS-Taskklassen aufgerufen werden
    5554     I/O-Modul gesteckt, aber Modultyp stimmt nicht
    5555     I/O-Modul nicht gesteckt
    5558     IX_check() darf am Parallelprozessor bzw. Multiprozessor nicht
             aufgerufen werden
    5563     IX_check() auf Systemen mit EX350 derzeit nicht mîglich
    5567     FUB-Daten liegen nicht im IO/Merker-Pool
    5576     Fehler beim 2003-Direkt-IO
    9136     IO-Fehler 2003

    Alle anderen Fehlernummern sind im Anhang @600[Fehlermeldungen] beschrieben.



                                      @150[ IX_check ]                     @001[ öbersicht ]
.156
    IX_check - PrÅfen eines I/O-Moduls mit Subslots (Fortsetzung)

    <- Parameter <module_typ >: BYTE

    Am Ausgang "module_typ" wird der tatsÑchliche Typ-Code des zu prÅfenden
    I/O-Moduls ausgegeben.
    Typ-Codes der wichtigsten I/O-Module (fÅr "search_typ" und "module_typ"):

    …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
    ∫    System B&R 2010   ∫    System B&R 2005   ∫    System B&R 2003   ∫
    «ƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ◊ƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ◊ƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ∂
    ∫ I/O-Modul ≥ Typ-Code ∫ I/O-Modul ≥ Typ-Code ∫ I/O-Modul ≥ Typ-Code ∫
    ÃÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕŒÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕŒÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕπ
    ∫   DI400   ≥   $01    ∫   DI475   ≥   $01    ∫   AI351   ≥ $02, $03 ∫
    ∫   DI401   ≥   $02    ∫   DO476   ≥   $02    ∫   AI354   ≥   $04    ∫
    ∫   DI425   ≥   $03    ∫   DO650   ≥   $03    ∫   AI774   ≥   $06    ∫
    ∫   DO426   ≥   $04    ∫   DO750   ≥   $04    ∫   AT351   ≥   $08    ∫
    ∫   DO600   ≥   $06    ∫   DI477   ≥   $05    ∫   AT662   ≥   $0A    ∫
    ∫   DO700   ≥   $07    ∫   DI450   ≥ $06, $08 ∫   AT664   ≥   $0C    ∫
    »ÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕº

                                     @157[ Fortsetzung ]                   @001[ öbersicht ]
.157
    IX_check - PrÅfen eines I/O-Moduls mit Subslots (Fortsetzung)

    …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
    ∫    System B&R 2010   ∫    System B&R 2005   ∫    System B&R 2003   ∫
    «ƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ◊ƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ◊ƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ∂
    ∫ I/O-Modul ≥ Typ-Code ∫ I/O-Modul ≥ Typ-Code ∫ I/O-Modul ≥ Typ-Code ∫
    ÃÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕŒÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕŒÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕπ
    ∫   AI300   ≥   $08    ∫   DI476   ≥   $07    ∫   AO352   ≥   $0E    ∫
    ∫   AI700   ≥   $09    ∫   DM455   ≥   $20    ∫   NC161   ≥   $10    ∫
    ∫   AT300   ≥   $0A    ∫   DO479   ≥   $40    ∫   DI135   ≥   $12    ∫
    ∫   AT400   ≥   $0B    ∫   DO480   ≥   $41    ∫   DO135   ≥   $14    ∫
    ∫   AT600   ≥   $0C    ∫   DI690   ≥   $60    ∫   AT352   ≥   $1A    ∫
    ∫   AT601   ≥   $0D    ∫   DO690   ≥   $61    ∫   AF451   ≥   $1E    ∫
    ∫   AT602   ≥   $0E    ∫   DM476   ≥   $62    ∫   AI261   ≥   $20    ∫
    ∫   AO725   ≥   $0F    ∫   AI375   ≥   $80    ∫   AI294   ≥   $22    ∫
    ∫   AO900   ≥   $10    ∫   AI775   ≥   $81    ∫   AF101   ≥   $C0    ∫
    ∫   AO300   ≥   $11    ∫   AI350   ≥   $82    ∫   CM471   ≥   $C1    ∫
    ∫   AM000   ≥   $12    ∫   AI350   ≥   $83    ∫   CM211   ≥   $C2    ∫
    ∫   AM001   ≥   $13    ∫   AM050   ≥   $88    ∫   CM411   ≥   $C3    ∫
    »ÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕº

                                     @158[ Fortsetzung ]                   @001[ öbersicht ]
.158
    IX_check - PrÅfen eines I/O-Moduls mit Subslots (Fortsetzung)

    …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
    ∫    System B&R 2010   ∫    System B&R 2005   ∫    System B&R 2003   ∫
    «ƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ◊ƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ◊ƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ∂
    ∫ I/O-Modul ≥ Typ-Code ∫ I/O-Modul ≥ Typ-Code ∫ I/O-Modul ≥ Typ-Code ∫
    ÃÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕŒÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕŒÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕπ
    ∫   NC300   ≥   $14    ∫   AM051   ≥   $89    ∫   DI435   ≥   $E1    ∫
    ∫   NC301   ≥   $15    ∫   AM374   ≥   $8A    ∫   DO720   ≥   $E2    ∫
    ∫   NC302   ≥   $16    ∫   AT650   ≥   $90    ∫   DM435   ≥   $E3    ∫
    ∫   NC303   ≥   $17    ∫   AT651   ≥   $91    ∫   DI645   ≥   $E5    ∫
    ∫   EX301   ≥   $18    ∫   AT450   ≥   $92    ∫   DO721   ≥   $E6    ∫
    ∫   EX302   ≥   $19    ∫   AT350   ≥   $93    ∫   DM438   ≥   $E7    ∫
    ∫   DS100   ≥   $1A    ∫   AT652   ≥   $94    ∫   DI439   ≥   $E9    ∫
    ∫   DS101   ≥   $1B    ∫   AT660   ≥   $95    ∫   DO435   ≥   $EB    ∫
    ∫   DS102   ≥   $1C    ∫   AI961   ≥   $96    ∫   DO722   ≥   $F2    ∫
    ∫   DO428   ≥   $1D    ∫   NC150   ≥   $98    ∫   DM465   ≥   $F7    ∫
    ∫   IP101   ≥   $1E    ∫   AO350   ≥   $A0    ∫           ≥          ∫
    ∫   DI825   ≥   $1F    ∫   AO775   ≥   $A1    ∫           ≥          ∫
    »ÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕº

                                     @159[ Fortsetzung ]                   @001[ öbersicht ]
.159
    IX_check - PrÅfen eines I/O-Moduls mit Subslots (Fortsetzung)

    …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
    ∫    System B&R 2010   ∫    System B&R 2005   ∫
    «ƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ◊ƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ∂
    ∫ I/O-Modul ≥ Typ-Code ∫ I/O-Modul ≥ Typ-Code ∫
    ÃÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕŒÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕπ
    ∫   DO430   ≥   $20    ∫   DO760   ≥   $B0    ∫
    ∫   UM900   ≥   $21    ∫   DI575   ≥   $B1    ∫
    ∫   DI426   ≥   $22    ∫   DI695   ≥   $B2    ∫
    ∫   NC102   ≥   $23    ∫           ≥          ∫
    ∫   AT610   ≥   $25    ∫           ≥          ∫
    ∫   DI725   ≥   $26    ∫           ≥          ∫
    ∫   DO710   ≥   $27    ∫           ≥          ∫
    ∫   AI730   ≥   $28    ∫           ≥          ∫
    »ÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕº





                                      @150[ IX_check ]                     @001[ öbersicht ]
.160
    IO_alloc - Allokieren eines I/O-Datenbereichs

    @161[IO_alloc] (enable,bytesize,status,data_ptr)

    Parameter-Datentypen :
    ->  enable    : BIT           Der Funktionsblock wird nur ausgefÅhrt, wenn
                                  "enable" = 1 ist
    ->  bytesize  : WORD          Grî·e des I/O-Datenbereichs in Byte
    <-  @165[status    ]: WORD          Fehlernummer (0 = kein Fehler)
    <-  data_ptr  : LONG          Adresse des allokierten I/O-Datenbereichs

    Mit der Funktion IO_alloc() kann I/O-Speicher fÅr die Bearbeitung mit
    IO_mphydef() und IO_data() allokiert werden (speziell in Systemen mit
    EX350). Die Freigabe des allokierten Speichers kann mit der Funktion
    @170[IO_free()] erfolgen.






                                     @161[ Fortsetzung ]                   @001[ öbersicht ]
.161
    IO_alloc - Allokieren eines I/O-Datenbereichs (Fortsetzung)

    Beispiel: Allokieren eines I/O-Datenbereichs

      if sc_adr = 0 then
          ;* Allokieren des Speichers fÅr SC-Daten und IO-Daten
          IO_alloc(1,sc_len + io_len,status,sc_adr)
      endif

      if status = 0 then
          ...
          ;* IO-Daten liegen hinter dem SC-Bereich
          iop.data_adr = sc_adr + sc_len
          io_val access sc_adr + sc_len

          IO_mphydef(1,adr(iop),sc_adr,0,status,ioident)
          ...
          ;* Outputwert berechnen und auf IO-Modul ausgeben
          io_val = calc(x,y,z)
          IO_data(1,ioident,status)
      endif
                                      @160[ IO_alloc ]                     @001[ öbersicht ]
.165
    IO_alloc - Allokieren eines I/O-Datenbereichs (Fortsetzung)

    <- Parameter <status    >: WORD

    Fehlernummern:
    3611     Im analogen I/O-Bereich ist zuwenig Speicher verfÅgbar

    Alle anderen Fehlernummern sind im Anhang @600[Fehlermeldungen] beschrieben.













                                      @160[ IO_alloc ]                     @001[ öbersicht ]
.170
    IO_free - Freigabe eines I/O-Datenbereichs

    @170[IO_free] (enable,bytesize,data_ptr,status)

    Parameter-Datentypen :
    ->  enable    : BIT           Der Funktionsblock wird nur ausgefÅhrt, wenn
                                  "enable" = 1 ist
    ->  bytesize  : WORD          Grî·e des I/O-Datenbereichs in Byte
    ->  data_ptr  : LONG          Adresse des allokierten I/O-Datenbereichs
    <-  @175[status    ]: WORD          Fehlernummer (0 = kein Fehler)

    Diese Funktion deallokiert einen Speicherbereich, der mit IO_alloc()
    allokiert wurde.








                                                                     @001[ öbersicht ]
.175
    IO_free - Freigabe eines I/O-Datenbereichs (Fortsetzung)

    <- Parameter <status    >: WORD

    Fehlernummern:
    3711     UngÅltiger Parameter bei IO_free im analogen I/O-Bereich

    Alle anderen Fehlernummern sind im Anhang @600[Fehlermeldungen] beschrieben.













                                       @170[ IO_free ]                     @001[ öbersicht ]
.180
    IO_list - Liste aller gesteckten I/O-Module

    @181[IO_list] (enable,io_type,master_no,slave_no,prev_mod,adr(name_adr),
             status,module_adr,module_typ,io_bus)

    Parameter-Datentypen :
    ->  enable    : BIT           Der Funktionsblock wird nur ausgefÅhrt, wenn
                                  enable = 1 ist
    ->  io_type   : BYTE          I/O-Typ: 0 ... 2010-IO
                                           1 ... 2005-IO
                                           2 ... RIO-2010
                                           3 ... RIO-2005
                                           4 ... RIO-2003
                                           5 ... 2003-IO
    ->  master_no : BYTE          Logische Nummer des IO-Masters (derzeit
                                  immer 1) bzw. des RIO-Masters





                                     @181[ Fortsetzung ]                   @001[ öbersicht ]
.181
    IO_list - Liste aller gesteckten I/O-Module (Fortsetzung)

    Parameter-Datentypen (Fortsetzung) :
    ->  slave_no  : BYTE          Nummer des RIO-Slaves bzw. Nummer der 2005-
                                  RÅckwand (0=BasisrÅckwand, 1=Erweiterungs-
                                  rÅckwand 1, 2=ErweiterungsrÅckwand 2, usw.).
                                  Bei 2010-IO und 2003-IO mu· fÅr slave_no
                                  immer der Wert 0 angegeben werden.
    ->  prev_mod  : BYTE          Moduladresse des I/O-Moduls (in dezimaler
                                  Form), bei dem die Suche fortgesetzt wird
                                  (bei Angabe von 0 wird die Suche beim ersten
                                  I/O-Modul am Bus fortgesetzt)
    <-> @185[name_adr  ]: 6 BYTE (FELD) Name des I/O-Moduls
                                  (als nullterminierter String)
    <-  @186[status    ]: WORD          Fehlernummer (0 = kein Fehler)
    <-  module_adr: BYTE          Moduladresse des ersten gefundenen I/O-Moduls
                                  (in dezimaler Form)
    <-  @187[module_typ]: BYTE          Typ-Code des gefundenen I/O-Moduls
    <-  io_bus    : WORD          I/O-Bus-Parameter (Parameter io_bus) fÅr die
                                  Funktion IO_physdef()

                                     @182[ Fortsetzung ]                   @001[ öbersicht ]
.182
    IO_list - Liste aller gesteckten I/O-Module (Fortsetzung)

    Mit der Funktion IO_list() kann ein I/O-Bus (2010-IO, 2005-Basis-IO, 2005-
    Erweiterungen, 2003-IO, Remote-IO 2010, Remote-IO 2005, Remote-IO 2003)
    nach I/O-Modulen durchsucht werden. Als Ergebnis liefert diese Funktion
    Name, Moduladresse und Typ (@187[Typ-Code]) des gefundenen I/O-Moduls.
    Die Funktion IO_list() sucht das erste vorhandene Modul am I/O-Bus hinter
    der angegebenen Moduladresse "prev_mod" (allerdings nur Åber die im Hoch-
    lauf festgestellte Hardware-Konfigurationstabelle, nicht durch direkten
    physikalischen Zugriff).
    Um den ganzen I/O-Bus zu durchsuchen, mu· der Parameter "prev_mod" beim
    ersten Aufruf auf 0 gesetzt werden. Bei jedem weiteren Aufruf der Funktion
    mu· der Ausgangsparameter "module_adr" als neuer "prev_mod" verwendet
    werden. Mit "prev_mod" = i - 1 kann man jedoch auch von jeder beliebigen
    Moduladresse "i" aus die Suche beginnen. Wenn kein I/O-Modul mehr gefunden
    wird, wird am Ausgang "status" eine entsprechende Fehlernummer ausge-
    geben.




                                     @183[ Fortsetzung ]                   @001[ öbersicht ]
.183
    IO_list - Liste aller gesteckten I/O-Module (Fortsetzung)

    Achtung!
    - Diese Funktion kann nur verwendet werden, wenn der Exceptionhandler
      EXERMO.BR (mindestens Version 1.11) auf der Zentraleinheit (Anwender-ROM)
      vorhanden ist!
    - Um die LeistungsfÑhigkeit des Systems nicht zu beeintrÑchtigen, sollte
      die Funktion IO_list() nur in Initialisierungs-Unterprogrammen
      (INIT-UPs) der zyklischen Tasks verwendet werden. Damit trotzdem alle
      I/O-Module erfa·t werden, mu· die Funktion IO_list() im INIT-UP in einer
      "loop" Anweisung aufgerufen werden (siehe @730[Beispiel 4]).
    - Die Funktion IO_list() darf in superschnellen Taskklassen nicht verwendet
      werden (Ausnahme: INIT-UPs der superschnellen Taskklassen).
    - Um mit der Funktion IO_list() die korrekte Bezeichnung eines I/O-Moduls
      zu erhalten, mu· das entsprechende Datenmodul (IO_2010.BR fÅr 2010-IO,
      IO_2005.BR fÅr 2005-IO und IO_2003.BR fÅr 2003-IO) im Anwender-ROM der
      Zentraleinheit vorhanden sein.




                                       @180[ IO_list ]                     @001[ öbersicht ]
.185
    IO_list - Liste aller gesteckten I/O-Module (Fortsetzung)

    <-> Parameter <name_adr  >:  6 BYTE (FELD)

    In der Variable "name_adr" wird die Bezeichnung des gefundenen I/O-Moduls
    als String (5 Zeichen + Nullbyte) hinterlegt.
    Da in der Hardware-Konfigurationstabelle kein Modulname eingetragen ist,
    kînnen die korrekten Modulbezeichnungen nur Åber die mitgelieferten Daten-
    module IO_2010.BR, IO_2005.BR und IO_2003.BR bestimmt werden. D.h. wenn
    das entsprechende Datenmodul (IO_2010.BR fÅr 2010-IO, IO_2005.BR fÅr
    2005-IO und IO_2003.BR fÅr 2003-IO) nicht im Anwender-ROM der Zentral-
    einheit vorhanden ist, wird der String "?????" als Modulbezeichnung ein-
    getragen.








                                       @180[ IO_list ]                     @001[ öbersicht ]
.186
    IO_list - Liste aller gesteckten I/O-Module (Fortsetzung)

    <- Parameter <status    >: WORD

    Fehlernummern:
    5501     Falsche Parameter
    5551     IO_list() in mehreren Taskklassen parallel aufgerufen
    5553     IO_list() darf nicht in HS-Taskklassen aufgerufen werden
    5555     I/O-Modul nicht gesteckt
    5558     IO_list() darf am Parallelprozessor bzw. Multiprozessor nicht
             aufgerufen werden
    5576     Fehler beim 2003-Direkt-IO
    9136     IO-Fehler 2003

    Alle anderen Fehlernummern sind im Anhang @600[Fehlermeldungen] beschrieben.






                                       @180[ IO_list ]                     @001[ öbersicht ]
.187
    IO_list - Liste aller gesteckten I/O-Module (Fortsetzung)

    <- Parameter <module_typ >: BYTE

    Neben der Modulbezeichnung (Name des Moduls) liefert die Funktion IO_list()
    als Ergebnis auch den Typ-Code (Parameter "module_typ") des gefundenen
    I/O-Moduls. öber den Typ-Code kann jedes Modul der Systeme B&R 2010, 2005
    und 2003 eindeutig bestimmt werden. Typ-Codes der wichtigsten I/O-Module:
    …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
    ∫    System B&R 2010   ∫    System B&R 2005   ∫    System B&R 2003   ∫
    «ƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ◊ƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ◊ƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ∂
    ∫ I/O-Modul ≥ Typ-Code ∫ I/O-Modul ≥ Typ-Code ∫ I/O-Modul ≥ Typ-Code ∫
    ÃÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕŒÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕŒÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕπ
    ∫   DI400   ≥   $01    ∫   DI475   ≥   $01    ∫   AI351   ≥ $02, $03 ∫
    ∫   DI401   ≥   $02    ∫   DO476   ≥   $02    ∫   AI354   ≥   $04    ∫
    ∫   DI425   ≥   $03    ∫   DO650   ≥   $03    ∫   AI774   ≥   $06    ∫
    ∫   DO426   ≥   $04    ∫   DO750   ≥   $04    ∫   AT351   ≥   $08    ∫
    ∫   DO600   ≥   $06    ∫   DI477   ≥   $05    ∫   AT662   ≥   $0A    ∫
    ∫   DO700   ≥   $07    ∫   DI450   ≥ $06, $08 ∫   AT664   ≥   $0C    ∫
    »ÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕº

                                     @188[ Fortsetzung ]                   @001[ öbersicht ]
.188
    IO_list - Liste aller gesteckten I/O-Module (Fortsetzung)

    …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
    ∫    System B&R 2010   ∫    System B&R 2005   ∫    System B&R 2003   ∫
    «ƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ◊ƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ◊ƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ∂
    ∫ I/O-Modul ≥ Typ-Code ∫ I/O-Modul ≥ Typ-Code ∫ I/O-Modul ≥ Typ-Code ∫
    ÃÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕŒÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕŒÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕπ
    ∫   AI300   ≥   $08    ∫   DI476   ≥   $07    ∫   AO352   ≥   $0E    ∫
    ∫   AI700   ≥   $09    ∫   DM455   ≥   $20    ∫   NC161   ≥   $10    ∫
    ∫   AT300   ≥   $0A    ∫   DO479   ≥   $40    ∫   DI135   ≥   $12    ∫
    ∫   AT400   ≥   $0B    ∫   DO480   ≥   $41    ∫   DO135   ≥   $14    ∫
    ∫   AT600   ≥   $0C    ∫   DI690   ≥   $60    ∫   AT352   ≥   $1A    ∫
    ∫   AT601   ≥   $0D    ∫   DO690   ≥   $61    ∫   AF451   ≥   $1E    ∫
    ∫   AT602   ≥   $0E    ∫   DM476   ≥   $62    ∫   AI261   ≥   $20    ∫
    ∫   AO725   ≥   $0F    ∫   AI375   ≥   $80    ∫   AI294   ≥   $22    ∫
    ∫   AO900   ≥   $10    ∫   AI775   ≥   $81    ∫   AF101   ≥   $C0    ∫
    ∫   AO300   ≥   $11    ∫   AI350   ≥   $82    ∫   CM471   ≥   $C1    ∫
    ∫   AM000   ≥   $12    ∫   AI350   ≥   $83    ∫   CM211   ≥   $C2    ∫
    ∫   AM001   ≥   $13    ∫   AM050   ≥   $88    ∫   CM411   ≥   $C3    ∫
    »ÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕº

                                     @189[ Fortsetzung ]                   @001[ öbersicht ]
.189
    IO_list - Liste aller gesteckten I/O-Module (Fortsetzung)

    …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
    ∫    System B&R 2010   ∫    System B&R 2005   ∫    System B&R 2003   ∫
    «ƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ◊ƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ◊ƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ∂
    ∫ I/O-Modul ≥ Typ-Code ∫ I/O-Modul ≥ Typ-Code ∫ I/O-Modul ≥ Typ-Code ∫
    ÃÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕŒÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕŒÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕπ
    ∫   NC300   ≥   $14    ∫   AM051   ≥   $89    ∫   DI435   ≥   $E1    ∫
    ∫   NC301   ≥   $15    ∫   AM374   ≥   $8A    ∫   DO720   ≥   $E2    ∫
    ∫   NC302   ≥   $16    ∫   AT650   ≥   $90    ∫   DM435   ≥   $E3    ∫
    ∫   NC303   ≥   $17    ∫   AT651   ≥   $91    ∫   DI645   ≥   $E5    ∫
    ∫   EX301   ≥   $18    ∫   AT450   ≥   $92    ∫   DO721   ≥   $E6    ∫
    ∫   EX302   ≥   $19    ∫   AT350   ≥   $93    ∫   DM438   ≥   $E7    ∫
    ∫   DS100   ≥   $1A    ∫   AT652   ≥   $94    ∫   DI439   ≥   $E9    ∫
    ∫   DS101   ≥   $1B    ∫   AT660   ≥   $95    ∫   DO435   ≥   $EB    ∫
    ∫   DS102   ≥   $1C    ∫   AI961   ≥   $96    ∫   DO722   ≥   $F2    ∫
    ∫   DO428   ≥   $1D    ∫   NC150   ≥   $98    ∫   DM465   ≥   $F7    ∫
    ∫   IP101   ≥   $1E    ∫   AO350   ≥   $A0    ∫           ≥          ∫
    ∫   DI825   ≥   $1F    ∫   AO775   ≥   $A1    ∫           ≥          ∫
    »ÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕº

                                     @190[ Fortsetzung ]                   @001[ öbersicht ]
.190
    IO_list - Liste aller gesteckten I/O-Module (Fortsetzung)

    …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
    ∫    System B&R 2010   ∫    System B&R 2005   ∫
    «ƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ◊ƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ∂
    ∫ I/O-Modul ≥ Typ-Code ∫ I/O-Modul ≥ Typ-Code ∫
    ÃÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕŒÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕπ
    ∫   DO430   ≥   $20    ∫   DO760   ≥   $B0    ∫
    ∫   UM900   ≥   $21    ∫   DI575   ≥   $B1    ∫
    ∫   DI426   ≥   $22    ∫   DI695   ≥   $B2    ∫
    ∫   NC102   ≥   $23    ∫           ≥          ∫
    ∫   AT610   ≥   $25    ∫           ≥          ∫
    ∫   DI725   ≥   $26    ∫           ≥          ∫
    ∫   DO710   ≥   $27    ∫           ≥          ∫
    ∫   AI730   ≥   $28    ∫           ≥          ∫
    »ÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕº





                                       @180[ IO_list ]                     @001[ öbersicht ]
.200
    IO_slist - Liste aller gesteckten Submodule

    @201[IO_slist] (enable,io_type,master_no,slave_no,module_adr,prev_slot,
              adr(name_adr),status,slot_no,slot_typ)

    Parameter-Datentypen :
    ->  enable    : BIT           Der Funktionsblock wird nur ausgefÅhrt, wenn
                                  enable = 1 ist
    ->  io_type   : BYTE          I/O-Typ: 4 ... RIO-2003
                                           5 ... 2003-IO
    ->  master_no : BYTE          Logische Nummer des IO-Masters (derzeit
                                  immer 1) bzw. des RIO-Masters
    ->  slave_no  : BYTE          Nummer des RIO-Slaves (bei RIO-2003). Bei
                                  2003-IO mu· fÅr slave_no immer der Wert 0
                                  angegeben werden.
    ->  module_adr: BYTE          Moduladresse des Analog-Interfacemoduls
                                  (in dezimaler Form).
                                  Dieses Analog-Interfacemodul wird nach Sub-
                                  modulen (auch Anpassungsmodule genannt)
                                  durchsucht.

                                     @201[ Fortsetzung ]                   @001[ öbersicht ]
.201
    IO_slist - Liste aller gesteckten Submodule (Fortsetzung)

    Parameter-Datentypen (Fortsetzung) :
    ->  prev_slot : BYTE          Steckplatz (in dezimaler Form) des Submoduls
                                  (auch Anpassungsmodul genannt), bei dem die
                                  Suche fortgesetzt wird (bei Angabe von 0 wird
                                  die Suche beim ersten Anpassungsmodul fort-
                                  gesetzt)
    <-> @205[name_adr  ]: 6 BYTE (FELD) Name des Anpassungsmoduls
                                  (als nullterminierter String)
    <-  @206[status    ]: WORD          Fehlernummer (0 = kein Fehler)
    <-  slot_no   : BYTE          Steckplatz des ersten gefundenen Anpassungs-
                                  moduls (in dezimaler Form)
    <-  @207[slot_typ  ]: BYTE          Typ-Code des gefundenen Anpassungsmoduls

    Mit der Funktion IO_slist() kînnen die auf einem Analog-Interfacemodul
    (System B&R 2003) vorhandenen Submodule (auch Anpassungsmodule genannt)
    analysiert werden (2003-IO, RIO-2003).



                                     @202[ Fortsetzung ]                   @001[ öbersicht ]
.202
    IO_slist - Liste aller gesteckten Submodule (Fortsetzung)

    Die Funktion IO_slist() sucht das erste vorhandene Submodul hinter dem
    angegebenen Steckplatz "prev_slot" (allerdings nur Åber die im Hoch-
    lauf festgestellte Hardware-Konfigurationstabelle, nicht durch direkten
    physikalischen Zugriff).
    Um alle (auf einem Analog-Interfacemodul) vorhandenen Anpassungsmodule
    zu analysieren, mu· der Parameter "prev_slot" beim ersten Aufruf auf 0
    gesetzt werden. Bei jedem weiteren Aufruf der Funktion mu· der Ausgangs-
    parameter "slot_no" als neuer "prev_slot" verwendet werden.
    Mit "prev_slot" = i - 1 kann man jedoch auch von jedem beliebigen Steck-
    platz "i" aus die Suche beginnen. Wenn kein Anpassungsmodul mehr gefunden
    wird, wird am Ausgang "status" eine entsprechende Fehlernummer ausge-
    geben.







                                     @203[ Fortsetzung ]                   @001[ öbersicht ]
.203
    IO_slist - Liste aller gesteckten Submodule (Fortsetzung)

    Achtung!
    - Um die LeistungsfÑhigkeit des Systems nicht zu beeintrÑchtigen, sollte
      die Funktion IO_slist() nur in Initialisierungs-Unterprogrammen
      (INIT-UPs) der zyklischen Tasks verwendet werden.
    - Um mit der Funktion IO_slist() die korrekten Bezeichnungen der Submodule
      zu erhalten, mu· das Datenmodul IO_2003.BR im Anwender-ROM der Zentral-
      einheit vorhanden sein.












                                      @200[ IO_slist ]                     @001[ öbersicht ]
.205
    IO_slist - Liste aller gesteckten Submodule (Fortsetzung)

    <-> Parameter <name_adr  >:  6 BYTE (FELD)

    In der Variable "name_adr" wird die Bezeichnung des gefundenen Anpassungs-
    moduls als String (5 Zeichen + Nullbyte) hinterlegt.
    Da in der Hardware-Konfigurationstabelle kein Modulname eingetragen ist,
    kann die korrekte Modulbezeichnung nur Åber das mitgelieferten Daten-
    modul IO_2003.BR bestimmt werden. D.h. wenn das Datenmodul IO_2003.BR
    nicht im Anwender-ROM der Zentraleinheit vorhanden ist, wird der String
    "?????" als Modulbezeichnung eingetragen.










                                      @200[ IO_slist ]                     @001[ öbersicht ]
.206
    IO_slist - Liste aller gesteckten Submodule (Fortsetzung)

    <- Parameter <status    >: WORD

    Fehlernummern:
    5501     Falsche Parameter
    5555     Anpassungsmodul (Submodul) nicht gesteckt
    5576     Fehler beim 2003-Direkt-IO
    9136     IO-Fehler 2003

    Alle anderen Fehlernummern sind im Anhang @600[Fehlermeldungen] beschrieben.










                                      @200[ IO_slist ]                     @001[ öbersicht ]
.207
    IO_slist - Liste aller gesteckten Submodule (Fortsetzung)

    <- Parameter <slot_typ  >: BYTE

    Dieser Parameter enthÑlt den Typ-Code des gefundenen Anpassungsmoduls.

    …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕª
    ∫ Anpassungsmodul ≥ Typ-Code ∫
    ÃÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕπ
    ∫      AI351      ≥ $02, $03 ∫
    ∫      AI354      ≥   $04    ∫
    ∫      AI774      ≥   $06    ∫
    ∫      AT351      ≥   $08    ∫
    ∫      AT662      ≥   $0A    ∫
    ∫      AT664      ≥   $0C    ∫
    ∫      AO352      ≥   $0E    ∫
    ∫      NC161      ≥   $10    ∫
    ∫      DI135      ≥   $12    ∫
    ∫      DO135      ≥   $14    ∫
    »ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕº

                                     @208[ Fortsetzung ]                   @001[ öbersicht ]
.208
    IO_slist - Liste aller gesteckten Submodule (Fortsetzung)

    …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕª
    ∫ Anpassungsmodul ≥ Typ-Code ∫
    ÃÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕπ
    ∫      AT352      ≥   $1A    ∫
    ∫      AI261      ≥   $20    ∫
    »ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕº













                                      @200[ IO_slist ]                     @001[ öbersicht ]
.210
    SYS_list - Liste aller gesteckten Systemmodule

    @211[SYS_list] (enable,prev_mod,adr(name_adr),status,module_adr,module_typ)

    Parameter-Datentypen :
    ->  enable    : BIT           Der Funktionsblock wird nur ausgefÅhrt, wenn
                                  enable = 1 ist
    ->  prev_mod  : BYTE          Moduladresse des Systemmoduls (in dezimaler
                                  Form), bei dem die Suche fortgesetzt wird
                                  0 ..... Suche beim ersten Systemmodul
                                          fortsetzen
                                  255 ... Information zur aktuellen CPU
                                          holen
    <-> @215[name_adr  ]: 6 BYTE (FELD) Name des Systemmoduls
                                  (als nullterminierter String)
    <-  @216[status    ]: WORD          Fehlernummer (0 = kein Fehler)
    <-  module_adr: BYTE          Moduladresse des ersten gefundenen System-
                                  moduls (in dezimaler Form)
    <-  @217[module_typ]: BYTE          Typ-Code des gefundenen Systemmoduls


                                     @211[ Fortsetzung ]                   @001[ öbersicht ]
.211
    SYS_list - Liste aller gesteckten Systemmodule (Fortsetzung)

    Mit der Funktion SYS_list() kînnen alle Systemmodule am Bus analysiert
    werden, wobei immer das Systemmodul mit der nÑchsthîheren Moduladresse
    im Vergleich zur angegebenen Moduladresse (Parameter "prev_mod") gesucht
    wird.
    Um den ganzen Bus zu durchsuchen, mu· der Parameter "prev_mod" beim
    ersten Aufruf auf 0 gesetzt werden. Bei jedem weiteren Aufruf der Funktion
    mu· der Ausgangsparameter "module_adr" als neuer "prev_mod" verwendet
    werden.
    Mit "prev_mod" = i - 1 kann man jedoch auch von jeder beliebigen Modul-
    adresse "i" aus die Suche beginnen. Wenn kein Systemmodul mehr gefunden
    wird, wird am Ausgang "status" eine entsprechende Fehlernummer ausge-
    geben.
    Mit "prev_mod" = 255 kann der Typ und der Name der aktuellen CPU ermittelt
    werden, die Moduladresse ist dabei immer 0. Der Name der aktuellen CPU
    wird allerdings erst ab BUGFIX 11 der Betriebssystem-Version 1.10
    (B&R-Modul BUGFIX.BR mit der Versionsnummer 1.21) unterstÅtzt. Bei Ñlteren
    BUGFIX-Versionen wird an Stelle des Namens der String "?????" zurÅck-
    geliefert.

                                     @212[ Fortsetzung ]                   @001[ öbersicht ]
.212
    SYS_list - Liste aller gesteckten Systemmodule (Fortsetzung)

    Achtung!
    - Um die LeistungsfÑhigkeit des Systems nicht zu beeintrÑchtigen, sollte
      die Funktion SYS_list() nur in Initialisierungs-Unterprogrammen
      (INIT-UPs) der zyklischen Tasks verwendet werden. Damit trotzdem alle
      Systemmodule erfa·t werden, mu· die Funktion SYS_list() im INIT-UP in
      einer "loop" Anweisung aufgerufen werden. Siehe Beispiel zur Funktion
      IO_list (@730[Beispiel 4]).
    - Bei Angabe des Werts 255 fÅr den Parameter "prev_mod" wird erst ab
      BUGFIX 11 der Betriebssystem-Version 1.10 (B&R-Modul BUGFIX.BR mit der
      Versionsnummer 1.21) der korrekte Name der aktuellen CPU in der Variable
      "name_adr" hinterlegt. Bei Ñlteren BUGFIX-Versionen wird an Stelle des
      Namens der String "?????" zurÅckgeliefert.







                                      @210[ SYS_list ]                     @001[ öbersicht ]
.215
    SYS_list - Liste aller gesteckten Systemmodule (Fortsetzung)

    <-> Parameter <name_adr  >:  6 BYTE (FELD)

    In der Variable "name_adr" wird die Bezeichnung des gefundenen Systemmoduls
    als String (5 Zeichen + Nullbyte) hinterlegt.















                                      @210[ SYS_list ]                     @001[ öbersicht ]
.216
    SYS_list - Liste aller gesteckten Systemmodule (Fortsetzung)

    <- Parameter <status    >: WORD

    Fehlernummern:
    5555     Kein Systemmodul mehr gefunden

    Alle anderen Fehlernummern sind im Anhang @600[Fehlermeldungen] beschrieben.













                                      @210[ SYS_list ]                     @001[ öbersicht ]
.217
    SYS_list - Liste aller gesteckten Systemmodule (Fortsetzung)

    <- Parameter <module_typ >: BYTE

    Neben der Modulbezeichnung (Name des Systemmoduls) liefert die Funktion
    SYS_list() als Ergebnis auch den Typ-Code (Parameter "module_typ") des
    gefundenen Systemmoduls. Typ-Codes der wichtigsten Systemmodule:

    …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
    ∫ Systemmodul        ≥ Typ-Code ≥ System            ∫
    ÃÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ
    ∫ ME010              ≥   $00    ≥ B&R 2003          ∫
    ∫ EX100/EX150        ≥   $01    ≥ B&R 2010/B&R 2005 ∫
    ∫ EX350              ≥   $02    ≥ B&R 2005          ∫
    ∫ ME020              ≥   $02    ≥ B&R 2003          ∫
    ∫ EX101              ≥   $03    ≥ B&R Panel-CPU     ∫
    ∫ LS191              ≥   $03    ≥ B&R PC            ∫
    ∫ NW100/NW150        ≥   $10    ≥ B&R 2010/B&R 2005 ∫
    ∫ XP152              ≥   $11    ≥ B&R 2005          ∫
    »ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº

                                     @218[ Fortsetzung ]                   @001[ öbersicht ]
.218
    SYS_list - Liste aller gesteckten Systemmodule (Fortsetzung)

    …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
    ∫ Systemmodul        ≥ Typ-Code ≥ System            ∫
    ÃÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ
    ∫ CP100/CP104        ≥   $20    ≥ B&R 2010          ∫
    ∫ CP152/CP153        ≥   $21    ≥ B&R 2005          ∫
    ∫ IF152              ≥   $22    ≥ B&R 2005          ∫
    ∫ IP151              ≥   $23    ≥ B&R 2005          ∫
    ∫ CP472              ≥   $24    ≥ B&R 2003          ∫
    ∫ CP470              ≥   $25    ≥ B&R 2003          ∫
    ∫ CP474              ≥   $26    ≥ B&R 2003          ∫
    ∫ CP260              ≥   $27    ≥ B&R 2005          ∫
    ∫ IF260              ≥   $2A    ≥ B&R 2005          ∫
    ∫ LS251              ≥   $2B    ≥ B&R PC            ∫
    ∫ MP100              ≥   $2D    ≥ B&R 2010          ∫
    ∫ IF100/IF101        ≥   $2E    ≥ B&R 2010          ∫
    ∫ CP772              ≥   $30    ≥ B&R 2003          ∫
    ∫ CP770              ≥   $31    ≥ B&R 2003          ∫
    »ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº

                                     @219[ Fortsetzung ]                   @001[ öbersicht ]
.219
    SYS_list - Liste aller gesteckten Systemmodule (Fortsetzung)

    …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
    ∫ Systemmodul        ≥ Typ-Code ≥ System            ∫
    ÃÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ
    ∫ CP774              ≥   $32    ≥ B&R 2003          ∫
    ∫ AC701              ≥   $33    ≥ B&R 2003          ∫
    ∫ IP161              ≥   $34    ≥ B&R 2005          ∫
    ∫ IP350              ≥   $35    ≥ B&R 2005          ∫
    ∫ IP152              ≥   $36    ≥ B&R 2005          ∫
    ∫ CP430              ≥   $38    ≥ B&R 2003          ∫
    ∫ CP476              ≥   $39    ≥ B&R 2003          ∫
    ∫ HIC3               ≥   $3A    ≥ B&R Panel-CPU     ∫
    ∫ CP200              ≥   $50    ≥ B&R 2010          ∫
    ∫ CP210              ≥   $51    ≥ B&R 2010          ∫
    ∫ IF050              ≥   $60    ≥ B&R 2005          ∫
    ∫ NC154              ≥   $61    ≥ B&R 2005          ∫
    ∫ EM150              ≥   $62    ≥ B&R 2005          ∫
    ∫ IF060              ≥   $63    ≥ B&R 2005          ∫
    ∫ NC156              ≥   $64    ≥ B&R 2005          ∫
    »ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº
                                     @220[ Fortsetzung ]                   @001[ öbersicht ]
.220
    SYS_list - Liste aller gesteckten Systemmodule (Fortsetzung)

    …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
    ∫ Systemmodul        ≥ Typ-Code ≥ System            ∫
    ÃÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ
    ∫ NC158              ≥   $65    ≥ B&R 2005          ∫
    ∫ NC157              ≥   $66    ≥ B&R 2005          ∫
    ∫ EX450/LS050-26     ≥   $96    ≥ B&R 2005 / PCI    ∫
    ∫ ME050-26           ≥   $96    ≥ B&R 2003          ∫
    ∫ EX450/LS050-66-2   ≥   $9B    ≥ B&R 2005 / PCI    ∫
    ∫ ME050-66-2         ≥   $9B    ≥ B&R 2003          ∫
    ∫ EX450/LS050-66     ≥   $A6    ≥ B&R 2005 / PCI    ∫
    ∫ ME050-66           ≥   $A6    ≥ B&R 2003          ∫
    ∫ EX450/LS050-78     ≥   $A7    ≥ B&R 2005 / PCI    ∫
    ∫ ME050-78           ≥   $A7    ≥ B&R 2003          ∫
    ∫ EX450/LS050-76     ≥   $A8    ≥ B&R 2005 / PCI    ∫
    ∫ ME050-76           ≥   $A8    ≥ B&R 2003          ∫
    ∫ EX450/LS050-77     ≥   $A9    ≥ B&R 2005 / PCI    ∫
    ∫ ME050-77           ≥   $A9    ≥ B&R 2003          ∫
    »ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº

                                     @221[ Fortsetzung ]                   @001[ öbersicht ]
.221
    SYS_list - Liste aller gesteckten Systemmodule (Fortsetzung)

    …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
    ∫ Systemmodul        ≥ Typ-Code ≥ System            ∫
    ÃÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ
    ∫ EX450/LS050-21     ≥   $AB    ≥ B&R 2005 / PCI    ∫
    ∫ ME050-21           ≥   $AB    ≥ B&R 2003          ∫
    ∫ EX450/LS050-71     ≥   $AC    ≥ B&R 2005 / PCI    ∫
    ∫ ME050-71           ≥   $AC    ≥ B&R 2003          ∫
    ∫ EX450/LS050-41     ≥   $AD    ≥ B&R 2005 / PCI    ∫
    ∫ ME050-41           ≥   $AD    ≥ B&R 2003          ∫
    ∫ EX450/LS050-72     ≥   $AE    ≥ B&R 2005 / PCI    ∫
    ∫ ME050-72           ≥   $AE    ≥ B&R 2003          ∫
    »ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº







                                      @210[ SYS_list ]                     @001[ öbersicht ]
.230
    HW_list - Liste aller Hardware-Module erstellen

    @231[HW_list] (enable,first,adr(name_adr),status,hw_type,module_typ,master_no,
             slave_no,module_adr,slot_no)

    Parameter-Datentypen :
    ->  enable    : BIT           Der Funktionsblock wird nur ausgefÅhrt, wenn
                                  enable = 1 ist
    ->  first     : BIT           1 ... Bestimmen des ersten Hardware-Moduls
                                  0 ... Bestimmen des nÑchsten Hardware-Moduls
    <-> @235[name_adr  ]: 6 BYTE (FELD) Name des Moduls
                                  (als nullterminierter String)
    <-  @236[status    ]: WORD          Fehlernummer (0 = kein Fehler).
    <-  @237[hw_type   ]: BYTE          Hardware-Typ
    <-  @238[module_typ]: BYTE          Typ-Code des Moduls






                                     @231[ Fortsetzung ]                   @001[ öbersicht ]
.231
    HW_list - Liste aller Hardware-Module erstellen (Fortsetzung)

    Parameter-Datentypen (Fortsetzung) :
    <-  master_no : BYTE          Logische Nummer des IO-Masters, des RIO-
                                  Masters bzw. des CAN-Busses bei CANIO
                                  (1, 2, usw.):
                                  1 ..... bei 2010-IO, 2005-IO und 2003-IO
                                          inkl. Submodule (Anpassungsmodule)
                                  $FF ... $FF = UNDEFINED, bei SPS-CPU, PPs,
                                          Systemmodulen (au·er EX100/EX150),
                                          Submodulen in Systemmodulen
    <-  slave_no  : BYTE          Nummer der 2005-RÅckwand (0=BasisrÅckwand,
                                  1=ErweiterungsrÅckwand 1, usw.), Nummer
                                  des RIO-Slaves (bei Remote I/O), bzw. CAN-
                                  Knotennummer (bei CANIO):
                                  0 ..... bei 2010-IO und 2003-IO inkl.
                                          Submodule (Anpassungsmodule)
                                  $FF ... $FF = UNDEFINED, bei SPS-CPU,
                                          Parallelprozessoren, Systemmodulen,
                                          Submodulen in Systemmodulen

                                     @232[ Fortsetzung ]                   @001[ öbersicht ]
.232
    HW_list - Liste aller Hardware-Module erstellen (Fortsetzung)

    Parameter-Datentypen (Fortsetzung) :

    <-  module_adr: BYTE          Moduladresse des Hardware-Moduls in dezimaler
                                  Form
    <-  slot_no   : BYTE          Steckplatz des Submoduls (Einschubmodul oder
                                  Anpassungsmodul) in dezimaler Form

    Mit dem FUB HW_list() kînnen alle Hardware-Module, die vom aktuellen
    Prozessor aus "sichtbar" und damit in der Hardware-Konfigurationstabelle
    eingetragen sind, abgefragt werden. Diese Liste wird auch vom Automation
    Studio verwendet. Damit steht ein zentraler Funktionsblock fÅr das Fest-
    stellen der Hardware-Konfiguration zur VerfÅgung.

    Mit "first" = 1 kann das erste Hardware-Modul in der Liste bestimmt werden.
    Bei allen weiteren Aufrufen von HW_list() bis zum Ende der Liste mu·
    "first" = 0 gesetzt werden.



                                     @233[ Fortsetzung ]                   @001[ öbersicht ]
.233
    HW_list - Liste aller Hardware-Module erstellen (Fortsetzung)

    AbhÑngig vom Hardware-Typ stehen verschiedene Modulparameter zur VerfÅgung:
    Bei 2005-IO die Nummer der 2005-RÅckwand, bei Remote I/O die Master-Nummer
    und die Slave-Nummer, bei CANIO die Busnummer und die CAN-Knotennummer.
    ZusÑtzlich wird immer die Moduladresse sowie der Typ-Code des Moduls
    ermittelt. Der Typ-Code ist allerdings in einigen FÑllen nicht eindeutig
    (CP100/CP104, CP152/CP153, IF100/IF101, EX100/EX150, NW100/NW150).
    Eindeutig ist jedoch der Name des Hardware-Moduls, der optional mit Hilfe
    der Datenmodule IO_2010.BR, IO_2005.BR, IO_2003.BR, IO_PC.BR und IO_PW.BR
    bestimmt werden kann. In diesen Datenmodulen sind die Namen aller Module
    der jeweiligen Systemfamilie enthalten, also I/O-Module und Systemmodule
    (inkl. Submodule). Bei Verwendung von gemischten Systemen (z.B. 2005-CPU
    mit CANIO-2003, LS251 mit RIO-2010 oder RIO-2005) mÅssen alle benîtigten
    Datenmodule im nullspannungssicheren Speicher der Zentraleinheit vorhanden
    sein.

    Achtung!
    Da die Bestimmung des Namens relativ viel Zeit kostet, kann sie durch
    öbergabe des Werts 0 fÅr "adr(name_adr)" (Zeiger auf die Adresse 0)
    deaktiviert werden!
                                       @230[ HW_list ]                     @001[ öbersicht ]
.235
    HW_list - Liste aller Hardware-Module erstellen (Fortsetzung)

    <-> Parameter <name_adr  >:  6 BYTE (FELD)

    In der Variable "name_adr" wird die Bezeichnung des Hardware-Moduls als
    String (5 Zeichen + Nullbyte) hinterlegt.
    Da in der Hardware-Konfigurationstabelle kein Modulname eingetragen ist,
    kînnen die korrekten Modulbezeichnungen nur Åber die mitgelieferten Daten-
    module IO_2010.BR, IO_2005.BR, IO_2003.BR, IO_PC.BR und IO_PW.BR bestimmt
    werden. D.h. wenn das entsprechende Datenmodul nicht im nullspannungs-
    sicheren Speicher der Zentraleinheit vorhanden ist, wird der String "?????"
    als Modulbezeichnung eingetragen.









                                       @230[ HW_list ]                     @001[ öbersicht ]
.236
    HW_list - Liste aller Hardware-Module erstellen (Fortsetzung)

    <- Parameter <status    >: WORD

    Fehlernummern:
    5555     Kein Systemmodul mehr gefunden
    5566     Kennung der Hardware-Konfiguration wird nicht unterstÅtzt

    Alle anderen Fehlernummern sind im Anhang @600[Fehlermeldungen] beschrieben.












                                       @230[ HW_list ]                     @001[ öbersicht ]
.237
    HW_list - Liste aller Hardware-Module erstellen (Fortsetzung)

    <- Parameter <hw_type   >: BYTE

    Hardware-Typ:
    0 .... 2010-IO
    1 .... 2005-IO
    2 .... RIO-2010
    3 .... RIO-2005
    4 .... RIO-2003
    5 .... 2003-IO
    6 .... 2003-CANIO
    7 .... SPS-CPU
    8 .... PP-Systemmodul
    9 .... anderes Systemmodul
    10 ... Submodul (Einschubmodul oder Anpassungsmodul), das auf einer CPU,
           auf einem PP oder auf einem Systemmodul betrieben wird.




                                       @230[ HW_list ]                     @001[ öbersicht ]
.238
    HW_list - Liste aller Hardware-Module erstellen (Fortsetzung)

    <- Parameter <module_typ >: BYTE

    Neben der Modulbezeichnung liefert die Funktion HW_list() als Ergebnis
    auch den Typ-Code des Hardware-Moduls.

    Typ-Codes der wichtigsten I/O-Module:
    …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
    ∫    System B&R 2010   ∫    System B&R 2005   ∫    System B&R 2003   ∫
    «ƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ◊ƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ◊ƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ∂
    ∫ I/O-Modul ≥ Typ-Code ∫ I/O-Modul ≥ Typ-Code ∫ I/O-Modul ≥ Typ-Code ∫
    ÃÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕŒÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕŒÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕπ
    ∫   DI400   ≥   $01    ∫   DI475   ≥   $01    ∫   AI351   ≥ $02, $03 ∫
    ∫   DI401   ≥   $02    ∫   DO476   ≥   $02    ∫   AI354   ≥   $04    ∫
    ∫   DI425   ≥   $03    ∫   DO650   ≥   $03    ∫   AI774   ≥   $06    ∫
    ∫   DO426   ≥   $04    ∫   DO750   ≥   $04    ∫   AT351   ≥   $08    ∫
    ∫   DO600   ≥   $06    ∫   DI477   ≥   $05    ∫   AT662   ≥   $0A    ∫
    ∫   DO700   ≥   $07    ∫   DI450   ≥ $06, $08 ∫   AT664   ≥   $0C    ∫
    »ÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕº

                                     @239[ Fortsetzung ]                   @001[ öbersicht ]
.239
    HW_list - Liste aller Hardware-Module erstellen (Fortsetzung)

    …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
    ∫    System B&R 2010   ∫    System B&R 2005   ∫    System B&R 2003   ∫
    «ƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ◊ƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ◊ƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ∂
    ∫ I/O-Modul ≥ Typ-Code ∫ I/O-Modul ≥ Typ-Code ∫ I/O-Modul ≥ Typ-Code ∫
    ÃÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕŒÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕŒÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕπ
    ∫   AI300   ≥   $08    ∫   DI476   ≥   $07    ∫   AO352   ≥   $0E    ∫
    ∫   AI700   ≥   $09    ∫   DM455   ≥   $20    ∫   NC161   ≥   $10    ∫
    ∫   AT300   ≥   $0A    ∫   DO479   ≥   $40    ∫   DI135   ≥   $12    ∫
    ∫   AT400   ≥   $0B    ∫   DO480   ≥   $41    ∫   DO135   ≥   $14    ∫
    ∫   AT600   ≥   $0C    ∫   DI690   ≥   $60    ∫   AT352   ≥   $1A    ∫
    ∫   AT601   ≥   $0D    ∫   DO690   ≥   $61    ∫   AF451   ≥   $1E    ∫
    ∫   AT602   ≥   $0E    ∫   DM476   ≥   $62    ∫   AI261   ≥   $20    ∫
    ∫   AO725   ≥   $0F    ∫   AI375   ≥   $80    ∫   AI294   ≥   $22    ∫
    ∫   AO900   ≥   $10    ∫   AI775   ≥   $81    ∫   AF101   ≥   $C0    ∫
    ∫   AO300   ≥   $11    ∫   AI350   ≥   $82    ∫   CM471   ≥   $C1    ∫
    ∫   AM000   ≥   $12    ∫   AI350   ≥   $83    ∫   CM211   ≥   $C2    ∫
    ∫   AM001   ≥   $13    ∫   AM050   ≥   $88    ∫   CM411   ≥   $C3    ∫
    »ÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕº

                                     @240[ Fortsetzung ]                   @001[ öbersicht ]
.240
    HW_list - Liste aller Hardware-Module erstellen (Fortsetzung)

    …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
    ∫    System B&R 2010   ∫    System B&R 2005   ∫    System B&R 2003   ∫
    «ƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ◊ƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ◊ƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ∂
    ∫ I/O-Modul ≥ Typ-Code ∫ I/O-Modul ≥ Typ-Code ∫ I/O-Modul ≥ Typ-Code ∫
    ÃÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕŒÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕŒÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕπ
    ∫   NC300   ≥   $14    ∫   AM051   ≥   $89    ∫   DI435   ≥   $E1    ∫
    ∫   NC301   ≥   $15    ∫   AM374   ≥   $8A    ∫   DO720   ≥   $E2    ∫
    ∫   NC302   ≥   $16    ∫   AT650   ≥   $90    ∫   DM435   ≥   $E3    ∫
    ∫   NC303   ≥   $17    ∫   AT651   ≥   $91    ∫   DI645   ≥   $E5    ∫
    ∫   EX301   ≥   $18    ∫   AT450   ≥   $92    ∫   DO721   ≥   $E6    ∫
    ∫   EX302   ≥   $19    ∫   AT350   ≥   $93    ∫   DM438   ≥   $E7    ∫
    ∫   DS100   ≥   $1A    ∫   AT652   ≥   $94    ∫   DI439   ≥   $E9    ∫
    ∫   DS101   ≥   $1B    ∫   AT660   ≥   $95    ∫   DO435   ≥   $EB    ∫
    ∫   DS102   ≥   $1C    ∫   AI961   ≥   $96    ∫   DO722   ≥   $F2    ∫
    ∫   DO428   ≥   $1D    ∫   NC150   ≥   $98    ∫   DM465   ≥   $F7    ∫
    ∫   IP101   ≥   $1E    ∫   AO350   ≥   $A0    ∫           ≥          ∫
    ∫   DI825   ≥   $1F    ∫   AO775   ≥   $A1    ∫           ≥          ∫
    »ÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕº

                                     @241[ Fortsetzung ]                   @001[ öbersicht ]
.241
    HW_list - Liste aller Hardware-Module erstellen (Fortsetzung)

    …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
    ∫    System B&R 2010   ∫    System B&R 2005   ∫
    «ƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ◊ƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ∂
    ∫ I/O-Modul ≥ Typ-Code ∫ I/O-Modul ≥ Typ-Code ∫
    ÃÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕŒÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕπ
    ∫   DO430   ≥   $20    ∫   DO760   ≥   $B0    ∫
    ∫   UM900   ≥   $21    ∫   DI575   ≥   $B1    ∫
    ∫   DI426   ≥   $22    ∫   DI695   ≥   $B2    ∫
    ∫   NC102   ≥   $23    ∫           ≥          ∫
    ∫   AT610   ≥   $25    ∫           ≥          ∫
    ∫   DI725   ≥   $26    ∫           ≥          ∫
    ∫   DO710   ≥   $27    ∫           ≥          ∫
    ∫   AI730   ≥   $28    ∫           ≥          ∫
    »ÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕº





                                     @242[ Fortsetzung ]                   @001[ öbersicht ]
.242
    HW_list - Liste aller Hardware-Module erstellen (Fortsetzung)

    Typ-Codes der wichtigsten Systemmodule (Zentraleinheiten, Parallel-
    prozessoren, usw.):

    …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
    ∫ Modul               ≥ Typ-Code ≥ Hardware-Typ ≥ benîtigte Datenmodule ∫
    ÃÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ
    ∫ ME010               ≥   $00    ≥ Systemmodul  ≥ IO_2003.BR            ∫
    ∫ EX100/EX150         ≥   $01    ≥ Systemmodul  ≥ IO_2010.BR/IO_2005.BR ∫
    ∫ EX350               ≥   $02    ≥ Systemmodul  ≥ IO_2005.BR            ∫
    ∫ ME020               ≥   $02    ≥ Systemmodul  ≥ IO_2003.BR            ∫
    ∫ EX101               ≥   $03    ≥ Systemmodul  ≥ IO_PCPU.BR            ∫
    ∫ LS191               ≥   $03    ≥ Systemmodul  ≥ IO_PC.BR              ∫
    ∫ NW100/NW150         ≥   $10    ≥ Systemmodul  ≥ IO_2010.BR/IO_2005.BR ∫
    ∫ XP152               ≥   $11    ≥ CPU / PP     ≥ IO_2005.BR            ∫
    ∫ CP100/CP104         ≥   $20    ≥ CPU          ≥ IO_2010.BR            ∫
    ∫ CP152/CP153         ≥   $21    ≥ CPU          ≥ IO_2005.BR            ∫
    ∫ IF152               ≥   $22    ≥ CPU / PP     ≥ IO_2005.BR            ∫
    »ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº

                                     @243[ Fortsetzung ]                   @001[ öbersicht ]
.243
    HW_list - Liste aller Hardware-Module erstellen (Fortsetzung)

    …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
    ∫ Modul               ≥ Typ-Code ≥ Hardware-Typ ≥ benîtigte Datenmodule ∫
    ÃÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ
    ∫ IP151               ≥   $23    ≥ CPU / PP     ≥ IO_2005.BR            ∫
    ∫ CP472               ≥   $24    ≥ CPU          ≥ IO_2003.BR            ∫
    ∫ CP470               ≥   $25    ≥ CPU          ≥ IO_2003.BR            ∫
    ∫ CP474               ≥   $26    ≥ CPU          ≥ IO_2003.BR            ∫
    ∫ CP260               ≥   $27    ≥ CPU          ≥ IO_2005.BR            ∫
    ∫ C300                ≥   $28    ≥ CPU          ≥ IO_PW.BR              ∫
    ∫ C200/C210/C220/P150 ≥   $29    ≥ CPU          ≥ IO_PW.BR              ∫
    ∫ IF260               ≥   $2A    ≥ CPU / PP     ≥ IO_2005.BR            ∫
    ∫ LS251               ≥   $2B    ≥ CPU          ≥ IO_PC.BR              ∫
    ∫ MP100               ≥   $2D    ≥ PP           ≥ IO_2010.BR            ∫
    ∫ IF100/IF101         ≥   $2E    ≥ PP           ≥ IO_2010.BR            ∫
    ∫ CP772               ≥   $30    ≥ CPU          ≥ IO_2003.BR            ∫
    ∫ CP770               ≥   $31    ≥ CPU          ≥ IO_2003.BR            ∫
    ∫ CP774               ≥   $32    ≥ CPU          ≥ IO_2003.BR            ∫
    »ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº

                                     @244[ Fortsetzung ]                   @001[ öbersicht ]
.244
    HW_list - Liste aller Hardware-Module erstellen (Fortsetzung)

    …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
    ∫ Modul               ≥ Typ-Code ≥ Hardware-Typ ≥ benîtigte Datenmodule ∫
    ÃÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ
    ∫ AC701               ≥   $33    ≥ CPU          ≥ IO_2003.BR            ∫
    ∫ IP161               ≥   $34    ≥ CPU / PP     ≥ IO_2005.BR            ∫
    ∫ IP350               ≥   $35    ≥ CPU / PP     ≥ IO_2005.BR            ∫
    ∫ IP152               ≥   $36    ≥ CPU / PP     ≥ IO_2005.BR            ∫
    ∫ CP430               ≥   $38    ≥ CPU          ≥ IO_2003.BR            ∫
    ∫ CP476               ≥   $39    ≥ CPU          ≥ IO_2003.BR            ∫
    ∫ HIC3                ≥   $3A    ≥ CPU          ≥ IO_PCPU.BR            ∫
    ∫ CP200               ≥   $50    ≥ CPU          ≥ IO_2010.BR            ∫
    ∫ CP210               ≥   $51    ≥ CPU          ≥ IO_2010.BR            ∫
    ∫ IF050               ≥   $60    ≥ Systemmodul  ≥ IO_2005.BR            ∫
    ∫ NC154               ≥   $61    ≥ Systemmodul  ≥ IO_2005.BR            ∫
    ∫ EM150               ≥   $62    ≥ Systemmodul  ≥ IO_2005.BR            ∫
    ∫ IF060               ≥   $63    ≥ Systemmodul  ≥ IO_2005.BR            ∫
    ∫ NC156               ≥   $64    ≥ Systemmodul  ≥ IO_2005.BR            ∫
    ∫ NC158               ≥   $65    ≥ Systemmodul  ≥ IO_2005.BR            ∫
    »ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº
                                     @245[ Fortsetzung ]                   @001[ öbersicht ]
.245
    HW_list - Liste aller Hardware-Module erstellen (Fortsetzung)

    …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
    ∫ Modul               ≥ Typ-Code ≥ Hardware-Typ ≥ benîtigte Datenmodule ∫
    ÃÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ
    ∫ NC157               ≥   $66    ≥ Systemmodul  ≥ IO_2005.BR            ∫
    ∫ EX450/LS050-26      ≥   $96    ≥ Systemmodul  ≥ IO_2005.BR/IO_PC.BR   ∫
    ∫ ME050-26            ≥   $96    ≥ Systemmodul  ≥ IO_2003.BR            ∫
    ∫ EX450/LS050-66-2    ≥   $9B    ≥ Systemmodul  ≥ IO_2005.BR/IO_PC.BR   ∫
    ∫ ME050-66-2          ≥   $9B    ≥ Systemmodul  ≥ IO_2003.BR            ∫
    ∫ EX450/LS050-66      ≥   $A6    ≥ Systemmodul  ≥ IO_2005.BR/IO_PC.BR   ∫
    ∫ ME050-66            ≥   $A6    ≥ Systemmodul  ≥ IO_2003.BR            ∫
    ∫ EX450/LS050-78      ≥   $A7    ≥ Systemmodul  ≥ IO_2005.BR/IO_PC.BR   ∫
    ∫ ME050-78            ≥   $A7    ≥ Systemmodul  ≥ IO_2003.BR            ∫
    ∫ EX450/LS050-76      ≥   $A8    ≥ Systemmodul  ≥ IO_2005.BR/IO_PC.BR   ∫
    ∫ ME050-76            ≥   $A8    ≥ Systemmodul  ≥ IO_2003.BR            ∫
    ∫ EX450/LS050-77      ≥   $A9    ≥ Systemmodul  ≥ IO_2005.BR/IO_PC.BR   ∫
    ∫ ME050-77            ≥   $A9    ≥ Systemmodul  ≥ IO_2003.BR            ∫
    ∫ EX450/LS050-21      ≥   $AB    ≥ Systemmodul  ≥ IO_2005.BR/IO_PC.BR   ∫
    ∫ ME050-21            ≥   $AB    ≥ Systemmodul  ≥ IO_2003.BR            ∫
    »ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº
                                     @246[ Fortsetzung ]                   @001[ öbersicht ]
.246
    HW_list - Liste aller Hardware-Module erstellen (Fortsetzung)

    …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
    ∫ Modul               ≥ Typ-Code ≥ Hardware-Typ ≥ benîtigte Datenmodule ∫
    ÃÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ
    ∫ EX450/LS050-71      ≥   $AC    ≥ Systemmodul  ≥ IO_2005.BR/IO_PC.BR   ∫
    ∫ ME050-71            ≥   $AC    ≥ Systemmodul  ≥ IO_2003.BR            ∫
    ∫ EX450/LS050-41      ≥   $AD    ≥ Systemmodul  ≥ IO_2005.BR/IO_PC.BR   ∫
    ∫ ME050-41            ≥   $AD    ≥ Systemmodul  ≥ IO_2003.BR            ∫
    ∫ EX450/LS050-72      ≥   $AE    ≥ Systemmodul  ≥ IO_2005.BR/IO_PC.BR   ∫
    ∫ ME050-72            ≥   $AE    ≥ Systemmodul  ≥ IO_2003.BR            ∫
    »ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº









                                     @247[ Fortsetzung ]                   @001[ öbersicht ]
.247
    HW_list - Liste aller Hardware-Module erstellen (Fortsetzung)

    Typ-Codes der Submodule (Einschubmodule) des Systems B&R 2005:

    …ÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕª
    ∫ Submodul ≥ Typ-Code ∫
    ÃÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕπ
    ∫ IF613    ≥   $00    ∫
    ∫ IF672    ≥   $01    ∫
    ∫ IF661    ≥   $02    ∫
    ∫ IF621    ≥   $03    ∫
    ∫ IF671    ≥   $04    ∫
    ∫ IF681    ≥   $05    ∫
    ∫ IF681    ≥   $06    ∫
    ∫ IF622    ≥   $08    ∫
    ∫ MC111    ≥   $7B    ∫
    ∫ MC112    ≥   $7C    ∫
    ∫ MC211    ≥   $7D    ∫
    ∫ MC212    ≥   $7E    ∫
    »ÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕº

                                       @230[ HW_list ]                     @001[ öbersicht ]
.500
    ANHANG : LIBRARY-Informationen


    @501[< Allgemeines       >]      Voraussetzungen etc.

    @550[< Syntax            >]      Syntax fÅr die ErklÑrung der Funktionen

    @600[< Fehlernummern     >]      Zusammenfassung aller Fehlernummern

    @650[< AusfÅhrungszeiten >]      AusfÅhrungszeiten und Stackbedarf

    @700[< Beispiele         >]      Beispiele fÅr die Verwendung der Funktionsblîcke

    @800[< History           >]      Neue FunktionalitÑten und VersionsÑnderungen







                                                                     @001[ öbersicht ]
.501
    I/O-Library : Allgemeines

    Die I/O-Library bietet dem Anwender die Mîglichkeit, ...

    ... (neben den zyklischen I/O-Zugriffen) direkt auf I/O-Punkte des I/O-
        Busses zuzugreifen (direkter I/O-Zugriff).
    ... den zyklischen Zugriff auf ein I/O-Modul dynamisch zu aktivieren oder
        zu deaktivieren.
    ... das Vorhandensein eines I/O-Moduls zu ÅberprÅfen. Ist ein Modul nicht
        vorhanden, kann der Zugriff auf das Modul deaktiviert werden.
    ... eine Liste mit Name, Moduladresse und Typ aller am I/O-Bus gesteckten
        I/O-Module zu erstellen.
    ... bei einer I/O-Exception das fehlerverursachende I/O-Modul festzustellen
        und zu deaktivieren.







                                     @502[ Fortsetzung ]                   @001[ öbersicht ]
.502
    I/O-Library : Allgemeines (Fortsetzung)

    Nach dem Importieren der I/O-Library stehen Ihnen folgende Funktionsgruppen
    zur VerfÅgung:

    - @503[Direkter I/O-Zugriff        ]
    - @505[Dynamische I/O-Konfiguration]

    Anmerkungen:
    - Bevor Sie die Funktionen der I/O-Library in Ihrem Projekt verwenden
      kînnen, mÅssen Sie die Library in die entsprechende Projekt-Datenbank
      importieren.

    - Da die I/O-Library AVT-Funktionen enthÑlt, kînnen die Funktionen dieser
      Library nur verwendet werden, wenn das Library-Runtime-Modul (B&R-Modul
      IO_LIB.BR) auf der Zentraleinheit (Anwender-ROM) vorhanden ist!

    - Die Funktionen der I/O-Library liefern im Fehlerfall als Ergebnis eine
      @600[Fehlernummer].


                                     @503[ Fortsetzung ]                   @001[ öbersicht ]
.503
    I/O-Library : Allgemeines (Fortsetzung)

    Allgemeines zum direkten I/O-Zugriff:
    Neben den zyklischen I/O-Zugriffen kann auf I/O-Punkte auch direkt zuge-
    griffen werden. Ein direkter I/O-Zugriff setzt sich aus der Definition des
    Schaufelauftrags und der Datenanforderung zusammen. Mit der I/O-Library
    kînnen direkte I/O-Zugriffe sowohl definiert als auch ausgefÅhrt werden:

    IO_mphydef ... Multiple physikalische Schaufelauftragsdefinition
    IO_ptest ..... Physikalische Schaufelauftragsdefinition testen
    IO_data ...... I/O-Schaufelauftrag ausfÅhren

    Die Auftragsdefinition und die AuftragsausfÅhrung kînnen in unterschied-
    lichen Tasks erfolgen. Dabei ist jedoch zu beachten, da· die Deinstallation
    der Definitions-Task (Task mit der Schaufelauftragsdefinition) zu einem
    nichtvorhersagbaren Systemverhalten fÅhrt, da die fÅr den Schaufelauftrag
    notwendigen Datenbereiche im Kontext der Definitions-Task abgelegt werden!




                                     @504[ Fortsetzung ]                   @001[ öbersicht ]
.504
    I/O-Library : Allgemeines (Fortsetzung)

    Achtung!
    - Die Funktion IO_ptest() kann am Parallelprozessor bzw. Multiprozessor
      (im weiteren auch "PP" bzw. "MP" genannt) derzeit nicht verwendet
      werden (siehe entsprechenden Abschnitt)!
    - Mit den Funktionen fÅr den direkten I/O-Zugriff ist ein Zugriff auf
      Remote I/O-Daten nicht mîglich!













                                     @505[ Fortsetzung ]                   @001[ öbersicht ]
.505
    I/O-Library : Allgemeines (Fortsetzung)

    Allgemeines zur dynamischen I/O-Konfiguration:
    Mit den Funktionen dieser Gruppe kann die aktuelle I/O-Konfiguration
    ermittelt und der Zugriff auf I/O-Module dynamisch aktiviert oder
    deaktiviert werden:

    IO_info ...... Bestimmen des fehlerverursachenden I/O-Moduls
    IX_info ...... Bestimmen des fehlerverursachenden Submoduls
    IO_disable ... Deaktivieren eines I/O-Moduls
    IX_disable ... Deaktivieren eines I/O-Moduls mit Subslots
    IO_enable .... Aktivieren eines I/O-Moduls
    IX_enable .... Aktivieren eines I/O-Moduls mit Subslots
    IO_check ..... PrÅfen eines I/O-Moduls
    IX_check ..... PrÅfen eines I/O-Moduls mit Subslots
    IO_list ...... Liste aller gesteckten I/O-Module erstellen
    IO_slist ..... Liste aller gesteckten Submodule erstellen
    SYS_list ..... Liste aller gesteckten Systemmodule erstellen
    HW_list ...... Liste aller Hardware-Module erstellen


                                       @500[ ANHANG ]                      @001[ öbersicht ]
.550
    I/O-Library : Syntaxbeschreibung

    Datentypen:
    FÅr viele Funktionen sind bestimmte Gruppen von Datentypen zulÑssig. Um
    bei der Funktionsbeschreibung nicht alle zulÑssigen Datentypen anfÅhren
    zu mÅssen, werden folgende Gruppenbezeichnungen eingefÅhrt:
    …ÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕª
    ∫ Gruppe ∫  BIT  ≥ INT8  ≥ BYTE  ≥ INT16 ≥ WORD  ≥ INT32 ≥ LONG  ≥ FLOAT ∫
    ÃÕÕÕÕÕÕÕÕŒÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕπ
    ∫ BASIS  ∫       ≥   x   ≥   x   ≥   x   ≥   x   ≥   x   ≥   x   ≥       ∫
    «ƒƒƒƒƒƒƒƒ◊ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ∂
    ∫ NICHT  ∫   x   ≥   x   ≥   x   ≥   x   ≥   x   ≥   x   ≥   x   ≥       ∫
    ∫ FLOAT  ∫       ≥       ≥       ≥       ≥       ≥       ≥       ≥       ∫
    «ƒƒƒƒƒƒƒƒ◊ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ∂
    ∫ ALLE   ∫   x   ≥   x   ≥   x   ≥   x   ≥   x   ≥   x   ≥   x   ≥   x   ∫
    «ƒƒƒƒƒƒƒƒ◊ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ∂
    ∫ FELD   ∫  [x]  ≥  [x]  ≥  [x]  ≥  [x]  ≥  [x]  ≥  [x]  ≥  [x]  ≥  [x]  ∫
    »ÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕÕœÕÕÕÕÕÕÕœÕÕÕÕÕÕÕœÕÕÕÕÕÕÕœÕÕÕÕÕÕÕœÕÕÕÕÕÕÕœÕÕÕÕÕÕÕœÕÕÕÕÕÕÕº
      x  Datentyp ist zulÑssig
     [x] Datentyp ist zulÑssig als Feldvariable oder Zeichenkette (String)

                                     @551[ Fortsetzung ]                   @001[ öbersicht ]
.551
    I/O-Library : Syntaxbeschreibung (Fortsetzung)

    Pfeile:
    FÅr die Darstellung von Eingangs- und Ausgangsparametern werden Pfeile
    verwendet. Dabei gilt folgende Vereinbarung:
    …ÕÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
    ∫  Pfeil  ∫  Bedeutung                                                   ∫
    ÃÕÕÕÕÕÕÕÕÕŒÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ
    ∫   ->    ∫  Eingangsparameter                                           ∫
    «ƒƒƒƒƒƒƒƒƒ◊ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
    ∫   <->   ∫  Ein-/Ausgangsparameter. Funktionell ist es ein Ausgangs-    ∫
    ∫         ∫  parameter. öblicherweise wird er aber vor dem Aufruf der    ∫
    ∫         ∫  Funktion mit einer bestimmten Information geladen (z.B.     ∫
    ∫         ∫  einer Adresse). Meist wird die Adresse einer Variable mit   ∫
    ∫         ∫  adr() [PL2000] oder einem Adre·kontakt [KOP] angeschlossen. ∫
    «ƒƒƒƒƒƒƒƒƒ◊ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
    ∫   <-    ∫  Ausgangsparameter                                           ∫
    »ÕÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº



                                     @552[ Fortsetzung ]                   @001[ öbersicht ]
.552
    I/O-Library : Syntaxbeschreibung (Fortsetzung)

    Funktionsblîcke:
    Funktionsblîcke sind in dieser Online-Hilfe nicht grafisch dargestellt.
    Sie finden aber alle fÅr Funktionsblîcke relevanten Informationen, wie
    Eingangsparameter (->), Ein-/Ausgangsparameter (<->) und Ausgangsparameter
    (<-) in der Online-Hilfe.














                                       @500[ ANHANG ]                      @001[ öbersicht ]
.600
    I/O-Library : Fehlernummern

    Die folgende Liste ist eine Zusammenfassung aller mîglichen Fehlermeldungen
    der I/O-Library:

    5501     Falsche Parameter
    5550     IO_info(): Keine Information vorhanden (falscher Kontext)
    5551     IO_ptest()/IO_check()/IX_check()/IO_list() in mehreren Task-
             klassen parallel aufgerufen
    5552     Analogdaten mit ungerader LÑnge oder ungerader Adresse kînnen
             nicht geforced werden
    5553     IO_ptest()/IO_check()/IX_check()/IO_list() darf nicht in HS-
             Taskklassen aufgerufen werden
    5554     I/O-Modul gesteckt, aber Modultyp stimmt nicht
    5555     I/O-Modul / Anpassungsmodul / Systemmodul nicht gesteckt oder
             falsch
    5556     IO_ptest()/IO_mphydef(): Falsche Adresse "data_adr" angegeben
    5557     IO_ptest()/IO_mphydef(): Falscher Offset "intern_off" oder
             falsche LÑnge "data_len"
    5558     Funktion darf am Parallelprozessor bzw. Multiprozessor nicht
             aufgerufen werden
                                     @601[ Fortsetzung ]                   @001[ öbersicht ]
.601
    I/O-Library : Fehlernummern (Fortsetzung)

    5559     Funktion IO_data() in Arbeit (Aufruf im nÑchsten Zyklus notwendig)
    5562     Funktion bei optimierter IO-Emulation derzeit nicht mîglich
    5563     Funktion auf Systemen mit EX350 derzeit nicht mîglich
    5564     Kein Zugriff auf 2010-IO bzw. 2005-Erweiterungen
    5565     Kein 2005-Basis-IO vorhanden
    5567     IO_check/IX_check/IO_ptest: FUB-Daten liegen nicht im
             IO/Merker-Pool
    5569     SC-Adresse nicht WORD-Aligned
    5576     Fehler beim Direkt-IO
    5578     2003: Direkt-IO-Overflow
    5579     2003: alter Direkt-IO-Auftrag noch aktiv
    9136     IO-Fehler 2003
    11716    IO_data(): Timeout beim Schaufelauftrag (fataler Fehler)
    11717    IO_data(): UngÅltiger I/O-Identifier





                                       @500[ ANHANG ]                      @001[ öbersicht ]
.650
    I/O-Library : AusfÅhrungszeiten

    Die folgende Tabelle zeigt die AusfÅhrungszeiten der Funktionen der I/O-
    Library sowie deren Stackbedarf:

    …ÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
    ∫ Funktion   ≥  Laufzeit  ≥ Userstack ≥ Supervisor- ≥   bei              ∫
    ∫            ≥    [Ês]    ≥  [Byte]   ≥ stack [Byte]≥                    ∫
    «ƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
    ∫ IO_mphydef ≥        460 ≥     172   ≥      46     ≥ 2010-IO ohne  INIT ∫
    ∫            ≥480 + 9 * n ≥     172   ≥      46     ≥ 2010-IO mit n INIT ∫
    ∫            ≥        480 ≥     212   ≥      46     ≥ 2005-IO ohne  INIT ∫
    ∫            ≥505 + 9 * n ≥     212   ≥      46     ≥ 2005-IO mit n INIT ∫
    ∫            ≥        290 ≥     144   ≥      46     ≥ Deaktivierung      ∫
    ∫ IO_ptest   ≥        520 ≥     172   ≥      46     ≥ 2010-IO OK         ∫
    ∫            ≥        840 ≥     172   ≥     212     ≥ 2010-IO nicht OK   ∫
    ∫            ≥        450 ≥     212   ≥      46     ≥ 2005-IO OK         ∫
    ∫            ≥        800 ≥     212   ≥     282     ≥ 2005-IO nicht OK   ∫
    ∫ IO_info    ≥         45 ≥      24   ≥       -     ≥                    ∫
    »ÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº

                                     @651[ Fortsetzung ]                   @001[ öbersicht ]
.651
    I/O-Library : AusfÅhrungszeiten (Fortsetzung)

    …ÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
    ∫ Funktion   ≥  Laufzeit  ≥ Userstack ≥ Supervisor- ≥   bei              ∫
    ∫            ≥    [Ês]    ≥  [Byte]   ≥ stack [Byte]≥                    ∫
    «ƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
    ∫ IO_data    ≥     >   50 ≥      24   ≥       -     ≥ 2010-IO            ∫
    ∫            ≥     >  100 ≥      24   ≥      26     ≥ 2005-IO            ∫
    ∫            ≥     >   90 ≥      72   ≥     144     ≥ 2003-IO            ∫
    ∫ IO_disable ≥     >  700 ≥     176   ≥      36     ≥ projektabhÑngig    ∫
    ∫ IO_enable  ≥     >  700 ≥     176   ≥      36     ≥ projektabhÑngig    ∫
    ∫ IO_check   ≥ 340 -  650 ≥     120   ≥     212     ≥ 2010-IO            ∫
    ∫            ≥ 520 -  690 ≥     160   ≥     282     ≥ 2005-IO            ∫
    ∫ IO_alloc   ≥ 200 -  ??? ≥      56   ≥     296     ≥ CP260, 16-??? Byte ∫
    ∫ IO_free    ≥ 190 -  ??? ≥      52   ≥     296     ≥ CP260, 16-??? Byte ∫
    ∫ IO_list    ≥ 410 -65000 ≥     180   ≥     212     ≥ 2010-IO            ∫
    ∫            ≥ 580 - 9000 ≥     220   ≥     282     ≥ 2005-IO            ∫
    ∫ SYS_list   ≥ 180 - 1400 ≥     104   ≥     118     ≥                    ∫
    »ÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº


                                       @500[ ANHANG ]                      @001[ öbersicht ]
.700
    I/O-Library : Beispiel 1

    Beispiel zu IO_list():

      ; Durchsuchen des I/O-Busses (B&R 2010) im INIT-UP der Exceptiontask
      module_adr = 0        ; ganzen I/O-Bus vom Beginn weg durchsuchen
      module_cnt = 0        ; Initialisierung des ModulzÑhlers
      loop
          ; Aufruf von IO_list() im Loop: enable=1, 2010-I/O (io_type=0,
          ; master_no=1, slave_no=0), I/O-Modul-Name egal: adr(name_adr)=0
          IO_list(1,0,1,0,module_adr,0,status,module_adr,
                  modul_typ[module_cnt],io_bus)
          ; erhaltene Moduladresse in einem Feld merken
          if status = 0 then
              moduladr[module_cnt] = modul_adr
          endif
          ; Wenn kein Modul mehr vorhanden oder die Tabelle voll ist: Loop-Ende
          exitif (status <> 0) or (module_cnt >= max_dim)
          ; Kein Fehler, daher ModulzÑhler erhîhen
          module_cnt = module_cnt + 1
      endloop
                                     @710[ Beispiel 2 ]                    @001[ öbersicht ]
.710
    I/O-Library : Beispiel 2

    Beispiel zu IO_disable():
    Deaktivieren eines I/O-Moduls bei einer I/O-Exception.

      ; Auswerten der I/O-Exception in einer Exceptiontask (Exception-Nr. 128)
      IO_info(1,sts_info,io_typ,master,slave,moduladr,int_off,mode)

      ; Deaktivieren des I/O-Moduls, das den Fehler ausgelîst hat
      ; Kein FORCEN der Input-PVs im normalen I/O-Bereich
      IO_disable(1,io_typ,master,slave,moduladr,0,0,0,sts_dis)

      ; Ende der Exceptiontask => die RPSSW setzt den zyklischen Ablauf fort,
      ; das deaktivierte I/O-Modul wird aber nicht mehr zyklisch behandelt







                                     @720[ Beispiel 3 ]                    @001[ öbersicht ]
.720
    I/O-Library : Beispiel 3

    Beispiel zu IO_check():
    Deaktivieren nicht vorhandener I/O-Module im Hochlauf der RPS.

      ; Im INIT-UP einer Exceptiontask (z.B. Exception-Nr. 128) wird geprÅft,
      ; ob die 2010-I/O-Module Nr. 2-8 (Moduladresse 2 bis 8) vorhanden sind
      ; (Typ des I/O-Moduls wird nicht geprÅft). Die nicht vorhandenen I/O-
      ; Module werden deaktiviert.
      ; => Dynamische I/O-Konfiguration des Systems im Hochlauf
      loop mod_nr = 2 to 8 do
          ; PrÅfen des I/O-Moduls Nr. "mod_nr" ohne Typ-Check. Flag (das an-
          ; zeigt, ob das I/O-Modul vorhanden ist) im Feld "ioflag" merken.
          IO_check(1,0,1,0,mod_nr,0,sts_chk,ioflag[mod_nr],found_typ)
          ; Wenn das Modul nicht vorhanden ist, wird es deaktiviert,
          ; dabei werden die Inputs nicht geforced, die Verriegelung in der
          ; Applikation erfolgt z.B. Åber "io_flag".
          if sts_chk <> 0 then
              IO_disable(1,0,1,0,mod_nr,0,0,0,sts_ena)
          endif
      endloop
                                       @500[ ANHANG ]                      @001[ öbersicht ]
.800
    I/O-Library : History - VersionsÑnderungen

  …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
  ∫ V2.30 -> V2.31  ≥ AKTUELLE VERSION: Neue FunktionalitÑten/Fehlerbehebung  ∫
  «ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
  ∫ - SYS_list: ME010 Modulkennung von 0 auf 1 geaendert                      ∫
  ∫ - io_2003.br: ME010 Modulkennung von 0 auf 1 geaendert                    ∫
  ∫               CM211, CM411 inkl. ANP-Anteilen                             ∫
  ∫ - IO_mphydef, IO_check, IX_check bei CP476 mit Moduladresse 16 OK         ∫
  ∫ - IO_mphydef: Check des WORD-Alignment von sc_adr                         ∫
  ∫ - IO_ptest bei 2003-ANP-Modulen OK                                        ∫
  ∫ - IO_ptest OK bei "lokalen Variablen im UserRAM"                          ∫
  ∫ - IO_check / IX_check OK auf CP476 / PPxx mit mehr als 12100 Byte         ∫
  ∫   RPS-Globals Analog                                                      ∫
  ∫ - Fehlerkorrektur wegen Exception beim Download                           ∫
  »ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº





                                     @804[ Fortsetzung ]                   @001[ öbersicht ]
.804
    I/O-Library : History - VersionsÑnderungen

  …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
  ∫ V2.23 -> V2.30  ≥ AKTUELLE VERSION: Neue FunktionalitÑten/Fehlerbehebung  ∫
  «ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
  ∫ - keine HW-Konfigurationserkennung mehr -> nur mehr im RPSSW Basissystem  ∫
  ∫   ab RPSSW V2.22;                                                         ∫
  ∫ - io_pcpu.br: PP00 statt HIC3                                             ∫
  ÃÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ
  ∫ V2.22 -> V2.23  ≥ AKTUELLE VERSION: Neue FunktionalitÑten/Fehlerbehebung  ∫
  «ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
  ∫ - UnterstÅtzung der HIC3                                                  ∫
  ∫ - UnterstÅtzung der 18-fach Backplane 2005 (bis zu 16 IO-Module)          ∫
  ∫ - IO_data: Fehler 9111 bei IO-Exception durch FUB selbst,                 ∫
  ∫            Fehler 5568 bei IO-Exception durch vorigen Auftrag (IO_check)  ∫
  ∫ - io_pcpu.br: HIC3, EX101 mit IF6xx, PCMCIA mit MCxxx, AI901, AI902       ∫
  ∫ - io_2005.br: DI486, UM161, IF686, DO486, AO360, DI695, DI175             ∫
  ∫ - io_2003.br: ME050-xx, AI901, AI902                                      ∫
  »ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº


                                     @805[ Fortsetzung ]                   @001[ öbersicht ]
.805
    I/O-Library : History - VersionsÑnderungen

  …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
  ∫ V2.20 -> V2.22  ≥ AKTUELLE VERSION: Neue FunktionalitÑten/Fehlerbehebung  ∫
  «ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
  ∫ - UnterstÅtzung der Module CP476 mit ME010/ME020 + IF6xx, EX450, LS050    ∫
  ∫ - UnterstÅtzung der 18-fach Backplane 2005 (bis zu 15 IO-Module)          ∫
  ∫ - IO_disable, IX_disable : Fehlerkorrektur fuer Moduladresse 0 (2003)     ∫
  ∫ - io_2005.br: IF622, EX450                                                ∫
  ∫ - io_2003.br: CM211, CM411, ME010, ME020, IF6xx                           ∫
  ∫ - io_pc.br  : LS050                                                       ∫
  ∫ - IO_data : Timeout fuer 1 Auftrag auf 4-fache Zeit erhoeht (Fehler 11716)∫
  ∫ - HW_list : IF060-Slotmodule funktionieren                                ∫
  ∫ - SYS_list : LS251 inkl. Systemmodule (EX150, LS050) funktionieren        ∫
  ÃÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ
  ∫ V2.10 -> V2.20  ≥ AKTUELLE VERSION: Neue FunktionalitÑten/Fehlerbehebung  ∫
  «ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
  ∫ - Nutzung der IO-Library im Automation Studio moeglich                    ∫
  ∫ - HW-Konfigurationserkennung fuer EX250                                   ∫
  ∫ - IO_physdef, IO_define und IO_combine werden nicht mehr unterstÅtzt      ∫
  »ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº
                                     @806[ Fortsetzung ]                   @001[ öbersicht ]
.806
    I/O-Library : History - VersionsÑnderungen

  …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
  ∫ V2.00 -> V2.10  ≥ AKTUELLE VERSION: Neue FunktionalitÑten/Fehlerbehebung  ∫
  «ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
  ∫ - Neuer Funktionsblock HW_list().                                         ∫
  ∫ - UnterstÅtzung der CPUs IP161 und IP152 (SYS_list, IO_disable).          ∫
  ∫ - IO_mphydef() auch auf IF260 (bei Verwendung als PP) mîglich (Voraus-    ∫
  ∫   setzung: Hardware-Revision 13.00).                                      ∫
  ∫ - IO_ptest, IO_check, IX_check : Fehler 5567, wenn FUB-Daten nicht im     ∫
  ∫   Merker-Pool                                                             ∫
  ∫ - Fehlerkorrektur bei IX_enable() / IX_disable()                          ∫
  ∫ - Fehlerkorrektur bei IO_mphydef (Deaktivierung)                          ∫
  ∫ - Fehlerkorrektur bei SYS_list mit PP                                     ∫
  ∫ - Fehlerkorrektur bei IO_check (Modultyp)                                 ∫
  ∫ - Fehlerkorrektur bei Initialisierung (RPSSW-Fehler 7010)                 ∫
  »ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº




                                     @807[ Fortsetzung ]                   @001[ öbersicht ]
.807
    I/O-Library : History - VersionsÑnderungen

  …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
  ∫ V1.60 -> V2.00  ≥ éLTERE VERSIONEN: Neue FunktionalitÑten/Fehlerbehebung  ∫
  «ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
  ∫ - UnterstÅtzung der Module IF260, IP350, LS251.                           ∫
  ∫ - Neue Funktionen fÅr 2003-Slots: IX_info(), IX_enable(), IX_disable()    ∫
  ∫   und IX_check().                                                         ∫
  ∫ - Neue Funktionen fÅr EX350-Bedienung: IO_alloc() und IO_free().          ∫
  ∫ - Neues Datenmodul "IO_2005.BR" mit den Namen der 2005-IF-Module (CP260,  ∫
  ∫   IF260).                                                                 ∫
  ∫ - Fehlerkorrektur bei EX350-Bedienung (HW-Konfigurationserkennung).       ∫
  ∫ - Fehlerkorrektur beim FUB IO_slist() bezÅglich RIO-2003.                 ∫
  ∫ - Fehlerkorrektur beim FUB IO_mphydef() fÅr CP260 (Daten wurden nicht     ∫
  ∫   geschaufelt).                                                           ∫
  ∫ - Fehlerkorrektur beim FUB IO_check() wegen DI426.                        ∫
  ∫ - Keine UnterstÅtzung mehr fÅr die Version V1.05 der RPSSW.               ∫
  »ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº



                                     @808[ Fortsetzung ]                   @001[ öbersicht ]
.808
    I/O-Library : History - VersionsÑnderungen (Fortsetzung)

  …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
  ∫ V1.50 -> V1.60  ≥ éLTERE VERSIONEN: Neue FunktionalitÑten/Fehlerbehebung  ∫
  «ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
  ∫ - Umstellung auf eine IO-Manager-Task zur Ermittlung der Hardware-        ∫
  ∫   Konfiguration (inkl. 2005-Erweiterungen und Remote-IO) im Hochlauf.     ∫
  ∫ - UnterstÅtzung der Module IP151, IF152 und CP260.                        ∫
  ∫ - UnterstÅtzung der CP4xx und CP7xx (2003-IO). Mit der neuen Funktion     ∫
  ∫   IO_slist() kann eine Liste der vorhandenen I/O-Module (2003-IO) er-     ∫
  ∫   stellt werden.                                                          ∫
  ∫ - Neues Datenmodul "IO_2003.BR" mit den Namen aller 2003-IO-Module.       ∫
  ∫ - Der FUB IO_list() kann ab dieser Version auch fÅr RIO-2010 und RIO-2005 ∫
  ∫   verwendet werden.                                                       ∫
  ∫ - Fehlerkorrektur beim FUB IO_mphydef() fÅr 2005-IO-Statuszugriff auf     ∫
  ∫   gerade Moduladressen.                                                   ∫
  »ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº




                                     @809[ Fortsetzung ]                   @001[ öbersicht ]
.809
    I/O-Library : History - VersionsÑnderungen (Fortsetzung)

  …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
  ∫ V1.40 -> V1.50  ≥ éLTERE VERSIONEN: Neue FunktionalitÑten                 ∫
  «ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
  ∫ - UnterstÅtzung der CP200.                                                ∫
  ∫ - Funktion SYS_list() fÅr die Analyse der vorhandenen Systemmodule.       ∫
  ÃÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ
  ∫ V1.32 -> V1.40  ≥ éLTERE VERSIONEN: Neue FunktionalitÑten                 ∫
  «ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
  ∫ - UnterstÅtzung der XP152.                                                ∫
  ÃÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ
  ∫ V1.31 -> V1.32  ≥ éLTERE VERSIONEN: Neue FunktionalitÑten                 ∫
  «ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
  ∫ - Neues Datenmodul "IO_2010.BR" mit den Namen aller 2010-IO-Module fÅr    ∫
  ∫   die Verwendung im Funktionsblock RIO_list() ab RIO-Version V4.20.       ∫
  ∫ - Korrektur eines Fehlers bei IO_mphydef() : Bei 2005-IO konnte es nach   ∫
  ∫   dem Deaktivieren des Eintrags (iop = NULL) zum Fehler 11716 bei         ∫
  ∫   IO_data() kommen.                                                       ∫
  »ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº

                                     @810[ Fortsetzung ]                   @001[ öbersicht ]
.810
    I/O-Library : History - VersionsÑnderungen (Fortsetzung)

  …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
  ∫ V1.30 -> V1.31  ≥ éLTERE VERSIONEN: Neue FunktionalitÑten                 ∫
  «ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
  ∫ - Korrektur eines Fehlers bei IO_mphydef() bzw. IO_ptest() : Bei 2005-IO  ∫
  ∫   konnten nur 7 Byte Status bzw. 15 Byte Normal behandelt werden, bei     ∫
  ∫   8 Byte Status bzw. 16 Byte Normal wurde der Fehler 5557 gemeldet.       ∫
  ÃÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ
  ∫ V1.20 -> V1.30  ≥ éLTERE VERSIONEN: Neue FunktionalitÑten                 ∫
  «ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
  ∫ - Neuer FUB IO_ptest() fÅr den Test einer physikalischen Schaufelauf-     ∫
  ∫   tragsdefinition. Dieser FUB kann nur auf der RPS-CPU aufgerufen werden. ∫
  ÃÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ
  ∫ V1.12 -> V1.20  ≥ éLTERE VERSIONEN: Neue FunktionalitÑten                 ∫
  «ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
  ∫ - Neuer FUB IO_mphydef() fÅr die multiple physikalische Schaufelauftrags- ∫
  ∫   definition. Dieser FUB kann sowohl auf der RPS-CPU als auch am MP2010   ∫
  ∫   aufgerufen werden.                                                      ∫
  »ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº

                                     @811[ Fortsetzung ]                   @001[ öbersicht ]
.811
    I/O-Library : History - VersionsÑnderungen (Fortsetzung)

  …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
  ∫ V1.11 -> V1.12  ≥ éLTERE VERSIONEN: Fehlerbehebung                        ∫
  «ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
  ∫ - Wird bei IO_list() prev_mod=255 angegeben, tritt kein fataler Fehler    ∫
  ∫   mehr auf, sondern es wird der Status 5555 geliefert.                    ∫
  ∫ - Bei 2005-Basis-IO werden bei IO_list() keine Systemmodule mehr ge-      ∫
  ∫   funden. Auch IO_check() liefert bei Systemmodulen den Status 5555.      ∫
  ∫ - IO_check() liefert bei Moduladressen > 99 (2010) bzw. > 13 (2005) den   ∫
  ∫   Status 5501.                                                            ∫
  »ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº









                                     @812[ Fortsetzung ]                   @001[ öbersicht ]
.812
    I/O-Library : History - VersionsÑnderungen (Fortsetzung)

  …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
  ∫ V1.11           ≥                                                         ∫
  «ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
  ∫ - öbernahme der Direkt-IO-FUBs in das Modul "IO_LIB.BR"; damit wird       ∫
  ∫   das Modul "DIRECTIO.BR" nicht weiter unterstÅtzt.                       ∫
  ∫ - Neue FUBs fÅr IO-Exception-Information, dynamisches Aktivieren und      ∫
  ∫   Deaktivieren von I/O-Modulen, Check von I/O-Modulen und Liste der       ∫
  ∫   vorhandenen I/O-Module.                                                 ∫
  ∫   ACHTUNG: Voraussetzung fÅr die FUBs IO_info(), IO_check() und IO_list() ∫
  ∫            sind die Module "EXERMO.BR" und "IO_LIB.BR" ab Version V1.11 ! ∫
  »ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº








                                       @500[ ANHANG ]                      @001[ öbersicht ]
.End

