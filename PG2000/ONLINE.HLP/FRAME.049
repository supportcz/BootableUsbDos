%%
1,0:1
%%
.1
    Funktionen der Frame-Treiber-Library

  …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
  ∫ ACHTUNG: Die Funktionen dieser Library kînnen nur verwendet werden, wenn  ∫
  ∫          der Frame-Treiber DVFRAME.BR im nullspannungssicheren Speicher   ∫
  ∫          (Anwender-ROM) der Steuerung vorhanden ist!                      ∫
  ∫          Nach dem öbertragen des Frame-Treibers in den nullspannungs-     ∫
  ∫          sicheren Speicher mu· ein KALTSTART (frÅher "TOTALINIT" genannt) ∫
  ∫          durchgefÅhrt werden.                                             ∫
  »ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº











                                     @002[ Fortsetzung ]               @999[ HILFE beenden ]
.2
    Funktionen der Frame-Treiber-Library (Fortsetzung)

    Nach dem Importieren der Frame-Treiber-Library stehen Ihnen folgende
    Funktionen zur VerfÅgung:

    @020[FRM_xopen] Initialisieren einer Schnittstelle (eXtended Open)
    @040[FRM_open ] Initialisieren einer Schnittstelle
    @080[FRM_mode ] éndern der Schnittstellenparameter
    @090[FRM_read ] Daten lesen und im Empfangspuffer ablegen
    @100[FRM_rbuf ] Freigeben des Empfangspuffers
    @110[FRM_gbuf ] Anfordern eines Sendepuffers
    @120[FRM_write] Daten im Sendepuffer senden
    @130[FRM_robuf] Freigeben des Sendepuffers
    @140[FRM_close] Deinitialisieren einer Schnittstelle
    @150[FRM_ctrl ] Bedienen der Schnittstelle






                                       @200[ ANHANG ]                      @001[ öbersicht ]
.20
    FRM_xopen - Initialisieren einer Schnittstelle - eXtended Open

    @021[FRM_xopen] (enable,device,mode,config,status,ident)

    Parameter-Datentypen :
    ->  @025[enable   ] : BIT           Der Funktionsblock wird nur ausgefÅhrt, wenn
                                  enable = 1 ist
    ->  @026[device   ] : LONG          An diesem Eingang wird die Adresse eines
                                  Strings Åbergeben, welcher die verwendete
                                  Schnittstelle eindeutig beschreibt.
    ->  @028[mode     ] : LONG          An diesem Eingang wird die Adresse eines
                                  Strings Åbergeben, welcher die verwendete
                                  Schnittstelle parametriert.
    ->  @030[config   ] : LONG          An diesem Eingang kann die Adresse einer
                                  Konfigurationsstruktur Åbergeben werden
                                  (optionale Angabe). Im Standardfall ist
                                  die Definition dieser Struktur nicht not-
                                  wendig.
    <-  @033[status   ] : WORD          Fehlernummer (0 = kein Fehler)


                                     @021[ Fortsetzung ]                   @001[ öbersicht ]
.21
    FRM_xopen - Initialisieren einer Schnittstelle - eXtended Open (Fortsetzung)

    <-  ident     : LONG          Treiberkennung der Schnittstelle (wird fÅr
                                  die anderen Funktionen der Frame-Treiber-
                                  Library benîtigt)

    Bevor Sie mit Hilfe der Funktionen FRM_write() und FRM_read() Daten als
    "Frame" senden und empfangen kînnen, mÅssen die verwendeten Schnittstellen
    initialisiert werden. Die Initialisierung der gewÅnschten Schnittstelle
    erfolgt mit der Funktion FRM_xopen(). Dabei werden u.a. Steckplatz- und
    Schnittstellennummer, Baudrate, Anzahl und Grî·e der Puffer angegeben.
    Mit Hilfe der Funktion FRM_xopen() kînnen bis zu 16 Schnittstellen gleich-
    zeitig betrieben werden.

    ACHTUNG:
    - Voraussetzung fÅr die Verwendung des Funktionsblocks FRM_xopen() ist eine
      RPSSW-Version grî·er oder gleich V1.91.
    - Die Module IF050 und IF060 (passive Schnittstellenmodule) kînnen nur be-
      dient werden, wenn die FRAME-BASIS-Treiber FBIF050.BR (fÅr IF050) und
      FBIF060.BR (fÅr IF060) auf der CPU (Anwender-ROM) vorhanden sind.

                                                                     @001[ öbersicht ]
.25
    FRM_xopen - Initialisieren einer Schnittstelle - eXtended Open (Fortsetzung)

    -> Parameter <enable    >: BIT

    Ist beim Aufruf der Funktion FRM_xopen() der Eingang "enable" gesetzt,
    wird die Schnittstelle initialisiert und die Puffer fÅr den Frame-Treiber
    werden allokiert.
    Nach erfolgreicher AusfÅhrung der Funktion FRM_xopen() mu· der Eingang
    "enable" vom Anwender wieder auf 0 gesetzt werden.












                                      @020[ FRM_xopen ]                    @001[ öbersicht ]
.26
    FRM_xopen - Initialisieren einer Schnittstelle - eXtended Open (Fortsetzung)

    -> Parameter <device    >: LONG

    An diesem Eingang wird die Adresse eines Strings Åbergeben, welcher die
    verwendete Schnittstelle eindeutig beschreibt.

    Format des Strings:
    [SL<x>].[SS<x>].[IF<x>]
    SL: Slot (Steckplatz) mit der Nummer <x>. Die mîglichen Steckplatznummern
        bewegen sich von 0 (CPU-Steckplatz) bis 15 (letzter Systembussteck-
        platz).
    SS: Steckt das Schnittstellenmodul, auf dem sich die Schnittstelle be-
        findet, in einem Einschubsteckplatz (auch "Subslot" genannt), so mu·
        hier die Nummer dieses Einschubsteckplatzes (<x> = 1, 2 oder 3) ange-
        geben werden. So mu· z.B. bei Verwendung eines steckbaren Schnitt-
        stellenmoduls (IF613, IF621, usw.) in einer IF060 fÅr den Einschub-
        steckplatz immer SS1 angegeben werden, da die IF060 nur Åber einen
        Einschubsteckplatz verfÅgt.
    IF: Schnittstelle mit der Nummer <x>.

                                     @027[ Fortsetzung ]                   @001[ öbersicht ]
.27
    FRM_xopen - Initialisieren einer Schnittstelle - eXtended Open (Fortsetzung)

    Als Trennzeichen der Argumente ist ein Punkt (".") vorgeschrieben. Es kann
    aber auch jedes andere Åbliche Trennzeichen verwendet werden.
    Zwischen Gro·- und Kleinschreibung wird nicht unterschieden.

    Beispiele gÅltiger Device-Beschreibungen:
    "IF2"
    "SL5.IF3"
    "SS1.IF1"











                                      @020[ FRM_xopen ]                    @001[ öbersicht ]
.28
    FRM_xopen - Initialisieren einer Schnittstelle - eXtended Open (Fortsetzung)

    -> Parameter <mode      >: LONG

    An diesem Eingang wird die Adresse eines Strings Åbergeben, welcher die
    Schnittstelle parametriert.

    Format des Strings:
    [<Typ>],[<Baudrate>],[<Parity>],[<Datenbits>],[<Stoppbits>],[<Optionen>]

    Typ:       Die Schnittstelle kann als [RS232|RS422|RS485|TTY|RS422BUS] ge-
               îffnet werden, falls dies von der Hardware unterstÅtzt wird.
               Standardeinstellung: RS232
    Baudrate:  Die Schnittstelle kann mit folgenden Baudraten geîffnet werden:
               [300|600|1200|2400|4800|9600|19200|38400|57600|115200]
               Standardeinstellung: 57600
    Parity:    Die Einstellungen [N|O|E|H|L] fÅr no Parity (keine ParitÑt),
               odd Parity (ungerade ParitÑt), even Parity (gerade ParitÑt),
               high forced Parity oder low forced Parity sind mîglich.
               Standardeinstellung: no Parity

                                     @029[ Fortsetzung ]                   @001[ öbersicht ]
.29
    FRM_xopen - Initialisieren einer Schnittstelle - eXtended Open (Fortsetzung)

    Datenbits: Die Einstellungen [7|8] fÅr 7 oder 8 Datenbits sind mîglich.
               Standardeinstellung: 8 Datenbits
    Stoppbits: Die Einstellungen [1|2] fÅr 1 oder 2 Stoppbits sind mîglich.
               Standardeinstellung: 1 Stoppbit
    Optionen:  Wurde als Schnittstellentyp eine RS232 ausgewÑhlt, sind folgende
               Optionen zulÑssig:
               [HW] ... fÅr Hardware-Handshake (RTS/CTS) oder
               [RT] ... fÅr die Steuerung eines externen Kopplers (INT1) mit
                        der RTS-Leitung.

    Als Trennzeichen der Argumente ist ein Punkt (".") vorgeschrieben. Es kann
    aber auch jedes andere Åbliche Trennzeichen verwendet werden.
    Zwischen Gro·- und Kleinschreibung wird nicht unterschieden, die Reihen-
    folge der Parameter hat keine Bedeutung.

    Beispiele gÅltiger Mode-Beschreibungen:
    "19200,7,E,1"
    "RS485,N,8,1,9600"
    "RS232, 38400, HW"
                                      @020[ FRM_xopen ]                    @001[ öbersicht ]
.30
    FRM_xopen - Initialisieren einer Schnittstelle - eXtended Open (Fortsetzung)

    -> Parameter <config    >: LONG

    Mit diesem Eingang kann die Adresse einer Konfigurationsstruktur Åbergeben
    werden (optionale Angabe). Im Standardfall ist die Definition dieser
    Struktur nicht notwendig.

    Elemente der Struktur:
    idle       : WORD           @223[Max. Leerzeit zwischen Zeichen]
                                (Standardwert: 4)
    delimc     : WORD           Freigabe der Frame-Abschlu·zeichen
                                (Standardwert: 0)
    delim      : 2 BYTE (FELD)  @222[Frame-Abschlu·zeichen]
                                (Standardwert: 0,0)
    tx_cnt     : WORD           Anzahl der Sendepuffer (max. 8)
                                (Standardwert: 2)
    rx_cnt     : WORD           Anzahl der Empfangspuffer (max. 8)
                                (Standardwert: 2)


                                     @031[ Fortsetzung ]                   @001[ öbersicht ]
.31
    FRM_xopen - Initialisieren einer Schnittstelle - eXtended Open (Fortsetzung)

    tx_len     : WORD           LÑnge der Sendepuffer
                                (Standardwert: 256 Byte)
    rx_len     : WORD           LÑnge der Empfangspuffer
                                (Standardwert: 256 Byte)
    argc       : WORD           Anzahl zusÑtzlicher Argumente in "argv"
                                (Standardwert: 0)
    @032[argv       ]: LONG           Adresse eines LONG-Feldes mit zusÑtzlichen
                                Argumenten.
                                (Standardwert: 0)










                                      @020[ FRM_xopen ]                    @001[ öbersicht ]
.32
    FRM_xopen - Initialisieren einer Schnittstelle - eXtended Open (Fortsetzung)

    Das Strukturelement "argv" enthÑlt die Adresse eines LONG-Feldes mit zu-
    sÑtzlichen Argumenten. Jedes Argument besteht aus zwei LONG-Elementen.
    Im ersten LONG steht die Argumentnummer, im zweiten LONG steht der Wert
    des Arguments. Folgende Argumente werden ausgewertet:
    …ÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
    ∫  Nr. ≥ Bedeutung                                                        ∫
    ÃÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ
    ∫   0  ≥ Baudrate (hier besteht die Mîglichkeit, unÅbliche Baudraten ein- ∫
    ∫      ≥ zustellen)                                                       ∫
    «ƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
    ∫  15  ≥ Adresse einer RX-Poll-PV (USER-VerstÑndigung: Frame empfangen)   ∫
    «ƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
    ∫  16  ≥ Diverse Flags                                                    ∫
    «ƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
    ∫  17  ≥ Adresse einer TX-Poll-PV (USER-VerstÑndigung: Frame gesendet)    ∫
    «ƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
    ∫ (14) ≥ Nur fÅr das C-Interface von Bedeutung.                           ∫
    ∫      ≥ USER-VerstÑndigung Åber ein Event: Frame empfangen.              ∫
    »ÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº
                                       @031[ ZurÅck ]                      @001[ öbersicht ]
.33
    FRM_xopen - Initialisieren einer Schnittstelle - eXtended Open (Fortsetzung)

    <- Parameter <status    >: WORD

    Fehlernummern der Funktion FRM_xopen():
    258     Frame-Treiber ist nicht geladen
    3008    Frame-Treiber ist nicht geladen
    8074    Referenziertes Device existiert nicht bzw. FRAME-BASIS-Treiber fÅr
            die IF050/IF060 ist nicht geladen
    8252    Syntax-Fehler im Device-String (siehe Parameter "device")
    8253    Syntax-Fehler im Mode-String (siehe Parameter "mode")
    8254    Die maximale Anzahl gleichzeitig geîffneter Devices wurde Åber-
            schritten
    8255    RPSSW-Version zu alt (es mu· eine RPSSW-Version grî·er oder gleich
            V1.91 verwendet werden)
    14808   Eine Einstellung im Mode-String (siehe Parameter "mode") wird von
            der Schnittstelle nicht unterstÅtzt

    Eine Liste aller mîglichen Fehlermeldungen der Frame-Treiber-Library finden
    Sie im Anhang @300[Fehlermeldungen].

                                      @020[ FRM_xopen ]                    @001[ öbersicht ]
.40
    FRM_open - Initialisieren einer Schnittstelle

    @041[FRM_open] (enable,dvnr,frmdelim,baud,mode,rxbufcnt,txbufcnt,rxbuflng,
              txbuflng,arginfo,adr(argliste),status,ident)

    Parameter-Datentypen :
    ->  @045[enable   ] : BIT           Der Funktionsblock wird nur ausgefÅhrt, wenn
                                  enable = 1 ist
    ->  @046[dvnr     ] : BYTE          Nummer der verwendeten Schnittstelle
    ->  @055[frmdelim ] : LONG          Frame-Abschlu·zeichen
    ->  @056[baud     ] : WORD          Baudrate
    ->  @057[mode     ] : LONG          Schnittstellenkonfiguration
    ->  @062[rxbufcnt ] : WORD          Anzahl der Empfangspuffer (RX)
    ->  @062[txbufcnt ] : WORD          Anzahl der Sendepuffer (TX)
    ->  @063[rxbuflng ] : WORD          Maximale LÑnge des Empfangspuffers
    ->  @063[txbuflng ] : WORD          Maximale LÑnge des Sendepuffers
    ->  @064[arginfo  ] : LONG          Anzahl der zusÑtzlichen Parameter in
                                  "argliste"
    ->  @064[argliste ] : LONG (FELD)   Liste der zusÑtzlichen Parameter als Feld
                                  (erweiterte Parameterdefinition)

                                     @041[ Fortsetzung ]                   @001[ öbersicht ]
.41
    FRM_open - Initialisieren einer Schnittstelle (Fortsetzung)

    <-  @073[status   ] : WORD          Fehlernummer (0 = kein Fehler)
    <-  ident     : LONG          Treiberkennung der Schnittstelle (wird fÅr
                                  die anderen Funktionen der Frame-Treiber-
                                  Library benîtigt)

    Bevor Sie mit Hilfe der Funktionen FRM_write() und FRM_read() Daten als
    "Frame" senden und empfangen kînnen, mÅssen die verwendeten Schnittstellen
    initialisiert werden. Die Initialisierung der gewÅnschten Schnittstelle
    kann mit der Funktion FRM_open() erfolgen. Dabei werden u.a. Steckplatz-
    und Schnittstellennummer, Baudrate, Anzahl und Grî·e der Puffer angegeben.

    ACHTUNG:
    - Die Funktion FRM_open() kann nur verwendet werden, wenn der Frame-Treiber
      DVFRAME.BR bzw. der Frame-Treiber DVFRAME3.BR (fÅr IF050-Schnittstellen)
      auf der CPU (Anwender-ROM) vorhanden ist!
    - Ab Version V3.10 der Frame-Treiber-Library und Version V1.91 der RPSSW
      kann zum Initialisieren der Schnittstellen auch die Funktion FRM_xopen()
      verwendet werden.

                                      @042[ Beispiel ]                     @001[ öbersicht ]
.42
    FRM_open - Initialisieren einer Schnittstelle (Beispiel)

    Wir verwenden das System B&R 2010. Die Daten werden Åber die untere
    Schnittstelle (RS232) der Zentraleinheit gesendet/empfangen. FÅr die
    anderen Eingangsparameter setzen wir einfach Standardwerte ein:

      ; Standard-Initialisierung z.B. im INIT-UP der Task
      dvnr = 1                ; B&R 2010: untere Schnittstelle (RS232)
      frmdelim = 0            ; Frame Åber Zeichenverzugszeit
      baud = 96               ; Baudrate 9600
      mode = $0101            ; keine ParitÑt, 8 Datenbits, 1 Stoppbit
      rxbufcnt = 1            ; 1 Empfangspuffer
      txbufcnt = 1            ; 1 Sendepuffer
      rxbuflng = $0010        ; 16 Byte Empfangspuffer
      txbuflng = $0080        ; 128 Byte Sendepuffer
      arginfo = 0             ; keine zusÑtzlichen Parameter





                               @043[ Fortsetzung - Beispiel ]              @001[ öbersicht ]
.43
    FRM_open - Initialisieren einer Schnittstelle (Beispiel - Fortsetzung)

      ; ôFFNEN der gewÅnschten Schnittstelle
      ; Voraussetzung fÅr die Abarbeitung aller weiteren Frame-Treiber-
      ; Funktionen ist ein fehlerfreies ôffnen (opnstatus = 0) !!!
      if open = 0 then
          FRM_open(1,dvnr,frmdelim,baud,mode,rxbufcnt,txbufcnt,rxbuflng,
                   txbuflng,arginfo,adr(argliste),opnstatus,frmident)
          open = 1
      endif











                                                                     @001[ öbersicht ]
.45
    FRM_open - Initialisieren einer Schnittstelle (Fortsetzung)

    -> Parameter <enable    >: BIT

    Ist beim Aufruf der Funktion FRM_open() der Eingang "enable" gesetzt,
    wird die Schnittstelle initialisiert und die Puffer fÅr den Frame-Treiber
    werden allokiert.














                                      @040[ FRM_open ]                     @001[ öbersicht ]
.46
    FRM_open - Initialisieren einer Schnittstelle (Fortsetzung)

    -> Parameter <dvnr      >: BYTE

    Schnittstellennummer:
    …ÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕª
    ∫ Modul ≥ Schnittstelle             ≥ dvnr ≥ Typ             ≥ Treiber     ∫
    ÃÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕπ
    ∫ CP100 ≥ IF1 (oberes Interface)    ≥ 0    ≥ RS232           ≥ DVFRAME.BR  ∫
    ∫       ≥ IF3 (mittleres Interface) ≥ 2    ≥ RS485/RS422     ≥ DVFRAME.BR  ∫
    ∫       ≥ IF2 (unteres Interface)   ≥ 1    ≥ RS232/TTY       ≥ DVFRAME.BR  ∫
    ÃÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕπ
    ∫ CP200 ≥ IF1 (oberes Interface)    ≥ 0    ≥ RS232           ≥ DVFRAME.BR  ∫
    ∫       ≥ IF3 (mittleres Interface) ≥ 2    ≥ RS485/RS422     ≥ DVFRAME.BR  ∫
    ∫       ≥ IF2 (unteres Interface)   ≥ 1    ≥ RS232           ≥ DVFRAME.BR  ∫
    ÃÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕπ
    ∫ CP104 ≥ IF1 (oberes Interface)    ≥ 0    ≥ RS232           ≥ DVFRAME.BR  ∫
    ∫       ≥ IF2 (unteres Interface)   ≥ 1    ≥ RS232/TTY       ≥ DVFRAME.BR  ∫
    »ÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕº


                                     @047[ Fortsetzung ]                   @001[ öbersicht ]
.47
    FRM_open - Initialisieren einer Schnittstelle (Fortsetzung)

    Schnittstellennummer (Fortsetzung):
    …ÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕª
    ∫ Modul ≥ Schnittstelle             ≥ dvnr ≥ Typ             ≥ Treiber     ∫
    ÃÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕπ
    ∫ IF10x ≥ IF1                       ≥ 0    ≥ RS232           ≥ DVFRAME.BR  ∫
    ∫       ≥ IF3                       ≥ 2    ≥ RS485/RS422/RIO ≥ DVFRAME.BR  ∫
    ∫       ≥ IF2                       ≥ 1    ≥ RS232/TTY       ≥ DVFRAME.BR  ∫
    ÃÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕπ
    ∫ MP100 ≥ IF1 (oberes Interface)    ≥ 0    ≥ RS232           ≥ DVFRAME.BR  ∫
    ∫       ≥ IF3 (unteres Interface)   ≥ 2    ≥ RS485/RS422     ≥ DVFRAME.BR  ∫
    ÃÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕπ
    ∫ CP15x ≥ IF2 (oberes Interface)    ≥ 1    ≥ RS485/RS422/TTY ≥ DVFRAME.BR  ∫
    ∫       ≥ IF1 (unteres Interface)   ≥ 0    ≥ RS232           ≥ DVFRAME.BR  ∫
    ÃÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕπ
    ∫ XP152 ≥ unteres Interface         ≥ 0    ≥ RS232           ≥ DVFRAME.BR  ∫
    ÃÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕπ
    ∫ IP151 ≥ unteres Interface         ≥ 0    ≥ RS232           ≥ DVFRAME.BR  ∫
    »ÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕº

                                     @048[ Fortsetzung ]                   @001[ öbersicht ]
.48
    FRM_open - Initialisieren einer Schnittstelle (Fortsetzung)

    Schnittstellennummer (Fortsetzung):
    …ÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕª
    ∫ Modul ≥ Schnittstelle             ≥ dvnr ≥ Typ             ≥ Treiber     ∫
    ÃÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕπ
    ∫ IF152 ≥ unteres Interface         ≥ 0    ≥ RS232           ≥ DVFRAME.BR  ∫
    ÃÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕπ
    ∫ CP470 ≥ RS232-Schnittstelle       ≥ 0    ≥ RS232           ≥ DVFRAME.BR  ∫
    ÃÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕπ
    ∫ CP770 ≥ RS232-Schnittstelle       ≥ 0    ≥ RS232           ≥ DVFRAME.BR  ∫
    ÃÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕπ
    ∫ CP474 ≥ RS232-Schnittstelle       ≥ 0    ≥ RS232           ≥ DVFRAME.BR  ∫
    ∫       ≥ Schnittstellenmodul auf   ≥      ≥ RS232 bzw.      ≥             ∫
    ∫       ≥ Steckplatz 1              ≥ 1    ≥ RS485/RS422     ≥ DVFRAME.BR  ∫
    ∫       ≥ Schnittstellenmodul auf   ≥      ≥ RS232 bzw.      ≥             ∫
    ∫       ≥ Steckplatz 2              ≥ 2    ≥ RS485/RS422     ≥ DVFRAME.BR  ∫
    »ÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕº



                                     @049[ Fortsetzung ]                   @001[ öbersicht ]
.49
    FRM_open - Initialisieren einer Schnittstelle (Fortsetzung)

    Schnittstellennummer (Fortsetzung):
    …ÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕª
    ∫ Modul ≥ Schnittstelle             ≥ dvnr ≥ Typ             ≥ Treiber     ∫
    ÃÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕπ
    ∫ CP774 ≥ RS232-Schnittstelle       ≥ 0    ≥ RS232           ≥ DVFRAME.BR  ∫
    ∫       ≥ Schnittstellenmodul auf   ≥      ≥ RS232 bzw.      ≥             ∫
    ∫       ≥ Steckplatz 1              ≥ 1    ≥ RS485/RS422     ≥ DVFRAME.BR  ∫
    ∫       ≥ Schnittstellenmodul auf   ≥      ≥ RS232 bzw.      ≥             ∫
    ∫       ≥ Steckplatz 2              ≥ 2    ≥ RS485/RS422     ≥ DVFRAME.BR  ∫
    ÃÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕπ
    ∫ IF050 ≥ IF1 (oberes Interface)    ≥ 3    ≥ RS232           ≥ DVFRAME3.BR ∫
    ∫ @050[(1)]   ≥ IF3 (mittleres Interface) ≥ 5    ≥ RS485/RS422     ≥ DVFRAME3.BR ∫
    ∫       ≥ IF2 (unteres Interface)   ≥ 4    ≥ RS232/TTY       ≥ DVFRAME3.BR ∫
    ÃÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕπ
    ∫ IF050 ≥ IF1 (oberes Interface)    ≥ 6    ≥ RS232           ≥ DVFRAME3.BR ∫
    ∫ @050[(2)]   ≥ IF3 (mittleres Interface) ≥ 8    ≥ RS485/RS422     ≥ DVFRAME3.BR ∫
    ∫       ≥ IF2 (unteres Interface)   ≥ 7    ≥ RS232/TTY       ≥ DVFRAME3.BR ∫
    »ÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕº

                                     @050[ Fortsetzung ]                   @001[ öbersicht ]
.50
    FRM_open - Initialisieren einer Schnittstelle (Fortsetzung)

    Schnittstellenmodul IF050:
    Das Schnittstellenmodul IF050 verfÅgt Åber drei serielle Schnittstellen.
    Der Anwender kann das Schnittstellenmodul IF050 an eine beliebige Position
    der BasisrÅckwand stecken, es kînnen auch mehrere Schnittstellenmodule ver-
    wendet werden. FÅr die Ermittlung der Schnittstellennummern mÅssen Sie die
    Schnittstellenmodule von der Zentraleinheit ausgehend durchnumerieren. Das
    Schnittstellenmodul, das am weitesten links steckt (wird als IF050 (1) be-
    zeichnet) erhÑlt die Schnittstellennummern 3, 4 und 5, das nÑchste Schnitt-
    stellenmodul (wird als IF050 (2) bezeichnet) erhÑlt die Schnittstellen-
    nummern 6, 7 und 8, usw.









                                     @051[ Fortsetzung ]                   @001[ öbersicht ]
.51
    FRM_open - Initialisieren einer Schnittstelle (Fortsetzung)

    Beispiel:
      ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ Netzteil
      ≥   ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒ Zentraleinheit
      ≥   ≥  ⁄ƒƒƒƒƒƒƒƒƒƒƒ I/O-Modul
      ≥   ≥  ≥ ⁄ƒƒƒƒƒƒƒƒƒ Schnittstellenmodul IF050 (1):
      ≥   ≥  ≥ ≥             IF1 ... Schnittstellennummer ("dvnr") 3
      ≥   ≥  ≥ ≥             IF3 ... Schnittstellennummer ("dvnr") 5
      ≥   ≥  ≥ ≥             IF2 ... Schnittstellennummer ("dvnr") 4
      ≥   ≥  ≥ ≥ ⁄ƒƒƒƒƒƒƒ I/O-Modul
      ≥   ≥  ≥ ≥ ≥ ⁄ƒƒƒƒƒ I/O-Modul
      ≥   ≥  ≥ ≥ ≥ ≥ ⁄ƒƒƒ Schnittstellenmodul IF050 (2):
    ⁄ƒƒƒ¬ƒƒƒ¬ƒ¬ƒ¬ƒ¬ƒ¬ƒø      IF1 ... Schnittstellennummer ("dvnr") 6
    ≥   ≥   ≥ ≥ ≥ ≥ ≥ ≥      IF3 ... Schnittstellennummer ("dvnr") 8
    ≥   ≥   ≥ ≥ ≥ ≥ ≥ ≥      IF2 ... Schnittstellennummer ("dvnr") 7
    ¿ƒƒƒ¡ƒƒƒ¡ƒ¡ƒ¡ƒ¡ƒ¡ƒŸ




                                     @052[ Fortsetzung ]                   @001[ öbersicht ]
.52
    FRM_open - Initialisieren einer Schnittstelle (Fortsetzung)

    Folgende EinschrÑnkungen gelten derzeit fÅr die IF050 (Wenn Sie die Funk-
    tion FRM_xopen() verwenden, sind die unten angefÅhrten EinschrÑnkungen
    hinfÑllig):

    - FÅr die Bedienung eines IF050-Moduls mu· der Frame-Treiber DVFRAME3.BR
      (unterstÅtzt die Schnittstellennummern 3 bis 8) auf die Zentraleinheit
      (Anwender-ROM) geladen werden.
      Es werden derzeit nur zwei Schnittstellenmodule unterstÅtzt. Dies ist
      allerdings eine Software-EinschrÑnkung, auf Anfrage sind Treiber zur
      UnterstÅtzung von weiteren Schnittstellenmodulen erhÑltlich.

    - öber die CPU-Schnittstellen kînnen mit der Funktion FRM_write() auch
      Puffer gesendet werden, welche nicht vom Frame-Treiber verwaltet werden
      (sinnvoll bei konstanten Frames bzw. konstanten Texten). Dies ist beim
      Schnittstellenmodul IF050 nicht zulÑssig! Beim Modul IF050 mÅssen alle
      Puffer vor dem Senden mit FRM_write() mit der Funktion FRM_gbuf() ange-
      fordert werden.


                                     @053[ Fortsetzung ]                   @001[ öbersicht ]
.53
    FRM_open - Initialisieren einer Schnittstelle (Fortsetzung)

    EinschrÑnkungen fÅr die IF050 (Fortsetzung):

    - Das IF050-Schnittstellenmodul verfÅgt Åber 576 Byte Pufferspeicher fÅr
      alle drei Schnittstellen. Dieser Pufferbereich wird gleichmÑ·ig auf die
      drei Schnittstellen des Moduls aufgeteilt (6 Byte Reserve fÅr eine
      eventuelle Verwaltung). D.h. pro IF050-Schnittstelle stehen 190 Byte
      Pufferspeicher zur VerfÅgung. Die Anzahl der Empfangspuffer mal deren
      LÑnge addiert mit der Anzahl der Sendepuffer mal deren LÑnge ist also
      auf 190 Byte limitiert.

    - Aus Hardware-GrÅnden dauert die Interrupt-Behandlung fÅr IF050-Module
      deutlich lÑnger als fÅr die CPU-Schnittstellen.







                                     @054[ Fortsetzung ]                   @001[ öbersicht ]
.54
    FRM_open - Initialisieren einer Schnittstelle (Fortsetzung)

    EinschrÑnkungen fÅr die IF050 (Fortsetzung):

    - Achtung: Wird der Frame-Treiber fÅr die IF050- und die CPU-Schnittstellen
      verwendet, dann mu· der Stack fÅr die Taskklassen in der System-
      konfiguration um mindestens 256 Byte erhîht werden.

    - Ab der Version 2.10 des Frame-Treibers ist es nach dem Stecken eines
      neuen IF050-Moduls nicht mehr nîtig, einen KALTSTART (alte Bezeichnung:
      TOTALINIT) auszulîsen. D.h. neue Schnittstellenmodule kînnen ab dieser
      Treiber-Version auch wÑhrend des normalen RPS-Betriebs (vor dem Aufruf
      der Funktion FRM_open()) gesteckt werden. Dabei gelten jedoch folgende
      EinschrÑnkungen:
      1. Wenn ein IF050-Schnittstellenmodul auf einer Position steckt, darf
         dieses Modul erst nach Aufruf der Funktion FRM_close() wieder von
         diesem Steckplatz entfernt werden.
      2. Jeder weitere Steckversuch der IF050 (nach einer erfolgreichen Be-
         dienung) mu· auf demselben Steckplatz durchgefÅhrt werden.
      3. Eine Fehlbedienung fÅhrt zu einer Exception und zum Nothalt des
         Systems.
                                      @040[ FRM_open ]                     @001[ öbersicht ]
.55
    FRM_open - Initialisieren einer Schnittstelle (Fortsetzung)

    -> Parameter <frmdelim  >: LONG

    Definition des Frame-Abschlusses (Frame-Begrenzung):
    ⁄ƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒø
    ≥EEEEEEEE≥DDDDDDDD≥CBAAAAAA≥AAAAAAAA≥
    ¿ƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒŸ

    A ... Bit 0 bis 13:   @223[Max. Leerzeit zwischen Zeichen] (0 = Standardwert 4)
    B ... Bit 14:         Freigabe fÅr Frame-Abschlu·zeichen 1
    C ... Bit 15:         Freigabe fÅr Frame-Abschlu·zeichen 2
    D ... Bit 16 bis 23:  @222[Frame-Abschlu·zeichen 1]
    E ... Bit 24 bis 31:  @222[Frame-Abschlu·zeichen 2]

    Wir unterscheiden zwischen der Frame-Begrenzung beim Empfangen und der
    Frame-Begrenzung beim Senden:

    * @221[Frame-Begrenzung beim Empfangen]
    * @225[Frame-Begrenzung beim Senden   ]

                                      @040[ FRM_open ]                     @001[ öbersicht ]
.56
    FRM_open - Initialisieren einer Schnittstelle (Fortsetzung)

    -> Parameter <baud      >: WORD

    Mit dem Parameter "baud" wird die Baudrate festgelegt. Die Baudrate wird
    in Einheiten zu 100 Baud (z.B. 192 = 19200 Baud) angegeben. Wird fÅr den
    Parameter "baud" der Wert 0 angegeben, wird die Standardeinstellung der
    Schnittstelle verwendet.
        24 ..... 2400 Baud
        48 ..... 4800 Baud
        96 ..... 9600 Baud
       192 .... 19200 Baud
       384 .... 38400 Baud
       576 .... 57600 Baud
      1152 ... 115200 Baud
      3470 ... 347000 Baud

    RS232-Schnittstelle:        Baudrate < 115200 Baud
    RS422/RS485-Schnittstelle:  Baudrate < 347000 Baud


                                      @040[ FRM_open ]                     @001[ öbersicht ]
.57
    FRM_open - Initialisieren einer Schnittstelle (Fortsetzung)

    -> Parameter <mode      >: LONG

    Grundlegende Schnittstellenparameter:
    ⁄ƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒø
    ≥JI000000≥00H0GGGG≥F0ED000C≥0B00000A≥
    ¿ƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒŸ

    A,B,C,D,E und F ... Bit 0 bis 15:    @058[Asynchrone Parameter              ]
    G ................. Bit 16 bis 19:   @059[Schnittstellenkonfiguration       ]
    H ................. Bit 21:          @060[Schnittstellenkonfiguration       ]
    I und J ........... Bit 30 bis 31:   @061[Handshake auf RS232-Schnittstellen]








                                      @040[ FRM_open ]                     @001[ öbersicht ]
.58
    FRM_open - Initialisieren einer Schnittstelle (Fortsetzung)

    Asynchrone Parameter:
    …ÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
    ∫ Bit-Nummer ≥ Bedeutung                                                  ∫
    ÃÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ
    ∫ Bit 0      ≥ Freigabe fÅr asynchrone Parameter (1 = Freigabe)           ∫
    «ƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
    ∫ Bit 6      ≥ Stoppbit (0 = 1 Stoppbit / 1 = 2 Stoppbits)                ∫
    «ƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
    ∫ Bit 8      ≥ Datenbits (0 = 7 Datenbits / 1 = 8 Datenbits)              ∫
    «ƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
    ∫ Bit 12     ≥ ParitÑt (0 = keine ParitÑt / 1 = ParitÑt verwendet)        ∫
    «ƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
    ∫ Bit 13     ≥ Empfangs-ParitÑt (0 = ungerade / 1 = gerade)               ∫
    «ƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
    ∫ Bit 14     ≥ immer 0                                                    ∫
    «ƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
    ∫ Bit 15     ≥ Sende-ParitÑt (0 = ungerade / 1 = gerade)                  ∫
    »ÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº

                                       @057[ ZurÅck ]                      @001[ öbersicht ]
.59
    FRM_open - Initialisieren einer Schnittstelle (Fortsetzung)

    Schnittstellenkonfiguration:
    …ÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
    ∫ Bit-Nummer ≥ Bedeutung                                                  ∫
    ÃÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ
    ∫ Bit 16     ≥ 0, 1 ... Standardkonfiguration: RS232 bzw. RS422           ∫
    «ƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
    ∫ Bit 17     ≥ 1 ...... RS485 fÅr 2010/dvnr = 2                           ∫
    ∫            ≥          RS485 fÅr 2005/dvnr = 1                           ∫
    ∫            ≥          RS485 fÅr IF050/dvnr = 2 + 3n, wobei n = Nummer   ∫
    ∫            ≥          der IF050 (beginnend bei 0)                       ∫
    «ƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
    ∫ Bit 18     ≥ 1 ...... doppelte RS485 (d.h. Transmitter ist nicht        ∫
    ∫            ≥          dauernd eingeschaltet, Vierdrahtleitung)          ∫
    «ƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
    ∫ Bit 19     ≥ 1 ...... TTY fÅr 2005/dvnr = 1 (fÅr 2010 funktioniert die  ∫
    ∫            ≥          TTY in der derzeitigen Version nicht)             ∫
    »ÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº


                                     @060[ Fortsetzung ]                   @001[ öbersicht ]
.60
    FRM_open - Initialisieren einer Schnittstelle (Fortsetzung)

    Schnittstellenkonfiguration (Fortsetzung):
    …ÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
    ∫ Bit-Nummer ≥ Bedeutung                                                  ∫
    ÃÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ
    ∫ Bit 21     ≥ 1 ...... explizite RS422-Einstellung (fÅr C200/C220 un-    ∫
    ∫            ≥          bedingt notwendig)                                ∫
    »ÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº

    Bis Frame-Treiber V2.40 werden Fehler, die durch falsche Konfiguration auf-
    treten (z.B. dvnr=0 und RS485) noch nicht abgefangen und kînnen zu einem
    Fehlverhalten fÅhren. Die Schnittstellenkonfiguration wird unabhÑngig von
    Bit 0 der Variable "mode" Åbernommen.
    Ab RPSSW V1.91 und Frame-Treiber V3.00 werden fehlerhafte Konfigurationen
    vom Treiber erkannt und abgelehnt!





                                       @057[ ZurÅck ]                      @001[ öbersicht ]
.61
    FRM_open - Initialisieren einer Schnittstelle (Fortsetzung)

    Handshake auf RS232-Schnittstellen:
    …ÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
    ∫ Bit-Nummer ≥ Bedeutung                                                  ∫
    ÃÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ
    ∫ Bit 30     ≥ 1 = Hardware-Handshake (RTS/CTS)                           ∫
    ∫            ≥ Mit Hilfe der CTS-Leitung kann eine laufende öbertragung   ∫
    ∫            ≥ des Treibers "eingefroren" werden, sie wird nach Freigabe  ∫
    ∫            ≥ Åber die CTS-Leitung wieder fortgesetzt. Der Treiber von   ∫
    ∫            ≥ sich aus behandelt den Inputoverflow-Fehler noch nicht mit ∫
    ∫            ≥ der RTS-Leitung.                                           ∫
    «ƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
    ∫ Bit 31     ≥ 1 = Software-Handshake                                     ∫
    ∫            ≥ Mit Hilfe der XON/XOFF-Kontrollzeichen wird die laufende   ∫
    ∫            ≥ öbertragung des Treibers "eingefroren" und wieder "auf-    ∫
    ∫            ≥ getaut".                                                   ∫
    ∫            ≥ Ab Version V3.00 des Frame-Treibers und Version V1.91 des  ∫
    ∫            ≥ Betriebssystems RPSSW wird das Software-Handshake nicht    ∫
    ∫            ≥ mehr unterstÅtzt!                                          ∫
    »ÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº
                                       @057[ ZurÅck ]                      @001[ öbersicht ]
.62
    FRM_open - Initialisieren einer Schnittstelle (Fortsetzung)

    -> Parameter <rxbufcnt  >: WORD

    Anzahl der Empfangspuffer (1 bis 8).

    -> Parameter <txbufcnt  >: WORD

    Anzahl der Sendepuffer (1 bis 8). Die öbertragung erfolgt asynchron (!)
    zum Aufrufer. D.h. wenn der Parameter "status" der Funktion FRM_write()
    0 ist, bedeutet das noch nicht, da· der Puffer auch wirklich Åbertragen
    worden ist.

    ACHTUNG:
    Wenn eine RS485 bzw. ein RS422-Netzwerk verwendet wird, dann dÅrfen NIE
    mehrere Puffer gleichzeitig in Senderichtung beauftragt werden.
    Ab Version V3.00 des Frame-Treibers und Version V1.91 der RPSSW ist diese
    EinschrÑnkung aufgehoben.



                                      @040[ FRM_open ]                     @001[ öbersicht ]
.63
    FRM_open - Initialisieren einer Schnittstelle (Fortsetzung)

    -> Parameter <rxbuflng  >: WORD

    Maximale LÑnge des Empfangspuffers (1 bis 2048).
    Beim Schnittstellenmodul IF050 stehen pro Schnittstelle nur 190 Byte
    Pufferspeicher zur VerfÅgung. D.h. die Anzahl der Empfangspuffer mal
    deren LÑnge addiert mit der Anzahl der Sendepuffer mal deren LÑnge ist
    auf 190 Byte limitiert.

    -> Parameter <txbuflng  >: WORD

    Maximale LÑnge des Sendepuffers (1 bis 2048).
    Beim Schnittstellenmodul IF050 stehen pro Schnittstelle nur 190 Byte
    Pufferspeicher zur VerfÅgung. D.h. die Anzahl der Empfangspuffer mal
    deren LÑnge addiert mit der Anzahl der Sendepuffer mal deren LÑnge ist
    auf 190 Byte limitiert.




                                      @040[ FRM_open ]                     @001[ öbersicht ]
.64
    FRM_open - Initialisieren einer Schnittstelle (Fortsetzung)

    -> Parameter <arginfo   >: LONG

    und

    -> Parameter <argliste  >: LONG (FELD)

    Diese beiden Eingangsparameter gehîren zusammen. Sie ermîglichen eine er-
    weiterte Parameterdefinition. Die meisten Eingangsparameter kînnen sowohl
    "normal" (siehe Eingangsparameter der Funktion FRM_open()) als auch in
    "argliste" definiert werden. Ist ein Parameter doppelt parametriert, hat
    die Angabe in "argliste" Vorrang. Der Eingang "arginfo" gibt die Anzahl der
    Parameter in "argliste" an. "argliste" ist ein LONG-Feld, das in Werte-
    Paare unterteilt ist. Der erste LONG-Wert ist die Nummer des Parameters,
    der zweite LONG-Wert ist der Parameter selbst. Wenn die Eingangsparameter
    "arginfo" und "argliste" nicht verwendet werden, sollten sie immer auf 0
    gesetzt werden.



                                     @065[ Fortsetzung ]                   @001[ öbersicht ]
.65
    FRM_open - Initialisieren einer Schnittstelle (Fortsetzung)

    …ÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
    ∫ Nr. ≥ Bedeutung         ≥ Detailbeschreibung                            ∫
    ÃÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ
    ∫  0  ≥ Baudrate          ≥ Baudrate in 100er-Schritten (96 = 9600 Baud)  ∫
    «ƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
    ∫  1  ≥ Asynchrone        ≥ Bit 6 ... Stoppbit                            ∫
    ∫     ≥ Parameter         ≥           (0 = 1 Stoppbit / 1 = 2 Stoppbits)  ∫
    ∫     ≥                   ≥ Bit 8 ... Datenbits                           ∫
    ∫     ≥                   ≥           (0 = 7 Datenbits / 1 = 8 Datenbits) ∫
    ∫     ≥                   ≥ Bit 12 .. ParitÑt                             ∫
    ∫     ≥                   ≥           (0 = aus / 1 = ein)                 ∫
    ∫     ≥                   ≥ Bit 13 .. Empfangs-ParitÑt                    ∫
    ∫     ≥                   ≥           (0 = ungerade / 1 = gerade)         ∫
    ∫     ≥                   ≥ Bit 15 .. Sende-ParitÑt                       ∫
    ∫     ≥                   ≥           (0 = ungerade / 1 = gerade)         ∫
    »ÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº



                                     @066[ Fortsetzung ]                   @001[ öbersicht ]
.66
    FRM_open - Initialisieren einer Schnittstelle (Fortsetzung)

    …ÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
    ∫ Nr. ≥ Bedeutung         ≥ Detailbeschreibung                            ∫
    ÃÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ
    ∫  2  ≥ Frame-            ≥ Frame-Abschlu·zeichen 1 im High Word.         ∫
    ∫     ≥ Abschlu·zeichen   ≥ Frame-Abschlu·zeichen 2 im Low Word. Wenn das ∫
    ∫     ≥                   ≥ zweite Frame-Abschlu·zeichen nicht verwendet  ∫
    ∫     ≥                   ≥ wird, mu· der Wert auf $8000 gesetzt werden.  ∫
    «ƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
    ∫  3  ≥ Frame-            ≥ Frame-Abschlu·zeichen 3 im High Word.         ∫
    ∫     ≥ Abschlu·zeichen   ≥ Frame-Abschlu·zeichen 4 im Low Word. Wenn das ∫
    ∫     ≥                   ≥ vierte Frame-Abschlu·zeichen nicht verwendet  ∫
    ∫     ≥                   ≥ wird, mu· der Wert auf $8000 gesetzt werden.  ∫
    »ÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº






                                     @067[ Fortsetzung ]                   @001[ öbersicht ]
.67
    FRM_open - Initialisieren einer Schnittstelle (Fortsetzung)

    …ÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
    ∫ Nr. ≥ Bedeutung         ≥ Detailbeschreibung                            ∫
    ÃÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ
    ∫  4  ≥ Leerzeit          ≥ Max. Leerzeit zwischen Zeichen.               ∫
    ∫     ≥                   ≥ Die Zeit zwischen dem Empfang zweier aufein-  ∫
    ∫     ≥                   ≥ anderfolgender Zeichen wird "Leerzeit" oder   ∫
    ∫     ≥                   ≥ "Idle-Zeit" genannt. öberschreitet diese Zeit ∫
    ∫     ≥                   ≥ den bei der Parametrierung eingestellten      ∫
    ∫     ≥                   ≥ Maximalwert, nimmt der Frame-Treiber an, da·  ∫
    ∫     ≥                   ≥ der Frame vollstÑndig ist. Als Einheit fÅr    ∫
    ∫     ≥                   ≥ die Leerzeit wird die LÑnge eines Zeichens    ∫
    ∫     ≥                   ≥ verwendet.                                    ∫
    »ÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº






                                     @068[ Fortsetzung ]                   @001[ öbersicht ]
.68
    FRM_open - Initialisieren einer Schnittstelle (Fortsetzung)

    …ÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
    ∫ Nr. ≥ Bedeutung         ≥ Detailbeschreibung                            ∫
    ÃÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ
    ∫  5  ≥ Handshake         ≥ $00001000 ... Hardware-Handshake RTS/CTS      ∫
    ∫     ≥                   ≥ $00002000 ... Software-Handshake XON/XOFF     ∫
    ∫     ≥                   ≥ $00004000 ... RTS-Bedienung beim Senden       ∫
    ∫     ≥                   ≥ Diese Option kann zum Schalten eines RS485-   ∫
    ∫     ≥                   ≥ Kopplers (z.B. INT1) verwendet werden. Die    ∫
    ∫     ≥                   ≥ Option wird ab Version V3.00 des Frame-       ∫
    ∫     ≥                   ≥ Treibers und Version V1.91 der RPSSW nicht    ∫
    ∫     ≥                   ≥ mehr unterstÅtzt.                             ∫
    ∫     ≥                   ≥ $00008000 ... RTS ohne Receive beim Senden    ∫
    «ƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
    ∫  6  ≥ rxbuflng          ≥ Maximale LÑnge des Empfangspuffers            ∫
    «ƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
    ∫  7  ≥ txbuflng          ≥ Maximale LÑnge des Sendepuffers               ∫
    «ƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
    ∫  8  ≥ rxbufcnt          ≥ Anzahl der Empfangspuffer                     ∫
    »ÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº
                                     @069[ Fortsetzung ]                   @001[ öbersicht ]
.69
    FRM_open - Initialisieren einer Schnittstelle (Fortsetzung)

    …ÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
    ∫ Nr. ≥ Bedeutung         ≥ Detailbeschreibung                            ∫
    ÃÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ
    ∫  9  ≥ txbufcnt          ≥ Anzahl der Sendepuffer                        ∫
    «ƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
    ∫ 10  ≥ Schnittstellentyp ≥ Bit 1 ... 0 = RS232, 1 = RS485                ∫
    ∫     ≥                   ≥ Bit 2 ... 1 = Vierdraht-RS485 (RS422-BUS)     ∫
    ∫     ≥                   ≥ Bit 3 ... 1 = TTY                             ∫
    ∫     ≥                   ≥ Bit 4 ... reserviert                          ∫
    ∫     ≥                   ≥ Bit 5 ... 1 = RS422                           ∫
    «ƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
    ∫ 11  ≥ Multidrop         ≥ Adressen fÅr Multidrop                        ∫
    ∫     ≥                   ≥ (derzeit noch nicht implementiert)            ∫
    «ƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
    ∫ 12  ≥ Callout           ≥ Feld von AussprÅngen (wird ab Version V3.00   ∫
    ∫     ≥                   ≥ des Frame-Treibers und Version V1.91 der      ∫
    ∫     ≥                   ≥ RPSSW nicht mehr unterstÅtzt)                 ∫
    »ÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº

                                     @070[ Fortsetzung ]                   @001[ öbersicht ]
.70
    FRM_open - Initialisieren einer Schnittstelle (Fortsetzung)

    …ÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
    ∫ Nr. ≥ Bedeutung         ≥ Detailbeschreibung                            ∫
    ÃÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ
    ∫ 13  ≥ Restore           ≥ $00000000 ... @141[Restore-FunktionalitÑt]          ∫
    «ƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
    ∫ 14  ≥ Eventtask         ≥ Event wird auf eine fixe Task umgeleitet:     ∫
    ∫     ≥                   ≥ High Word ... High Word (Taskid)              ∫
    ∫     ≥                   ≥ Low Word .... Eventmaske                      ∫
    «ƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
    ∫ 15  ≥ Adresse PV        ≥ Es wird die Adresse einer PV (Datentyp BYTE)  ∫
    ∫     ≥                   ≥ Åbergeben, die fÅr das Pollen des Inputs zu-  ∫
    ∫     ≥                   ≥ stÑndig ist. Falls ein Input eingetroffen     ∫
    ∫     ≥                   ≥ ist, wird diese Variable (PV) auf 1 gesetzt.  ∫
    ∫     ≥                   ≥ Nach dem Aufruf von FRM_read() sollte die PV  ∫
    ∫     ≥                   ≥ vom Anwenderprogramm auf 0 gesetzt werden.    ∫
    »ÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº



                                     @071[ Fortsetzung ]                   @001[ öbersicht ]
.71
    FRM_open - Initialisieren einer Schnittstelle (Fortsetzung)

    …ÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
    ∫ Nr. ≥ Bedeutung         ≥ Detailbeschreibung                            ∫
    ÃÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ
    ∫ 16  ≥ Misc              ≥ Bit 0: 1 = auf der IF050 wird der gesamte     ∫
    ∫     ≥                   ≥ interne Speicher (576 Byte) fÅr die erste     ∫
    ∫     ≥                   ≥ Schnittstelle verwendet. Die anderen Schnitt- ∫
    ∫     ≥                   ≥ stellen sind damit nicht mehr verwendbar.     ∫
    ∫     ≥                   ≥ Bit 1: 1 = auch defekte Puffer (Parity, usw.) ∫
    ∫     ≥                   ≥ werden an den Aufrufer durchgereicht. Der     ∫
    ∫     ≥                   ≥ Aufrufer mu· den Puffer wieder an den Treiber ∫
    ∫     ≥                   ≥ zurÅckgeben! VerfÅgbar ab Version V3.30 des   ∫
    ∫     ≥                   ≥ Frame-Treibers und Version V1.91 der RPSSW.   ∫
    »ÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº






                                     @072[ Fortsetzung ]                   @001[ öbersicht ]
.72
    FRM_open - Initialisieren einer Schnittstelle (Fortsetzung)

    …ÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
    ∫ Nr. ≥ Bedeutung         ≥ Detailbeschreibung                            ∫
    ÃÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ
    ∫ 17  ≥ Adresse PV        ≥ VerfÅgbar ab Version V3.00 des Frame-Treibers ∫
    ∫     ≥                   ≥ und Version V1.91 der RPSSW. Es wird die      ∫
    ∫     ≥                   ≥ Adresse einer PV (Datentyp BYTE) Åbergeben,   ∫
    ∫     ≥                   ≥ die die vollstÑndige öbertragung eines Frames ∫
    ∫     ≥                   ≥ anzeigt (die PV wird bei jeder Frame-         ∫
    ∫     ≥                   ≥ öbertragung inkrementiert).                   ∫
    »ÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº

    Um z.B. den Parameter 13 (Restore nach FRM_close()) zu definieren, mÅssen
    folgende Werte angegeben werden:

      arginfo = 1
      argliste[0] = 13                 ; Nummer des Parameters
      argliste[1] = $00000000          ; Wert des Parameters


                                      @040[ FRM_open ]                     @001[ öbersicht ]
.73
    FRM_open - Initialisieren einer Schnittstelle (Fortsetzung)

    <- Parameter <status    >: WORD

    Fehlernummern der Funktion FRM_open():
    258     Frame-Treiber ist nicht geladen
    3008    Frame-Treiber ist nicht geladen
    8070    Falsche Konfiguration fÅr das Device
    8074    Referenziertes Device existiert nicht
    8076    IF050: Device benîtigt zuviel internen Speicher

    Eine Liste aller mîglichen Fehlermeldungen der Frame-Treiber-Library finden
    Sie im Anhang @300[Fehlermeldungen].








                                      @040[ FRM_open ]                     @001[ öbersicht ]
.80
    FRM_mode - éndern der Schnittstellenparameter

    @081[FRM_mode] (enable,ident,mode,status)

    Parameter-Datentypen :
    ->  enable    : BIT           Der Funktionsblock wird nur ausgefÅhrt, wenn
                                  enable = 1 ist
    ->  ident     : LONG          Treiberkennung der Schnittstelle
                                  (von @020[FRM_xopen] oder @040[FRM_open])
    ->  @085[mode     ] : LONG          An diesem Eingang wird die Adresse eines
                                  Strings Åbergeben, welcher die verwendete
                                  Schnittstelle parametriert.
    <-  @088[status   ] : WORD          Fehlernummer (0 = kein Fehler)

    Mit Hilfe der Funktion FRM_mode() kînnen wÑhrend des Betriebs die Werte fÅr
    Baudrate und asynchrone Parameter (Parity, Datenbits, Stoppbits) sowie der
    Wert fÅr die maximale Leerzeit zwischen Zeichen geÑndert werden.
    Die Funktion FRM_mode() hat eine wesentlich geringere Laufzeit als die
    Funktionen FRM_xopen() und FRM_open().
    Voraussetzung fÅr die Verwendung der Funktion FRM_mode() ist eine RPSSW-
    Version grî·er oder gleich V1.91.
                                     @081[ Fortsetzung ]                   @001[ öbersicht ]
.81
    FRM_mode - éndern der Schnittstellenparameter (Fortsetzung)

    Mit der Funktion FRM_mode() kînnen folgende Parameter verÑndert werden:
    - Baudrate
    - asynchrone Parameter (Parity, Datenbits, Stoppbits)
    - max. Leerzeit zwischen Zeichen (fÅr Frame-Begrenzung)

    Laufzeitmessung:
    Die folgende Tabelle zeigt die Laufzeit (AusfÅhrungszeit) der Funktion
    FRM_mode() beim éndern verschiedener Parameter. Die Zeiten wurden auf
    einer CP104 gemessen.

    …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
    ∫ AuszufÅhrende Aktion                                    ∫ Laufzeit [Ês] ∫
    ÃÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕŒÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ
    ∫ Baudrate Ñndern                                         ∫      604      ∫
    ∫ asynchrone Parameter Ñndern                             ∫      693      ∫
    ∫ max. Leerzeit Ñndern                                    ∫      546      ∫
    ∫ Baudrate, asynchrone Parameter und max. Leerzeit Ñndern ∫     1069      ∫
    »ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº

                                                                     @001[ öbersicht ]
.85
    FRM_mode - éndern der Schnittstellenparameter (Fortsetzung)

    -> Parameter <mode      >: LONG

    An diesem Eingang wird die Adresse eines Strings Åbergeben, welcher die
    Schnittstelle parametriert.

    Format des Strings: [<Typ>],[<Baudrate>],[<Parity>],[<Datenbits>],
                        [<Stoppbits>],[<Optionen>],[<Idle>]

    Typ:       Die Schnittstelle kann als [RS232|RS422|RS485|TTY|RS422BUS] ge-
               îffnet werden, falls dies von der Hardware unterstÅtzt wird.
               Standardeinstellung: RS232
    Baudrate:  Die Schnittstelle kann mit folgenden Baudraten geîffnet werden:
               [300|600|1200|2400|4800|9600|19200|38400|57600|115200]
               Standardeinstellung: 57600
    Parity:    Die Einstellungen [N|O|E|H|L] fÅr no Parity (keine ParitÑt),
               odd Parity (ungerade ParitÑt), even Parity (gerade ParitÑt),
               high forced Parity oder low forced Parity sind mîglich.
               Standardeinstellung: no Parity

                                     @086[ Fortsetzung ]                   @001[ öbersicht ]
.86
    FRM_mode - éndern der Schnittstellenparameter (Fortsetzung)

    Datenbits: Die Einstellungen [7|8] fÅr 7 oder 8 Datenbits sind mîglich.
               Standardeinstellung: 8 Datenbits
    Stoppbits: Die Einstellungen [1|2] fÅr 1 oder 2 Stoppbits sind mîglich.
               Standardeinstellung: 1 Stoppbit
    Optionen:  Wurde als Schnittstellentyp eine RS232 ausgewÑhlt, sind folgende
               Optionen zulÑssig:
               [HW] ... fÅr Hardware-Handshake (RTS/CTS) oder
               [RT] ... fÅr die Steuerung eines externen Kopplers (INT1) mit
                        der RTS-Leitung.
    Idle:      @223[Max. Leerzeit zwischen Zeichen]. Die Zeit zwischen dem Empfang
               zweier aufeinanderfolgender Zeichen wird als "Leerzeit" oder
               "Idle-Zeit" bezeichnet. öberschreitet diese Zeit den einge-
               stellten Maximalwert (Max. Leerzeit zwischen Zeichen), nimmt
               der Frame-Treiber an, da· der Frame vollstÑndig ist. Als Einheit
               fÅr die Leerzeit wird die LÑnge eines Zeichens verwendet.
               FÅr die Angabe dieses Parameters mu· folgende Syntax verwendet
               werden:
               [I=<x>] ... fÅr <x> sind Werte von 1 bis 255 zulÑssig

                                     @087[ Fortsetzung ]                   @001[ öbersicht ]
.87
    FRM_mode - éndern der Schnittstellenparameter (Fortsetzung)

    Als Trennzeichen der Argumente ist ein Punkt (".") vorgeschrieben. Es kann
    aber auch jedes andere Åbliche Trennzeichen verwendet werden.
    Zwischen Gro·- und Kleinschreibung wird nicht unterschieden, die Reihen-
    folge der Parameter hat keine Bedeutung.

    Beispiele gÅltiger Mode-Beschreibungen:
    "19200,7,E,1,I=2"
    "RS485,N,8,1,9600"
    "RS232, 38400, HW, I=3"










                                      @080[ FRM_mode ]                     @001[ öbersicht ]
.88
    FRM_mode - éndern der Schnittstellenparameter (Fortsetzung)

    <- Parameter <status    >: WORD

    Fehlernummern der Funktion FRM_mode():
    258     Frame-Treiber ist nicht geladen
    3008    Frame-Treiber ist nicht geladen
    8251    Device ist nicht geîffnet
    8253    Syntax-Fehler im Mode-String (siehe Parameter "mode")
    14814   Funktion ist nicht verfÅgbar (im FBASE-Treiber nicht implementiert)

    Eine Liste aller mîglichen Fehlermeldungen der Frame-Treiber-Library finden
    Sie im Anhang @300[Fehlermeldungen].








                                      @080[ FRM_mode ]                     @001[ öbersicht ]
.90
    FRM_read - Daten lesen und im Empfangspuffer ablegen

    @091[FRM_read] (enable,ident,status,buffer,buflng)

    Parameter-Datentypen :
    ->  enable    : BIT           Der Funktionsblock wird nur ausgefÅhrt, wenn
                                  enable = 1 ist
    ->  ident     : LONG          Treiberkennung der Schnittstelle
                                  (von @020[FRM_xopen] oder @040[FRM_open])
    <-  @095[status   ] : WORD          Fehlernummer (0 = kein Fehler)
    <-  buffer    : LONG          Adresse des Empfangspuffers
    <-  buflng    : WORD          LÑnge des Empfangspuffers

    Mit der Funktion FRM_read() wird der Empfangsvorgang gestartet, d.h. der
    Frame-Treiber wird aufgefordert, Daten zu empfangen und in einem Empfangs-
    puffer abzulegen.
    Als Ergebnis liefert diese Funktion die Adresse (Parameter "buffer") und
    die LÑnge (Parameter "buflng") des Empfangspuffers. Damit kînnen Sie Daten
    auslesen (z.B. umkopieren mit der Funktion memcpy() der System-Library).


                                     @091[ Fortsetzung ]                   @001[ öbersicht ]
.91
    FRM_read - Daten lesen und im Empfangspuffer ablegen (Fortsetzung)

    Um vernÅnftig auf den Empfangspuffer zugreifen zu kînnen, sollte man in der
    Programmiersprache PL2000 ein Feld bzw. eine Struktur mit "access" auf die
    Åbergebene Empfangspuffer-Adresse legen bzw. im KOP einen eigenen Zugriffs-
    FUB einfÅhren.

    Achtung!
    Nach dem Auslesen der Daten mÅssen Sie den Empfangspuffer mit der Funktion
    @100[FRM_rbuf] wieder freigeben.











                                      @092[ Beispiel ]                     @001[ öbersicht ]
.92
    FRM_read - Daten lesen und im Empfangspuffer ablegen (Beispiel)

      ; PrÅfen, ob Empfangsdaten vorhanden sind
      FRM_read(1,frmident,rstatus,inbufadr,inbuflng)

      if rstatus = 0 then
          ; ApplikationsabhÑngiges Auswerten der Empfangsdaten
          incnt = incnt + 1
          memcpy(insave_adr,inbufadr,inbuflng)
          ; Empfangspuffer freigeben
          FRM_rbuf(1,frmident,inbufadr,inbuflng,rbstatus)
      endif









                                                                     @001[ öbersicht ]
.95
    FRM_read - Daten lesen und im Empfangspuffer ablegen (Fortsetzung)

    <- Parameter <status    >: WORD

    Fehlernummern der Funktion FRM_read():
    1       Keine Nachricht eingetroffen
    60      Keine Nachricht eingetroffen
    258     Treiber ist nicht geladen
    3008    Treiber ist nicht geladen
    8079    Puffer war beim Empfang fehlerhaft
    8210    8210 + x; Analyse des fehlerhaften Puffers. x liegt zwischen 1
            und 31, und wird folgenderma·en aufgeschlÅsselt:
            ⁄ƒ¬ƒ¬ƒ¬ƒ¬ƒ¬ƒ¬ƒ¬ƒø
            ≥ ≥ ≥ ≥F≥P≥B≥O≥ ≥
            ¿ƒ¡ƒ¡ƒ¡ƒ¡ƒ¡ƒ¡ƒ¡ƒŸ
            O ... Bit 1: Overrun-Error (EmpfÑngerÅberlauf aufgetreten)
            B ... Bit 2: Break empfangen
            P ... Bit 3: Parity-Error (Zeichen mit falscher ParitÑt erhalten)
            F ... Bit 4: Framing-Error (kein Stoppbit erhalten)
    8251    Device ist noch nicht geîffnet

                                     @096[ Fortsetzung ]                   @001[ öbersicht ]
.96
    FRM_read - Daten lesen und im Empfangspuffer ablegen (Fortsetzung)

    Eine Liste aller mîglichen Fehlermeldungen der Frame-Treiber-Library finden
    Sie im Anhang @300[Fehlermeldungen].

















                                      @090[ FRM_read ]                     @001[ öbersicht ]
.100
    FRM_rbuf - Freigeben des Empfangspuffers

    @101[FRM_rbuf] (enable,ident,buffer,buflng,status)

    Parameter-Datentypen :
    ->  enable    : BIT           Der Funktionsblock wird nur ausgefÅhrt, wenn
                                  enable = 1 ist
    ->  ident     : LONG          Treiberkennung der Schnittstelle
                                  (von @020[FRM_xopen] oder @040[FRM_open])
    ->  buffer    : LONG          Adresse des Empfangspuffers
    ->  buflng    : WORD          LÑnge des Empfangspuffers
    <-  @105[status   ] : WORD          Fehlernummer (0 = kein Fehler)

    Nach dem Auslesen der Daten mit der Funktion FRM_read() mÅssen Sie den
    Empfangspuffer wieder freigeben. Dazu wird die Funktion FRM_rbuf() be-
    nîtigt.
    Durch die Verwendung von mehreren Empfangspuffern kann die Freigabe auch
    verzîgert erfolgen (z.B. nach dem Empfang von mehreren Nachrichten).



                                     @101[ Fortsetzung ]                   @001[ öbersicht ]
.101
    FRM_rbuf - Freigeben des Empfangspuffers (Fortsetzung)

    Die Eingangsparameter "buffer" und "buflng" der Funktion FRM_rbuf() mÅssen
    den Ausgangsparametern "@090[buffer]" und "@090[buflng]" von FRM_read() entsprechen,
    sonst wird am Ausgang "status" eine Fehlernummer ausgegeben.
















                                      @102[ Beispiel ]                     @001[ öbersicht ]
.102
    FRM_rbuf - Freigeben des Empfangspuffers (Beispiel)

      ; PrÅfen, ob Empfangsdaten vorhanden sind
      FRM_read(1,frmident,rstatus,inbufadr,inbuflng)

      if rstatus = 0 then
          ; ApplikationsabhÑngiges Auswerten der Empfangsdaten
          incnt = incnt + 1
          memcpy(insave_adr,inbufadr,inbuflng)
          ; Empfangspuffer freigeben
          FRM_rbuf(1,frmident,inbufadr,inbuflng,rbstatus)
      endif









                                                                     @001[ öbersicht ]
.105
    FRM_rbuf - Freigeben des Empfangspuffers (Fortsetzung)

    <- Parameter <status    >: WORD

    Fehlernummern der Funktion FRM_rbuf():
    258     Treiber ist nicht geladen
    3008    Treiber ist nicht geladen
    8072    Falscher Puffer Åbergeben
    8251    Device ist noch nicht geîffnet

    Eine Liste aller mîglichen Fehlermeldungen der Frame-Treiber-Library finden
    Sie im Anhang @300[Fehlermeldungen].









                                      @100[ FRM_rbuf ]                     @001[ öbersicht ]
.110
    FRM_gbuf - Anfordern eines Sendepuffers

    @111[FRM_gbuf] (enable,ident,status,buffer,buflng)

    Parameter-Datentypen :
    ->  enable    : BIT           Der Funktionsblock wird nur ausgefÅhrt, wenn
                                  enable = 1 ist
    ->  ident     : LONG          Treiberkennung der Schnittstelle
                                  (von @020[FRM_xopen] oder @040[FRM_open])
    <-  @115[status   ] : WORD          Fehlernummer (0 = kein Fehler)
    <-  buffer    : LONG          Adresse des Sendepuffers
    <-  buflng    : WORD          LÑnge des Sendepuffers

    Mit der Funktion FRM_gbuf() wird ein freier Sendepuffer angefordert. Als
    Ergebnis liefert diese Funktion die Adresse (Parameter "buffer") und die
    LÑnge (Parameter "buflng") eines freien Sendepuffers.
    Die Pufferverwaltung wird Åber den Treiber gehandhabt. Dies hat den Vor-
    teil, da· sich der Anwender um die PuffergÅltigkeit nicht kÅmmern mu·.



                                     @111[ Fortsetzung ]                   @001[ öbersicht ]
.111
    FRM_gbuf - Anfordern eines Sendepuffers (Fortsetzung)

    Es kînnen auch fremde Puffer Åbertragen werden. In diesem Fall ist der
    Anwender jedoch selbst dafÅr verantwortlich, da· er den Puffer vor der
    Abarbeitung durch den Treiber nicht manipuliert.

    Um vernÅnftig auf den Sendepuffer zugreifen zu kînnen, sollte man in der
    Programmiersprache PL2000 ein Feld bzw. eine Struktur mit "access" auf die
    Åbergebene Adresse legen bzw. im KOP einen eigenen Zugriffs-FUB einfÅhren.












                                      @112[ Beispiel ]                     @001[ öbersicht ]
.112
    FRM_gbuf - Anfordern eines Sendepuffers (Beispiel)

      ; Schreibpuffer beantragen
      ; Daten nur bei korrekter Pufferreservierung senden (gbstatus = 0) !!
      FRM_gbuf(1,frmident,gbstatus,outbufadr,outbuflng)
      if (gbstatus = 0) then
          ; Sendedaten aufbereiten - fixen String ausgeben
          obuf access outbufadr                ; Sendepuffer zuweisen
          strcpy(outbufadr,"Frame-Treiber - Outputtest")
          olng = strlen(outbufadr)
          obuf[olng  ] = $a                    ; Carriage Return
          obuf[olng+1] = $d                    ; Line Feed
          obuf[olng+2] = 0
          olng = olng + 2
          ; Sendedaten Åber Schnittstelle Åbertragen
          FRM_write(1,frmident,outbufadr,olng,wstatus)
          if (wstatus <> 0) then
              ; FEHLER-Auswertung: Im Fehlerfall Schreibpuffer freigeben
              FRM_robuf(1,frmident,outbufadr,outbuflng,rostatus)
          endif
      endif
                                                                     @001[ öbersicht ]
.115
    FRM_gbuf - Anfordern eines Sendepuffers (Fortsetzung)

    <- Parameter <status    >: WORD

    Fehlernummern der Funktion FRM_gbuf():
    258     Treiber ist nicht geladen
    3008    Treiber ist nicht geladen
    8071    Kein Puffer verfÅgbar
    8251    Device ist noch nicht geîffnet

    Eine Liste aller mîglichen Fehlermeldungen der Frame-Treiber-Library finden
    Sie im Anhang @300[Fehlermeldungen].









                                      @110[ FRM_gbuf ]                     @001[ öbersicht ]
.120
    FRM_write - Daten im Sendepuffer senden

    @121[FRM_write] (enable,ident,buffer,buflng,status)

    Parameter-Datentypen :
    ->  enable    : BIT           Der Funktionsblock wird nur ausgefÅhrt, wenn
                                  enable = 1 ist
    ->  ident     : LONG          Treiberkennung der Schnittstelle
                                  (von @020[FRM_xopen] oder @040[FRM_open])
    ->  buffer    : LONG          Adresse des Sendepuffers
    ->  buflng    : WORD          LÑnge des Sendepuffers
    <-  @125[status   ] : WORD          Fehlernummer (0 = kein Fehler)

    Durch diese Funktion wird der Frame-Treiber veranla·t, die Daten im Sende-
    puffer zu senden. Der Sendepuffer wird (falls mîglich) sofort Åbertragen.
    Wurde der Sendepuffer mit der Funktion FRM_gbuf() angefordert, so wird er
    nach dem Senden der Daten automatisch wieder freigegeben. Die Eingangs-
    parameter "buffer" und "buflng" der Funktion FRM_write() mÅssen in diesem
    Fall den Ausgangsparametern "@110[buffer]" und "@110[buflng]" von FRM_gbuf() ent-
    sprechen.

                                     @121[ Fortsetzung ]                   @001[ öbersicht ]
.121
    FRM_write - Daten im Sendepuffer senden (Fortsetzung)

    Es kînnen aber auch Puffer gesendet werden, welche nicht vom Frame-Treiber
    verwaltet werden (sinnvoll bei konstanten Frames bzw. konstanten Texten).
    In diesem Fall ist der Anwender jedoch selbst dafÅr verantwortlich, da· er
    den Puffer vor der Abarbeitung durch den Treiber nicht manipuliert.

    Achtung!
    Ein Aufruf der Funktion FRM_write() aus mehreren verschiedenen Taskklassen
    ist nicht zulÑssig!











                                      @122[ Beispiel ]                     @001[ öbersicht ]
.122
    FRM_write - Daten im Sendepuffer senden (Beispiel)

      ; Schreibpuffer beantragen
      ; Daten nur bei korrekter Pufferreservierung senden (gbstatus = 0) !!
      FRM_gbuf(1,frmident,gbstatus,outbufadr,outbuflng)
      if (gbstatus = 0) then
          ; Sendedaten aufbereiten - fixen String ausgeben
          obuf access outbufadr
          strcpy(outbufadr,"Frame-Treiber - Outputtest")
          olng = strlen(outbufadr)
          obuf[olng  ] = $a                    ; Carriage Return
          obuf[olng+1] = $d                    ; Line Feed
          obuf[olng+2] = 0
          olng = olng + 2
          ; Sendedaten Åber Schnittstelle Åbertragen
          FRM_write(1,frmident,outbufadr,olng,wstatus)
          if (wstatus <> 0) then
              ; FEHLER-Auswertung: Im Fehlerfall Schreibpuffer freigeben
              FRM_robuf(1,frmident,outbufadr,outbuflng,rostatus)
          endif
      endif
                                                                     @001[ öbersicht ]
.125
    FRM_write - Daten im Sendepuffer senden (Fortsetzung)

    <- Parameter <status    >: WORD

    Fehlernummern der Funktion FRM_write():
    258     Treiber ist nicht geladen
    3008    Treiber ist nicht geladen
    8072    Falscher Puffer Åbergeben
    8078    Der Auftrag wird abgelehnt, weil in der Sendewarteschlange
            bereits die maximal erlaubte Anzahl von Sendepuffern (siehe
            Funktion FRM_xopen() und FRM_open()) eingereiht ist
    8251    Device ist noch nicht geîffnet

    Eine Liste aller mîglichen Fehlermeldungen der Frame-Treiber-Library finden
    Sie im Anhang @300[Fehlermeldungen].






                                      @120[ FRM_write ]                    @001[ öbersicht ]
.130
    FRM_robuf - Freigeben des Sendepuffers

    @131[FRM_robuf] (enable,ident,buffer,buflng,status)

    Parameter-Datentypen :
    ->  enable    : BIT           Der Funktionsblock wird nur ausgefÅhrt, wenn
                                  enable = 1 ist
    ->  ident     : LONG          Treiberkennung der Schnittstelle
                                  (von @020[FRM_xopen] oder @040[FRM_open])
    ->  buffer    : LONG          Adresse des Sendepuffers
    ->  buflng    : WORD          LÑnge des Sendepuffers
    <-  @135[status   ] : WORD          Fehlernummer (0 = kein Fehler)

    Ist der von FRM_write() retournierte Status (Ausgangsparameter "status")
    nicht 0, ist ein Schreibfehler aufgetreten und der Sendepuffer wird nicht
    automatisch freigegeben. Sie mÅssen in diesem Fall den Sendepuffer manuell
    mit der Funktion FRM_robuf() freigeben.
    Die Eingangsparameter "buffer" und "buflng" der Funktion FRM_robuf() mÅssen
    den Ausgangsparametern "@110[buffer]" und "@110[buflng]" von FRM_gbuf() entsprechen,
    sonst wird am Ausgang "status" ein Fehler gemeldet.

                                      @131[ Beispiel ]                     @001[ öbersicht ]
.131
    FRM_robuf - Freigeben des Sendepuffers (Beispiel)

      ; Schreibpuffer beantragen
      ; Daten nur bei korrekter Pufferreservierung senden (gbstatus = 0) !!
      FRM_gbuf(1,frmident,gbstatus,outbufadr,outbuflng)
      if (gbstatus = 0) then
          ; Sendedaten aufbereiten - fixen String ausgeben
          obuf access outbufadr
          strcpy(outbufadr,"Frame-Treiber - Outputtest")
          olng = strlen(outbufadr)
          obuf[olng  ] = $a                    ; Carriage Return
          obuf[olng+1] = $d                    ; Line Feed
          obuf[olng+2] = 0
          olng = olng + 2
          ; Sendedaten Åber Schnittstelle Åbertragen
          FRM_write(1,frmident,outbufadr,olng,wstatus)
          if (wstatus <> 0) then
              ; FEHLER-Auswertung: Im Fehlerfall Schreibpuffer freigeben
              FRM_robuf(1,frmident,outbufadr,outbuflng,rostatus)
          endif
      endif
                                                                     @001[ öbersicht ]
.135
    FRM_robuf - Freigeben des Sendepuffers (Fortsetzung)

    <- Parameter <status    >: WORD

    Fehlernummern der Funktion FRM_robuf():
    258     Treiber ist nicht geladen
    3008    Treiber ist nicht geladen
    8072    Falscher Puffer Åbergeben
    8251    Device ist noch nicht geîffnet

    Eine Liste aller mîglichen Fehlermeldungen der Frame-Treiber-Library finden
    Sie im Anhang @300[Fehlermeldungen].









                                      @130[ FRM_robuf ]                    @001[ öbersicht ]
.140
    FRM_close - Deinitialisieren einer Schnittstelle

    @141[FRM_close] (enable,ident,status)

    Parameter-Datentypen :
    ->  enable    : BIT           Der Funktionsblock wird nur ausgefÅhrt, wenn
                                  enable = 1 ist
    ->  ident     : LONG          Treiberkennung der Schnittstelle
                                  (von @020[FRM_xopen] oder @040[FRM_open])
    <-  @145[status   ] : WORD          Fehlernummer (0 = kein Fehler)

    Jeder Device-Treiber benîtigt bestimmte Ressourcen (z.B. Speicher). Wird
    ein GerÑt (Device) nicht mehr benîtigt, ist es sinnvoll, den entsprechenden
    Device-Treiber zu deinitialisieren und den verwendeten Speicher wieder frei-
    zugeben. FÅr den Frame-Treiber DVFRAME.BR (bzw. DVFRAME3.BR) wird dazu die
    Funktion FRM_close() verwendet.





                                     @141[ Fortsetzung ]                   @001[ öbersicht ]
.141
    FRM_close - Deinitialisieren einer Schnittstelle (Fortsetzung)

    Es besteht die Mîglichkeit, eine Schnittstelle mehrfach zu verwenden, z.B.
    die Schnittstelle, an der Ihr ProgrammiergerÑt angeschlossen ist.
    Beim Initialisieren der Schnittstelle mit der Funktion FRM_open() kann die
    sogenannte @070[Restore-FunktionalitÑt] aktiviert werden. D.h., da· die einge-
    stellten Schnittstellenparameter vor der Initialisierung (mit FRM_open())
    gespeichert und nach dem Deinitialisieren (mit FRM_close()) wieder einge-
    stellt werden (z.B. fÅr Kommunikation mit dem PG2000). Wenn also mit der
    Funktion FRM_open() die Restore-FunktionalitÑt aktiviert wurde, dann wird
    auch die Schnittstelle so zurÅckkonfiguriert, da· ein Betreiben des alten
    Protokolls unter gewissen Bedingungen mîglich ist.
    Ab der Version V3.00 des Frame-Treibers und Version V1.91 des Betriebs-
    systems RPSSW ist das Restore des ALI-Treibers eine Standardaktion. Andere
    Konfigurationen kînnen allerdings nicht rÅckgespeichert werden.






                                     @142[ Fortsetzung ]                   @001[ öbersicht ]
.142
    FRM_close - Deinitialisieren einer Schnittstelle (Fortsetzung)

    * Initialisierung der Schnittstelle:
      Die Restore-FunktionalitÑt wird in der erweiterten Parameterdefinition
      mit "@064[arginfo]" und "@064[argliste]" eingeschaltet:

        arginfo = 1
        argliste[0] = 13
        argliste[1] = $00000000

      Beim ôffnen der Schnittstelle mit FRM_open() werden die Schnittstellen-
      einstellungen gespeichert.

    * Deinitialisierung der Schnittstelle:
      Beim Deinitialisieren der Schnittstelle mit der Funktion FRM_close())
      werden die gespeicherten Schnittstelleneinstellungen wieder hergestellt.
      Dadurch kann eine Schnittstelle mehrfach verwendet werden.




                                      @143[ Beispiel ]                     @001[ öbersicht ]
.143
    FRM_close - Deinitialisieren einer Schnittstelle (Beispiel)

      ; INIT-UP der Task - ôFFNEN der Schnittstelle
      FRM_open(1,dvnr,frmdelim,baud,mode,rxbufcnt,txbufcnt,rxbuflng,txbuflng,
               arginfo,adr(argliste),opnstatus,frmident)

      ; Zyklischer Teil der Task - DEINITIALISIEREN der Schnittstelle
      if (close_flag = 1) and (opnstatus = 0) then
          close_flag = 0
          FRM_close(1,frmident,clstatus)
          if clstatus = 0
              opnstatus = 0xFFFF               ; Schnittstelle DEINITIALISIERT
          endif
      endif







                                                                     @001[ öbersicht ]
.145
    FRM_close - Deinitialisieren einer Schnittstelle (Fortsetzung)

    <- Parameter <status    >: WORD

    Fehlernummern der Funktion FRM_close():
    258     Treiber ist nicht geladen
    3008    Treiber ist nicht geladen
    8072    Falscher Puffer Åbergeben
    8251    Device ist noch nicht geîffnet

    Eine Liste aller mîglichen Fehlermeldungen der Frame-Treiber-Library finden
    Sie im Anhang @300[Fehlermeldungen].









                                      @140[ FRM_close ]                    @001[ öbersicht ]
.150
    FRM_ctrl - Bedienen der Schnittstelle

    @150[FRM_ctrl] (enable,ident,ioctrl,inarg,status,outarg)

    Parameter-Datentypen :
    ->  enable    : BIT           Der Funktionsblock wird nur ausgefÅhrt, wenn
                                  enable = 1 ist
    ->  ident     : LONG          Treiberkennung der Schnittstelle
                                  (von @020[FRM_xopen] oder @040[FRM_open])
    ->  @155[ioctrl   ] : WORD          Kontrollauswahl
    ->  inarg     : LONG          Inputargument
    <-  @157[status   ] : WORD          Fehlernummer (0 = kein Fehler)
    <-  outarg    : LONG          Ergebnis des Kontrollaufrufs

    Mit Hilfe der Funktion FRM_ctrl() sind die DSR/DTR-Signale der modemfÑhigen
    Schnittstellen durch den Anwender bedienbar. Au·erdem ist im Falle eines
    RTS-Hardware-Handshakes mit dieser Funktion der Zustand der Kommunikation
    auslesbar.



                                                                     @001[ öbersicht ]
.155
    FRM_ctrl - Bedienen der Schnittstelle (Fortsetzung)

    -> Parameter <ioctrl    >: WORD

    AbhÑngig vom Wert dieses Parameters werden verschiedene Kommandos ausge-
    fÅhrt:

    - "ioctrl" = $10:
      öberprÅft, ob das RTS-Hardware-Handshake gerade aktiv ist. Dies ent-
      spricht der Funktion FRM_hshake_activ. Wenn das RTS-Hardware-Handshake
      aktiv ist, kann der Anwender ÅberprÅfen, ob Åberhaupt eine Gegenstelle
      vorhanden ist.
      "inarg" .... keine Bedeutung
      "outarg" ... 1 (Handshake aktiv) oder 0 (Handshake inaktiv)

    - "ioctrl" = $11:
      Der Zustand des DSR-Signals wird ausgelesen. Funktioniert nur auf den
      modemfÑhigen Schnittstellen!
      "inarg" .... keine Bedeutung
      "outarg" ... Zustand des DSR-Signals (0 oder 1)

                                     @156[ Fortsetzung ]                   @001[ öbersicht ]
.156
    FRM_ctrl - Bedienen der Schnittstelle (Fortsetzung)

    - "ioctrl" = $12:
      Der Zustand des DTR-Signals wird entsprechend dem Wert in "inarg" gesetzt
      bzw. rÅckgesetzt. Dieser Aufruf funktioniert nur auf den modemfÑhigen
      Schnittstellen!
      "inarg" .... 0 oder 1 fÅr DTR-Signal
      "outarg" ... keine Bedeutung

    Ab der Version V3.00 des Frame-Treibers und der Version V1.91 des Betriebs-
    systems RPSSW sind weitere Funktionen verfÅgbar:
    "ioctrl" = $21 ... Zustand der Steuerleitung DCD lesen
    "ioctrl" = $22 ... RX aktiv (Ist ein Empfangspuffer geîffnet?)
    "ioctrl" = $23 ... TX aktiv (Ist eine FrameÅbertragung aktiv?)
    "ioctrl" = $24 ... Steuerleitung DTR setzen/rÅcksetzen
    "ioctrl" = $25 ... Funktionsnummer reserviert
    "ioctrl" = $26 ... Zustand der Steuerleitung DSR lesen
    "ioctrl" = $27 ... Steuerleitung RTS setzen/rÅcksetzen
    "ioctrl" = $28 ... Zustand der Steuerleitung CTS lesen
    "ioctrl" = $29 ... Zustand der Steuerleitung RI lesen

                                      @150[ FRM_ctrl ]                     @001[ öbersicht ]
.157
    FRM_ctrl - Bedienen der Schnittstelle (Fortsetzung)

    <- Parameter <status    >: WORD

    Fehlernummern der Funktion FRM_ctrl():
    258     Treiber ist nicht geladen
    3008    Treiber ist nicht geladen
    8073    Falsches bzw. ungÅltiges Kommando in "ioctrl"
    8251    Device ist noch nicht geîffnet
    14813   Steuerleitung ist auf der Schnittstelle nicht ausgefÅhrt oder wird
            nicht bedient
    14814   Steuerleitung wird nicht bedient

    Eine Liste aller mîglichen Fehlermeldungen der Frame-Treiber-Library finden
    Sie im Anhang @300[Fehlermeldungen].






                                      @150[ FRM_ctrl ]                     @001[ öbersicht ]
.200
    ANHANG : LIBRARY-Informationen


    @201[< Allgemeines       >]      Voraussetzungen etc.

    @210[< Frame-Treiber     >]      Beschreibung des Frame-Treibers

    @220[< Frame-Begrenzung  >]      Frame-Begrenzung beim Senden/Empfangen

    @250[< Syntax            >]      Syntax fÅr die ErklÑrung der Funktionen

    @300[< Fehlernummern     >]      Zusammenfassung aller Fehlernummern

    @400[< History           >]      Neue FunktionalitÑten und VersionsÑnderungen







                                                                     @001[ öbersicht ]
.201
    Frame-Treiber-Library : Allgemeines

    Mit Hilfe des Frame-Treibers kînnen Sie Daten mit externen GerÑten (z.B.
    Drucker, Bedientableaus, Bildschirmterminals, usw.), die nicht Åber ein
    Standard-Netzwerk kommunizieren kînnen, austauschen.
    Die Funktionsblîcke der zum Frame-Treiber gehîrigen Frame-Treiber-Library
    ermîglichen es, Daten als "Frame" zu senden und zu empfangen. Der Frame-
    Treiber kÅmmert sich dabei um die hardware-mÑ·ige Seite des Datenaus-
    tausches, ohne die Daten im Frame zu verÑndern. Damit kînnen schnell und
    einfach anwendungsspezifische Kommunikationen realisiert werden.
    Detaillierte Informationen zum Thema "Frame-Treiber" finden Sie im Handbuch
    "B&R System 2000 Programmieren fÅr Fortgeschrittene".









                                     @202[ Fortsetzung ]                   @001[ öbersicht ]
.202
    Frame-Treiber-Library : Allgemeines (Fortsetzung)

    Anmerkungen:
    - Bevor Sie die Funktionen der Frame-Treiber-Library in Ihrem Projekt
      verwenden kînnen, mÅssen Sie die Library in die entsprechende Projekt-
      Datenbank importieren.

    - Die Funktionen dieser Library kînnen nur verwendet werden, wenn der
      Frame-Treiber DVFRAME.BR auf der CPU (Anwender-ROM) vorhanden ist!

    - FRM_xopen():
      Die Module IF050 und IF060 (passive Schnittstellenmodule) kînnen nur be-
      dient werden, wenn die FRAME-BASIS-Treiber FBIF050.BR (fÅr IF050) und
      FBIF060.BR (fÅr IF060) auf der CPU (Anwender-ROM) vorhanden sind!

    - FRM_open():
      IF050-Module kînnen nur bedient werden, wenn der Frame-Treiber
      DVFRAME3.BR auf der CPU (Anwender-ROM) vorhanden ist!

    - Alle Funktionen der Frame-Treiber-Library liefern im Fehlerfall als
      Ergebnis eine @300[Fehlernummer].
                                       @200[ ANHANG ]                      @001[ öbersicht ]
.210
    Frame-Treiber-Library : Frame-Treiber

    Allgemeines zum Frame-Treiber:

    Der Frame-Treiber ermîglicht das Empfangen und Senden von Frames, ohne
    da· der Treiber diese Frames (Byte-Strîme) manipuliert. Der Frame-Treiber
    bildet somit die Basis zur hardware-unabhÑngigen Implementation von
    einfachen Protokollen. Der Anwender mu· lediglich die Mediumzugriffs-
    verriegelung (Master-Slave, Master-Master), sowie das Protokoll-Framing
    implementieren (Stationsadressen, PrÅfsummen, usw.). Weiters kann mit
    Hilfe des Frame-Treibers ein Drucker, Bildschirmterminal oder Bedien-
    tableau bedient werden. Der Frame-Treiber Åbernimmt folgende Funktionen:

    * Hardware-Initialisierung der Schnittstelle im parametrierten Modus
    * Puffermanagement fÅr die Schnittstelle (bis zu 8 Puffer in Empfangs- bzw.
      Sende-Richtung, wobei die Empfangs- und Sendepuffer unterschiedliche
      Grî·en haben kînnen).
    * Glitchfreies Senden von Sendepuffern, d.h. zwischen den Åbertragenen
      Zeichen gibt es keine Zeichenverzugszeit.


                                     @211[ Fortsetzung ]                   @001[ öbersicht ]
.211
    Frame-Treiber-Library : Frame-Treiber (Fortsetzung)

    Allgemeines zum Frame-Treiber (Fortsetzung):

    * Zerlegung des empfangenen Byte-Stroms in einzelne Frames nach den Vor-
      gaben des Anwenders (@220[Frame-Begrenzung]).
    * Hardware-Handshake auf Basis der RTS/CTS-Signale (derzeit nur als
      Sender).
    * Software-Handshake XON/XOFF (wird ab RPSSW-Version V1.91 nicht mehr
      unterstÅtzt).
    * Bedienung eines externen Kopplers mit RTS-Signal (z.B. RS485-
      Umschaltung).
    * UnterstÅtzung von zwei IF050-Modulen im System B&R 2005.
    * öberlagerung der PG-Schnittstelle mit der Mîglichkeit des Wiederaufbaus
      der PG-Kommunikation (@141[Restore-FunktionalitÑt])
    * Bedienung Åber C-Toolbox durch Restzeit-Tasks.

    Die zur VerfÅgung gestellten FunktionalitÑten sind unabhÑngig vom System
    (B&R 2010, B&R 2005, B&R 2003).


                                       @200[ ANHANG ]                      @001[ öbersicht ]
.220
    Frame-Treiber-Library : Frame-Begrenzung

    Wir unterscheiden zwischen der Frame-Begrenzung beim Empfangen und der
    Frame-Begrenzung beim Senden:

    * @221[Frame-Begrenzung beim Empfangen]
    * @225[Frame-Begrenzung beim Senden   ]














                                       @200[ ANHANG ]                      @001[ öbersicht ]
.221
    Frame-Treiber-Library : Frame-Begrenzung (Fortsetzung)

    Frame-Begrenzung beim Empfangen:

    Ein Frame enthÑlt eine Anzahl von zusammengehîrenden Bytes, die nachein-
    ander Åbertragen werden. Um empfangene Frames voneinander unterscheiden zu
    kînnen, mÅssen sie entweder mit einem bekannten Zeichen abgeschlossen oder
    ihre LÑnge bekannt sein:

    * @222[Frame-Abschlu·zeichen         ]
    * @222[LÑnge bekannt                 ]
    * @223[Max. Leerzeit zwischen Zeichen]

    Sie kînnen bei der Parametrierung eine, zwei oder alle drei Mîglichkeiten
    der Frame-Begrenzung gleichzeitig angeben.






                                     @222[ Fortsetzung ]                   @001[ öbersicht ]
.222
    Frame-Treiber-Library : Frame-Begrenzung (Fortsetzung)

    Frame-Begrenzung beim Empfangen (Fortsetzung):

    * Frame-Abschlu·zeichen:
      Am Ende eines Frames wird ein bestimmtes Zeichen gesendet. UnabhÑngig
      von der LÑnge des Frames wei· der Frame-Treiber damit, da· der Frame
      vollstÑndig empfangen wurde und beginnt mit dem nÑchsten Frame. Mit den
      Parametern "config" (Funktion FRM_xopen()) und "frmdelim" (Funktion
      FRM_open()) kînnen maximal 2 Frame-Abschlu·zeichen definiert werden,
      obwohl der Frame-Treiber bis zu 4 Frame-Abschlu·zeichen haben kann.
      Werden mehr als 2 Frame-Abschlu·zeichen benîtigt, mu· dies Åber die
      erweiterte Parameterdefinition mit "@064[arginfo]" und "@064[argliste]" (Funktion
      FRM_open()) angegeben werden.

    * LÑnge bekannt:
      Die Anzahl der empfangenen Zeichen entspricht der parametrierten maxi-
      malen Zeichenanzahl in einem Puffer. Nachdem das letzte Zeichen empfangen
      wurde, wird der ganze Frame in einem Empfangspuffer abgelegt. Das nÑchste
      empfangene Zeichen gehîrt zum nÑchsten Frame.

                                     @223[ Fortsetzung ]                   @001[ öbersicht ]
.223
    Frame-Treiber-Library : Frame-Begrenzung (Fortsetzung)

    Frame-Begrenzung beim Empfangen (Fortsetzung):

    * Max. Leerzeit zwischen Zeichen:
      Die Zeit zwischen dem Empfang zweier aufeinanderfolgender Zeichen wird
      "Leerzeit" oder "Idle-Zeit" genannt. öberschreitet diese Zeit den bei der
      Parametrierung eingestellten Maximalwert, nimmt der Frame-Treiber an, da·
      der Frame vollstÑndig ist. Als Einheit fÅr die Leerzeit wird die LÑnge
      eines Zeichens verwendet (Standard ist 4 Zeichen).











                                     @224[ Fortsetzung ]                   @001[ öbersicht ]
.224
    Frame-Treiber-Library : Frame-Begrenzung (Fortsetzung)

    Beispiel zur Frame-Begrenzung beim Empfangen:
    FÅr den Frame-Abschlu· wurden bei der Parametrierung folgende Angaben
    gemacht:

         Anzahl Zeichen:                   10
         Frame-Abschlu·zeichen:            $F1, $F2
         Max. Leerzeit zwischen Zeichen:   3 Zeichen

    Empfangene Daten:
    - Station 1 sendet 10 Zeichen:
      Die Anzahl der Zeichen eines Frames wurde erreicht. Der Frame ist voll-
      stÑndig und wird im Empfangspuffer 1 abgelegt. Weiter mit Puffer 2.
    - Station 2 sendet 3 Zeichen. 5 ZeichenlÑngen spÑter werden 8 Zeichen von
      Station 3 empfangen, das letzte Zeichen ist $F1:
      Die maximale Leerzeit wird Åberschritten. Die Daten von Station 2 werden
      im Empfangspuffer 2 abgelegt. Weiter mit Puffer 3.
      $F1 ist ein Frame-Abschlu·zeichen. Die Daten von Station 3 werden im
      Empfangspuffer 3 abgelegt. Weiter mit Puffer 4.

                                       @220[ ZurÅck ]                      @001[ öbersicht ]
.225
    Frame-Treiber-Library : Frame-Begrenzung (Fortsetzung)

    Frame-Begrenzung beim Senden:

    * In Sende-Richtung wird ein Frame durch den entsprechenden Funktionsblock-
      Aufruf definiert. Der Åbergebene Puffer wird ohne Zeichenverzugszeit
      (d.h. ohne Schlupf) Åbertragen.

    * Die PufferlÑnge mu· kleiner als die parametrierte maximale LÑnge des
      Sendepuffers sein (siehe Parameter "config" der Funktion FRM_xopen()
      bzw. Parameter "txbuflng" der Funktion FRM_open()).

    * Der Anwender mu· Åber sein Protokoll sicherstellen, da· das öbertragungs-
      medium (z.B. RS485) fÅr die öbertragung logisch (z.B. Master-Slave-
      Protokoll) zur VerfÅgung steht. Der Frame-Treiber fÅhrt keine Kontrollen
      durch. In einem Punkt-Punkt-Vollduplexbetrieb (RS232, RS422) gibt es hier
      sowieso keine Probleme.




                                       @220[ ZurÅck ]                      @001[ öbersicht ]
.250
    Frame-Treiber-Library : Syntaxbeschreibung

    Datentypen:
    FÅr viele Funktionen sind bestimmte Gruppen von Datentypen zulÑssig. Um
    bei der Funktionsbeschreibung nicht alle zulÑssigen Datentypen anfÅhren
    zu mÅssen, werden folgende Gruppenbezeichnungen eingefÅhrt:
    …ÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕª
    ∫ Gruppe ∫  BIT  ≥ INT8  ≥ BYTE  ≥ INT16 ≥ WORD  ≥ INT32 ≥ LONG  ≥ FLOAT ∫
    ÃÕÕÕÕÕÕÕÕŒÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕπ
    ∫ BASIS  ∫       ≥   x   ≥   x   ≥   x   ≥   x   ≥   x   ≥   x   ≥       ∫
    «ƒƒƒƒƒƒƒƒ◊ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ∂
    ∫ NICHT  ∫   x   ≥   x   ≥   x   ≥   x   ≥   x   ≥   x   ≥   x   ≥       ∫
    ∫ FLOAT  ∫       ≥       ≥       ≥       ≥       ≥       ≥       ≥       ∫
    «ƒƒƒƒƒƒƒƒ◊ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ∂
    ∫ ALLE   ∫   x   ≥   x   ≥   x   ≥   x   ≥   x   ≥   x   ≥   x   ≥   x   ∫
    «ƒƒƒƒƒƒƒƒ◊ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒ∂
    ∫ FELD   ∫  [x]  ≥  [x]  ≥  [x]  ≥  [x]  ≥  [x]  ≥  [x]  ≥  [x]  ≥  [x]  ∫
    »ÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕÕœÕÕÕÕÕÕÕœÕÕÕÕÕÕÕœÕÕÕÕÕÕÕœÕÕÕÕÕÕÕœÕÕÕÕÕÕÕœÕÕÕÕÕÕÕœÕÕÕÕÕÕÕº
      x  Datentyp ist zulÑssig
     [x] Datentyp ist zulÑssig als Feldvariable oder Zeichenkette (String)

                                     @251[ Fortsetzung ]                   @001[ öbersicht ]
.251
    Frame-Treiber-Library : Syntaxbeschreibung (Fortsetzung)

    Pfeile:
    FÅr die Darstellung von Eingangs- und Ausgangsparametern werden Pfeile
    verwendet. Dabei gilt folgende Vereinbarung:
    …ÕÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
    ∫  Pfeil  ∫  Bedeutung                                                   ∫
    ÃÕÕÕÕÕÕÕÕÕŒÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ
    ∫   ->    ∫  Eingangsparameter                                           ∫
    «ƒƒƒƒƒƒƒƒƒ◊ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
    ∫   <->   ∫  Ein-/Ausgangsparameter. Funktionell ist es ein Ausgangs-    ∫
    ∫         ∫  parameter. öblicherweise wird er aber vor dem Aufruf der    ∫
    ∫         ∫  Funktion mit einer bestimmten Information geladen (z.B.     ∫
    ∫         ∫  einer Adresse). Meist wird die Adresse einer Variable mit   ∫
    ∫         ∫  adr() [PL2000] oder einem Adre·kontakt [KOP] angeschlossen. ∫
    «ƒƒƒƒƒƒƒƒƒ◊ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
    ∫   <-    ∫  Ausgangsparameter                                           ∫
    »ÕÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº



                                     @252[ Fortsetzung ]                   @001[ öbersicht ]
.252
    Frame-Treiber-Library : Syntaxbeschreibung (Fortsetzung)

    Funktionsblîcke:
    Funktionsblîcke sind in dieser Online-Hilfe nicht grafisch dargestellt.
    Sie finden aber alle fÅr Funktionsblîcke relevanten Informationen, wie
    Eingangsparameter (->), Ein-/Ausgangsparameter (<->) und Ausgangsparameter
    (<-) in der Online-Hilfe.














                                       @200[ ANHANG ]                      @001[ öbersicht ]
.300
    Frame-Treiber-Library : Fehlernummern

    Die folgende Liste ist eine Zusammenfassung aller mîglichen Fehlermeldungen
    der Frame-Treiber-Library:

    1       Keine Nachricht eingetroffen
    60      Keine Nachricht eingetroffen
    258     Frame-Treiber ist nicht geladen
    3008    Frame-Treiber ist nicht geladen
    8070    Falsche Konfiguration fÅr das Device
    8071    Kein Puffer verfÅgbar
    8072    Falscher Puffer Åbergeben
    8073    Falsches bzw. ungÅltiges Kommando in "ioctrl"
    8074    Referenziertes Device existiert nicht bzw. FRAME-BASIS-Treiber fÅr
            die IF050/IF060 ist nicht geladen
    8076    IF050: Device benîtigt zuviel internen Speicher
    8078    Der Auftrag wird abgelehnt, weil in der Sendewarteschlange
            bereits die maximal erlaubte Anzahl von Sendepuffern (siehe
            Funktion FRM_xopen() und FRM_open()) eingereiht ist
    8079    Puffer war beim Empfang fehlerhaft

                                     @301[ Fortsetzung ]                   @001[ öbersicht ]
.301
    Frame-Treiber-Library : Fehlernummern (Fortsetzung)

    8210    8210 + x; Analyse des fehlerhaften Puffers. x liegt zwischen 1
            und 31, und wird folgenderma·en aufgeschlÅsselt:
            ⁄ƒ¬ƒ¬ƒ¬ƒ¬ƒ¬ƒ¬ƒ¬ƒø
            ≥ ≥ ≥ ≥F≥P≥B≥O≥ ≥
            ¿ƒ¡ƒ¡ƒ¡ƒ¡ƒ¡ƒ¡ƒ¡ƒŸ
            O ... Bit 1: Overrun-Error (EmpfÑngerÅberlauf aufgetreten)
            B ... Bit 2: Break empfangen
            P ... Bit 3: Parity-Error (Zeichen mit falscher ParitÑt erhalten)
            F ... Bit 4: Framing-Error (kein Stoppbit erhalten)
    8251    Device ist nicht geîffnet
    8252    Syntax-Fehler im Device-String (siehe Parameter "device")
    8253    Syntax-Fehler im Mode-String (siehe Parameter "mode")
    8254    Die maximale Anzahl gleichzeitig geîffneter Devices wurde Åber-
            schritten
    8255    RPSSW-Version zu alt (es mu· eine RPSSW-Version grî·er oder gleich
            V1.91 verwendet werden)
    14808   Eine Einstellung im Mode-String (siehe Parameter "mode") wird von
            der Schnittstelle nicht unterstÅtzt

                                     @302[ Fortsetzung ]                   @001[ öbersicht ]
.302
    Frame-Treiber-Library : Fehlernummern (Fortsetzung)

    14813   Steuerleitung ist auf der Schnittstelle nicht ausgefÅhrt oder wird
            nicht bedient
    14814   Funktion ist nicht verfÅgbar (im FBASE-Treiber nicht implementiert)
















                                       @200[ ANHANG ]                      @001[ öbersicht ]
.400
    Frame-Treiber-Library : History - VersionsÑnderungen

  …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
  ∫ V3.20 -> V3.30  ≥ AKTUELLE VERSION: Neue FunktionalitÑten/Fehlerbehebung  ∫
  «ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
  ∫ - Es besteht nun die Mîglichkeit, das Parity-Bit zu forcen.               ∫
  ∫   Die Einstellungen "h", "H", "l" und "L" sind gÅltige Einstellungen, um  ∫
  ∫   das Parity-Bit auf HIGH bzw. LOW zu forcen. Die Funktion ist nur Åber   ∫
  ∫   die Funktionsblîcke FRM_xopen() bzw. FRM_mode() erreichbar. Die Basis-  ∫
  ∫   funktionalitÑt ist derzeit nur auf der CP260 mit RPSSW V2.00 verfÅgbar. ∫
  ∫ - Fehlerkorrekturen:                                                      ∫
  ∫   - Defekte Puffer werden nun standardmÑ·ig nicht mehr an den Aufrufer    ∫
  ∫     durchgereicht (Fehlverhalten der Frame-Treiber-Version V3.00 bis      ∫
  ∫     V3.30 + RPSSW-Version grî·er oder gleich V1.90).                      ∫
  ∫   - Optional kann der Frame-Treiber jedoch so konfiguriert werden, da·    ∫
  ∫     defekte Puffer zum Aufrufer durchgereicht werden (Parametrierung Åber ∫
  ∫     das Argument 16).                                                     ∫
  ∫     Anmerkung: Generell sollte der Erhalt eines Puffers Åber die Puffer-  ∫
  ∫     lÑnge > 0 geprÅft werden!                                             ∫
  »ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº

                                     @401[ Fortsetzung ]                   @001[ öbersicht ]
.401
    Frame-Treiber-Library : History - VersionsÑnderungen (Fortsetzung)

  …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
  ∫ V3.10 -> V3.20  ≥ éLTERE VERSIONEN: Neue FunktionalitÑten/Fehlerbehebung  ∫
  «ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
  ∫ FRM_mode(): Mit Hilfe der Funktion FRM_mode() kînnen wÑhrend des Betriebs ∫
  ∫ die Schnittstellenparameter geÑndert werden. Voraussetzung fÅr die Ver-   ∫
  ∫ wendung der Funktion FRM_mode() ist eine RPSSW-Version grî·er oder gleich ∫
  ∫ V1.91.                                                                    ∫
  ÃÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ
  ∫ V3.00 -> V3.10  ≥ éLTERE VERSIONEN: Neue FunktionalitÑten/Fehlerbehebung  ∫
  «ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
  ∫ - FRM_xopen(): Mit Hilfe der Funktion FRM_xopen() kînnen bis zu 16        ∫
  ∫   Schnittstellen gleichzeitig betrieben werden. Voraussetzung fÅr die     ∫
  ∫   Verwendung der Funktion FRM_xopen() ist eine RPSSW-Version grî·er oder  ∫
  ∫   gleich V1.91.                                                           ∫
  ∫ - Bei Verwendung der Funktion FRM_xopen() kînnen die Module IF050 und     ∫
  ∫   IF060 (passive Schnittstellenmodule) nur bedient werden, wenn die       ∫
  ∫   FRAME-BASIS-Treiber FBIF050.BR (fÅr IF050) und FBIF060.BR (fÅr IF060)   ∫
  ∫   auf der CPU (Anwender-ROM) vorhanden sind.                              ∫
  »ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº
                                     @402[ Fortsetzung ]                   @001[ öbersicht ]
.402
    Frame-Treiber-Library : History - VersionsÑnderungen (Fortsetzung)

  …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
  ∫ V3.00 -> V3.10  ≥ éLTERE VERSIONEN: Neue FunktionalitÑten/Fehlerbehebung  ∫
  «ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
  ∫ - Der Treiber DVFRAME3.BR hat bei der Bedienung einer IF050-Schnittstelle ∫
  ∫   mit der Funktion FRM_xopen() keinerlei Bedeutung mehr.                  ∫
  ∫   Die EinschrÑnkungen, die bei Verwendung der Funktion FRM_open() fÅr die ∫
  ∫   IF050 gelten, sind bei Verwendung der Funktion FRM_xopen() hinfÑllig.   ∫
  ∫ - Die Poll-Variablen zur USER-VerstÑndigung (RX-, TX-Poll-PV) werden nun  ∫
  ∫   vom Frame-Treiber inkrementiert.                                        ∫
  ∫ - Fehlerkorrekturen:                                                      ∫
  ∫   - BUS-Error mit NC154 + IF050 korrigiert.                               ∫
  ∫   - "Totaler Zeitengpa· im System" (6002) mit IF050 korrigiert.           ∫
  ∫   - IF050-Initialisierung (Port A-Behandlung) korrigiert.                 ∫
  »ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº





                                     @403[ Fortsetzung ]                   @001[ öbersicht ]
.403
    Frame-Treiber-Library : History - VersionsÑnderungen (Fortsetzung)

  …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
  ∫ V2.40 -> V3.00  ≥ éLTERE VERSION: Neue FunktionalitÑten/Fehlerbehebung    ∫
  «ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
  ∫ - UnterstÅtzung neuer CPU-Typen (XP152, IP151, IF152, CP472).             ∫
  ∫ - Ab der Version V1.19 der RPSSW werden sÑmtliche Frame-Treiber-Aufrufe   ∫
  ∫   auf "FBASE"-Funktionen abgebildet. Die FBASE-Treiber sind integrale     ∫
  ∫   Bestandteile der RPSSW.                                                 ∫
  ∫ - Die FunktionalitÑt "Software-Handshake" wurde aus dem Funktionsumfang   ∫
  ∫   des Frame-Treibers gestrichen.                                          ∫
  ∫ - Die FunktionalitÑt "Steuerung des INT1 Kopplers Åber RTS mit Echo"      ∫
  ∫   wurde aus dem Funktionsumfang des Frame-Treibers gestrichen.            ∫
  ∫ - EinfÅhrung einer "TX-Poll-PV". Dadurch kann die Beendigung einer Frame- ∫
  ∫   öbertragung erkannt werden.                                             ∫
  ∫ - Erweiterung der Funktion FRM_ctrl().                                    ∫
  ∫ - Das "Restore" der ALI-Konfiguration nach einem FRM_close() ist eine     ∫
  ∫   Standardaktion der FBASE-Treiber (Funktioniert nun ohne Ausnahme!).     ∫
  ∫ - Weiters wurden Fehlerkorrekturen im "alten" Code-Teil durchgefÅhrt.     ∫
  »ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº

                                     @404[ Fortsetzung ]                   @001[ öbersicht ]
.404
    Frame-Treiber-Library : History - VersionsÑnderungen (Fortsetzung)

  …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
  ∫ V2.30 -> V2.40  ≥ éLTERE VERSIONEN: Fehlerbehebung                        ∫
  «ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
  ∫ Fehlerkorrektur: Bei der Verwendung einer IF050 hat die Fehlerver-        ∫
  ∫                  stÑndigung des Remote Masters an die RPS-CPU nicht       ∫
  ∫                  funktioniert (System B&R 2005).                          ∫
  ÃÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ
  ∫ V2.20 -> V2.30  ≥ éLTERE VERSIONEN: Neue FunktionalitÑten                 ∫
  «ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
  ∫ - FRM_ctrl(): Die DSR/DTR-Signale der modemfÑhigen Schnittstellen sind    ∫
  ∫   mit Hilfe dieses FUBs durch den Anwender bedienbar. Im Falle eines      ∫
  ∫   RTS-Hardware-Handshakes ist der Zustand der Kommunikation auslesbar.    ∫
  ∫ - Die RTS-Option fÅr das Handshake mit einem RS485-Koppler wurde um die   ∫
  ∫   Mîglichkeit des Receiver-Disables erweitert (Argumentnummer 5).         ∫
  »ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº




                                     @405[ Fortsetzung ]                   @001[ öbersicht ]
.405
    Frame-Treiber-Library : History - VersionsÑnderungen (Fortsetzung)

  …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
  ∫ V2.10 -> V2.20  ≥ éLTERE VERSIONEN: Neue FunktionalitÑten/Fehlerbehebung  ∫
  «ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
  ∫ Neue FunktionalitÑten:                                                    ∫
  ∫ - FRM_read(): Das aufwendige Pollen des Inputs (ca. 300Ês) Åber den Auf-  ∫
  ∫   ruf FRM_read() kann nun Åber eine eigene Pollvariable auf eine if-      ∫
  ∫   Abfrage reduziert werden (Argumentnummer 15).                           ∫
  ∫                                                                           ∫
  ∫ Fehlerbehebung:                                                           ∫
  ∫ - Die RS485 hat am System 2005 (Haupt-CPU) nicht korrekt funktioniert,    ∫
  ∫   und die entsprechende LED wurde nicht korrekt gesetzt. Dieser Fehler    ∫
  ∫   ist behoben.                                                            ∫
  ∫ - Einbau einer entsprechenden Verriegelung um den Buserror (Fehler 9100), ∫
  ∫   der bei einem FRM_read()/FRM_write() auf einen nicht geîffneten Treiber ∫
  ∫   auftreten konnte, zu vermeiden.                                         ∫
  »ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº



                                     @406[ Fortsetzung ]                   @001[ öbersicht ]
.406
    Frame-Treiber-Library : History - VersionsÑnderungen (Fortsetzung)

  …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
  ∫ V2.00 -> V2.10  ≥ éLTERE VERSIONEN: Neue FunktionalitÑten/Fehlerbehebung  ∫
  «ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
  ∫ Neue FunktionalitÑten:                                                    ∫
  ∫ - FRM_close() ist implementiert, somit ist auch eine öberlagerung eines   ∫
  ∫   anderen Treibers mîglich.                                               ∫
  ∫ - FRM_open(): Der Stackbedarf wurde in dieser Version reduziert.          ∫
  ∫ - FRM_read() enthÑlt erweiterte Fehlermeldung fÅr fehlerhafte Puffer.     ∫
  ∫ - FRM_read() (C-Aufrufschnittstelle) unterstÅtzt die Timeout/Receive-     ∫
  ∫   Aktiv-Option.                                                           ∫
  ∫ - Das Schnittstellenmodul IF050 (System B&R 2005) mu· erst vor dem Aufruf ∫
  ∫   der Funktion FRM_open() gesteckt werden (nicht wie vorher bereits beim  ∫
  ∫   URINIT).                                                                ∫
  »ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº





                                     @407[ Fortsetzung ]                   @001[ öbersicht ]
.407
    Frame-Treiber-Library : History - VersionsÑnderungen (Fortsetzung)

  …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
  ∫ V2.00 -> V2.10  ≥ éLTERE VERSIONEN: Neue FunktionalitÑten/Fehlerbehebung  ∫
  «ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
  ∫ Fehlerbehebung:                                                           ∫
  ∫ - Bei der Version V2.00 traten Probleme auf, wenn neben der IF050 ein     ∫
  ∫   Remote Master bzw. eine Netzwerkkarte gesteckt wurde.                   ∫
  ∫ - Bei der gleichzeitigen Verwendung von zwei IF050-Modulen konnte es zum  ∫
  ∫   Verlust von Interrupts kommen. Dieser Fehler ist fÅr die RPSSW V1.10    ∫
  ∫   behoben, fÅr die RPSSW V1.05 mu· der Bugfix 15 (F) geladen sein.        ∫
  ∫ - Die Funktion FRM_reloutbuf (C-Aufrufschnittstelle) funktionierte nicht  ∫
  ∫   korrekt.                                                                ∫
  ∫ - Bei der Verwendung von mehreren Sendepuffern hat es Probleme gegeben.   ∫
  ∫   Hier wurde der Fehler "kein Puffer verfÅgbar" zurÅckgegeben, obwohl     ∫
  ∫   noch Sendepuffer verfÅgbar waren.                                       ∫
  »ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº




                                     @408[ Fortsetzung ]                   @001[ öbersicht ]
.408
    Frame-Treiber-Library : History - VersionsÑnderungen (Fortsetzung)

  …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
  ∫ V1.05.3 -> V2.00   ≥ éLTERE VERSIONEN: Neue FunktionalitÑten              ∫
  «ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
  ∫ Neue FunktionalitÑten:                                                    ∫
  ∫ - UnterstÅtzung der RPSSW V1.10.                                          ∫
  ∫ - Zwei IF050-Module werden unterstÅtzt.                                   ∫
  ∫ - IF050 mu· beim Treiber-Download nicht vorhanden sein.                   ∫
  ∫ - Die Schnittstelle wird im FRM_open() voll initialisiert, d.h. man kann  ∫
  ∫   sich ohne Probleme Åber bereits existierende Treiber (z.B. PG-Treiber)  ∫
  ∫   "drÅberlegen". Ein RESTORE des alten Treibers ist derzeit noch nicht    ∫
  ∫   realisiert.                                                             ∫
  »ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº







                                     @409[ Fortsetzung ]                   @001[ öbersicht ]
.409
    Frame-Treiber-Library : History - VersionsÑnderungen (Fortsetzung)

  …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
  ∫ V1.05.2 -> V1.05.3 ≥ éLTERE VERSIONEN: Neue FunktionalitÑten              ∫
  «ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∂
  ∫ Neue FunktionalitÑten:                                                    ∫
  ∫ - Die neuen FUBs V1.05.3 funktionieren nicht mit dem alten Treiber        ∫
  ∫   (NamensÑnderung sfi auf frm).                                           ∫
  ∫ - FRM_open(): Die Schnittstelle des FUBs hat sich stark verÑndert         ∫
  ∫   (zusÑtzliche und teilweise andere Parameter).                           ∫
  ∫ - HW- und SW-Handshake fÅr die RS232-Leitung.                             ∫
  ∫ - Vier Frame-Abschlu·zeichen werden unterstÅtzt.                          ∫
  ∫ - Neue Dateien fÅr die Programmierung mit der C-Toolbox (C-Interface).    ∫
  ∫   Neue Includedatei frame.e (vormals dvframe.e).                          ∫
  ∫ - Beispiel in Form einer exportierten Task (FRMTEST.XPE) zur leichteren   ∫
  ∫   Bedienung/Einarbeitung in die FUBs mit darstellbaren Zeichen fÅr ein    ∫
  ∫   Terminal bzw. eine Terminalemulation (PG-Version V1.25 Exportdatei).    ∫
  ∫ - Vorbereitungen fÅr den Multidropmode und fÅr AussprÅnge aus dem Treiber ∫
  ∫   (C-Programmierung) zur besseren Bedienung von Sondersituationen.        ∫
  »ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº

                                       @200[ ANHANG ]                      @001[ öbersicht ]

.End
