$ Online Hilfe fuer die System 2000 Profibus Fubs -> Zeile 1236
%%
1,0:001
%%
.1
    PROFIBUS Library Functions

    Data can be read from a PROFIBUS station, or data can be sent to a PROFIBUS
    station using the PROFIBUS library functions.
    The following function groups are available after the PROFIBUS library has
    been imported:
     
    @020[< Initialization         >] PROFIBUS Initialization
    @030[< Connection Management  >] Make/Break Connection
    @070[< Variable Services      >] Read/Write Variables
    @240[< OV Management          >] Access to Object Directory
    @270[< Receive                >] Receive Telegrams
    @280[< Send                   >] Send Telegrams
    @400[< Information Report     >] Send Data Telegrams
    @410[< Send Status            >] Send Status Telegrams
    @420[< Download Services      >] Transfer B&R Modules
    @440[< Event Services         >] Event Management Services
    @470[< Services for C110      >] Functions for C110 Slave Controller Module

    Please note the PROFIBUS function @560[Guidelines]!

    @002[ Continue ]                        @550[ APPENDIX ]                      @999[ End HELP ]
.2
    PROFIBUS Library Functions (continue)

  ษอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ ATTENTION: As the PROFIBUS library contains AVT functions, the library    บ
  บ            functions can only be used if the Library Runtime Module       บ
  บ            (B&R module PB_LIB.BR) exists on the CPU (application ROM)!    บ
  ศอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ














                                      @550[ APPENDIX ]                      @001[ Overview ]
.20
    PROFIBUS Library - Initialization

    The initialization group contains a function for PROFIBUS initialization.

    @021[PBinit] PROFIBUS Initialization
















                                                                      @001[ Overview ]
.21
    PBinit - PROFIBUS Initialization

    @022[PBinit](enable,srv_cnt,memsize,par_ptr,error_nr,memadr)

    Parameter Data Types :
    ->  enable    : BIT           The function block is only executed if 
                                  enable = 1.
    ->  @025[srv_cnt   ]: WORD          Number of buffers to be reserved.
    ->  memsize   : LONG          Size of the memory area to be reserved for the
                                  user in the DPR (Dual Ported RAM) of the
                                  network controller (see @110[PBrdDPR] and
                                  @170[PBwrDPR] functions).
    ->  par_ptr   : LONG          This parameter has no function at present, and
                                  this value must always have the value 0!
    <-  @800[error_nr  ]: WORD          Error number (0 = no error).
    <-  memadr    : LONG          Address of the memory area (in the DPR of
                                  the network controller), available to the
                                  user.



                                      @022[ Continue ]                      @001[ Overview ]
.22
    PBinit - PROFIBUS Initialization (continue)

    The PBinit() function initializes all structures necessary for operating
    PROFIBUS function blocks in the DPR of the network controller.

    Notes:
    - The PBinit() function is only allowed to be called in the initialization
      sub-programs (INIT SPs) of the cyclic task.
    - You also have to ensure that no other PROFIBUS library functions
      blocks are active before calling the PBinit() function.
    - You have to ensure that the PBinit() function is only called ONCE after
      each INIT or TOTALINIT. This can cause an error, for example, when 
      downloading a task which calls the PBinit() function in the INIT SP.
    - The number of @025[Reserved Buffers] must be greater than or equal to the 
      number of PROFIBUS function blocks used.






                                   @020[ Initialization ]                   @001[ Overview ]
.25
    PBinit - PROFIBUS Initialization (continue)

    -> Parameter <srv_cnt   >: WORD

    Number of buffers to be reserved.
    When the PBinit() function is called, the given number of buffers is
    reserved in the DPR of the network controller.
    If messages are sent from a PROFIBUS function block, a buffer is needed
    until a response is sent for the service. This means that a buffer must be
    reserved in the DPR of the network controller for each PROFIBUS function
    block (except @031[PBinfoKR], @040[PBstatKR] and @050[PBsyncKR]).
    The number of reserved buffers corresponds to the possible number of 
    PROFIBUS services, and must therefore be greater than or equal to the
    total number of active PROFIBUS function blocks.
    The required buffer is selected the first time the function block is
    activated. The same buffer is always accessed each time this function
    block is activated.




                                       @021[ PBinit ]                       @001[ Overview ]
.30
    PROFIBUS Library - Connection Management

    You can make or break the connection, or determine the status of a
    connection etc. using the functions in this group. 

    @031[PBinfoKR] Request Connection Information
    @040[PBstatKR] Request Connection Status
    @050[PBsyncKR] Read Sync Counter for a Connection
    @060[PBautoKR] Make or Break Connection












                                                                      @001[ Overview ]
.31
    PBinfoKR - Request Connection Information

    @032[PBinfoKR](enable,adr(name),adr(info_ptr),error_nr,kr)

    Parameter Data Types :
    ->  enable    : BIT           The function block is only executed if 
                                  enable = 1.
    ->  @035[name      ]: BYTE (array)  Symbolic name of the desired connection
                                  (from the communication connection list) as
                                  string. The string can be entered in two
                                  different ways:
                                  adr(name)  Address of the BYTE array variable
                                             containing the string
                                  "name"     Constant string (must be entered in
                                             quotation marks!)
    <-> @036[info_ptr  ]: KR structure  Structure in which additional information for
                                  the desired connection is placed. If the value
                                  0 is given for adr(info_ptr), no additional 
                                  information is returned for the connection.


                                      @032[ Continue ]                      @001[ Overview ]
.32
    PBinfoKR - Request Connection Information (continue)

    <-  @800[error_nr  ]: WORD          Error number (0 = no error).
    <-  kr        : WORD          Communication reference (logical connection
                                  number) for the given symbolic name. The 
                                  logical connection number is needed for many
                                  other functions of the PROFIBUS library.

    With this function, the respective communication reference (logical
    connection number), and other information about the connection, can be
    determined by entering the symbolic name of the desired connection.
    This service is responded to immediately. The result is available after the
    function block has been called. The service does not require a buffer.








                                @030[ Connection Management ]               @001[ Overview ]
.35
    PBinfoKR - Request Connection Information (continue)

    -> Parameter <name      >: BYTE (array)

    Symbolic name of the desired connection. The symbolic name of a connection
    is defined in the communication connection list (KBL) (see parameter [Name]
    for the communication connection list).
    You can find detailed information on the communication connection list in
    the "PROFIBUS User's Manual".












                                      @031[ PBinfoKR ]                      @001[ Overview ]
.36
    PBinfoKR - Request Connection Information (continue)

    <-> Parameter <info_ptr  >: KR structure

    Structure where the additional information about the connection is placed.
    Elements of the "KR" structure:

    src_adr    : BYTE    Address of the local station
    dest_adr   : BYTE    Address of the target station
    src_kanal  : BYTE    Communication channel on the local station
                         (Source SAP)
    dest_kanal : BYTE    Communication channel on the target station
                         (Destination SAP)
    maxSCC     : BYTE    Maximum number of parallel confirmed services
    maxSAC     : BYTE    Maximum number of parallel unconfirmed services
    spdu_len   : BYTE    Size of send buffer
    rpdu_len   : BYTE    Size of receive buffer
    device_nr  : BYTE    Device number
    reserve    : BYTE    Reserved


                                      @031[ PBinfoKR ]                      @001[ Overview ]
.40
    PBstatKR - Request Connection Status

    @041[PBstatKR](enable,kr,error_nr,status)

    Parameter Data Types:
    ->  enable    : BIT           The function block is only executed if
                                  enable = 1.
    ->  kr        : WORD          Communication reference (logical connection
                                  number). Gives the connection whose status
                                  is to be determined. See function block
                                  @031[PBinfoKR].
    <-  @800[error_nr  ]: WORD          Error number (0 = no error).
    <-  status    : BYTE          Current connection status:
                                  $00 ... connection broken
                                  $55 ... connection being made
                                  $FF ... connection is made

    You can determine the current status of the given connection with
    this function.


                                      @041[ Continue ]                      @001[ Overview ]
.41
    PBstatKR - Request Connection Status (continue)

    This service is responded to immediately. The result is available after
    the function block has been called. This service does not need a buffer.

    Note:
    Variable services, download services etc. are only possible with 
    established connections ("status" = $FF)!













                                @030[ Connection Management ]               @001[ Overview ]
.50
    PBsyncKR - Read Sync Counter for a Connection

    @051[PBsyncKR](enable,kr,dir,error_nr,count)

    Parameter Data Types:
    ->  enable    : BIT           The functions block is only executed if 
                                  enable = 1.
    ->  kr        : WORD          Communication reference (logical connection
                                  number, see function block @031[PBinfoKR]). States
                                  the connection whose sync counter is to be 
                                  read.
    ->  dir       : BYTE          0 ... read receive sync counter
                                  1 ... read send sync counter
    <-  @800[error_nr  ]: WORD          Error number (0 = no error).
    <-  count     : BYTE          Current count in the receive sync counter
                                  (dir = 0) or in the send sync counter
                                  (dir = 1).

    A send sync counter and a receive sync counter for each connection is
    available on the controller.

                                      @051[ Continue ]                      @001[ Overview ]
.51
    PBsyncKR - Read Sync Counter for a Connection (continue)

    The send sync counter is incremented each time a telegram is sent, and
    the receive sync counter is incremented each time a telegram is received.
    The current value in the send sync counter or the receive sync counter
    for the given connection can be determined using the PBsyncKR() function.
    This service is responded to immediately. The result is available after
    the function block has been called. This service does not need a buffer.

    Notes:
    - The service can also be used for connections which are not configured
      for broadcast.
    - Note that not only data telegrams (e.g. Read/Write) increment the
      sync counters, but also network internal telegrams (e.g. telegrams for
      connection monitoring)!






                                      @052[ Continue ]                      @001[ Overview ]
.52
    PBsyncKR - Read Sync Counter for a Connection (continue)

    Application Example (time synchronization):
    A station sends a broadcast service to all other stations 
    (function @301[PBirepI]). The receive sync counter is incremented on each
    station immediately after the telegram is received. This happens almost
    simultaneously on all stations. This sync counter can now be checked
    cyclically on each station. The stations can be time synchronized depending
    on how often they are checked. The station which sent the telegram can also
    be synchronized by checking its send sync counter (the send counter is
    incremented immediately after sending the telegram).










                                @030[ Connection Management ]               @001[ Overview ]
.60
    PBautoKR - Make or Break Connection

    @061[PBautoKR](enable,kr,onoff,ready,error_nr)

    Parameter Data Types:
    ->  enable    : BIT           The function block is only executed if
                                  enable = 1.
    ->  kr        : WORD          Communication reference (logical connection
                                  number, see function block @031[PBinfoKR]). Gives
                                  the connection which is to be made or broken.
    ->  onoff     : BYTE          1 ... make connection
                                  0 ... break connection
    <-  ready     : BIT           Service was carried out without error
    <-  @800[error_nr  ]: WORD          Error number (0 = no error).

    The stated connection is made or broken using this function. If the input
    parameter "onoff" = 1, the connection is made. If this connection is broken
    by a disturbance on the network (e.g. bus connector unplugged), the network
    controller automatically tries to re-establish the connection. 


                                      @061[ Continue ]                      @001[ Overview ]
.61
    PBautoKR - Make or Break Connection (continue)

    If the target station (to which the connection should be made) is not
    available, the network controller tries to establish the connection
    again at definable intervals (parameter vb_ci in CCl, see "PROFIBUS
    User's Manual") until the target station responds.
    This automatic connection establishing can be switched off by recalling
    the PBautoKR() function using "onoff" = 0.
    This service call is only ended if the "ready" output is set "ready" = 1
    or an error occurs. This service requires a buffer.











                                      @062[ Continue ]                      @001[ Overview ]
.62
    PBautoKR - Make or Break Connection (continue)

    Notes:
    - The user only has to call the PBautoKR() function once for a connection
      ("onoff" = 1), then the network controller handles the connection
      independently.
    - If a connection is already set to "onoff" = 1, re-calling the
      PBautoKR() function with "onoff" = 1 causes an error.
    - If the output parameter is "ready" = 1, it doesn't mean that the
      connection is established, just that the switch to automatic 
      connection establishing has been accepted without error.
    - The @040[PBstatKR] function can determine if the connection is established
      or not.
    - If the connection is already set to automatic in the configuration 
      (parameter vb_info in the CCl, see "PROFIBUS User's Manual"), the 
      automatic mode cannot be switched off with this function!





                                @030[ Connection Management ]               @001[ Overview ]
.70
    PROFIBUS Library - Variable Services

    The function group variable services contains functions to read and write
    to other variables on another PROFIBUS station (see @230[Example]).

    @071[PBreadI ] Read variable/variable lists via index
    @080[PBreadN ] Read variable/variable lists via name
    @090[PBreadX ] Read variable extended (longer than a frame)
    @100[PBreadP ] Read variable via physical address
    @110[PBrdDPR ] Read memory from the reserved DPR area
    @120[PBrdDVL ] Read variables via dynamic variable lists
    @130[PBwriteI] Write variable/variable list via index
    @140[PBwriteN] Write variable/variable lists via name
    @150[PBwriteX] Write variable extended (longer than a frame)
    @160[PBwriteP] Write variable via physical address
    @170[PBwrDPR ] Write memory in reserved DPR area
    @180[PBwrDVL ] Write variables via dynamic variable lists
    @190[PBdefVLI] Define variable lists via index
    @200[PBdefVLN] Define variable lists via name
    @210[PBdelVLI] Delete variable lists via index
    @220[PBdelVLN] Delete variable lists via name
                                                                      @001[ Overview ]
.71
    PBreadI - Read Variable/Variable Lists Via Index

    @072[PBreadI](enable,kr,index,subindex,adr(data),len,ready,error_nr)

    Parameter Data Types:
    ->  enable    : BIT           The function block is only executed if 
                                  enable = 1.
    ->  kr        : WORD          Communication reference (logical connection
                                  number, see function block @031[PBinfoKR]). Gives
                                  the target station to be read from.
    ->  @075[index     ]: WORD          PROFIBUS index of the variable or the
                                  variable lists, which is to be read from the
                                  target station. The PROFIBUS index can be
                                  determined using the @250[PBgetOVN] function.
    ->  @076[subindex  ]: WORD          Sub-index of the variable, which is to be read
                                  from the target station. The value 0 must
                                  always be given for the sub-index, when 
                                  reading variable lists.



                                      @072[ Continue ]                      @001[ Overview ]
.72
    PBreadI - Read Variable/Variable Lists Via Index (continue)

    <-> data      : ALL           Data buffer where the read data is placed.
    ->  len       : WORD          Size of the data buffer (data) in bytes.
    <-  ready     : BIT           Service is finished.
    <-  @800[error_nr  ]: WORD          Error number (0 = no error).

    A variable/variable list can be read from another PROFIBUS station using
    the PBreadI() function. Referencing the variable/variable list occurs via
    the PROFIBUS index for this variable/variable list given in the object
    description.
    The read data is written in the defined data buffer ("data"). The parameter
    "len" doesn't state the length of the data to be read, but the size of the 
    local data buffer (the length of the data is determined by the object on the
    target station). The size of the data buffer must be greater than or equal
    to the length of the read variable, or an error is registered!





                                      @073[ Continue ]                      @001[ Overview ]
.73
    PBreadI - Read Variable/Variable Lists Via Index (continue)

    This service call is only complete when the output parameter "ready" = 1,
    or an error is registered. This service requires a buffer.

    Only those variables/variable lists whose lengths do not exceed the maximum
    length of a PROFIBUS frame (approx. 230 bytes) can be accessed with this
    function! The function PBreadX() must be used for variables with a length
    greater than 230 bytes.

    Note:
    Variable lists can be defined using the functions @190[PBdefVLI] and @200[PBdefVLN]!









                                  @070[ Variable Services ]                 @001[ Overview ]
.75
    PBreadI - Read Variable/Variable Lists Via Index (continue)

    -> Parameter <index     >: WORD

    PROFIBUS index of the variable/variable list to be read on the target 
    station.
    This index can be determined using the @250[PBgetOVN] function. This function
    returns the @650[Object Description] for an object on the target station.
    The first element (element "Index", data type WORD) of this object
    description contains the index of the variable/variable list.











                                       @071[ PBreadI ]                      @001[ Overview ]
.76
    PBreadI - Read Variable/Variable Lists Via Index (continue)

    -> Parameter <subindex  >: WORD

    @400[Sub-Index] of the variable to be read. When reading variable lists, the
    value 0 must always be entered for the sub-index.















                                       @071[ PBreadI ]                      @001[ Overview ]
.80
    PBreadN - Read Variable/Variable List Via Name

    @081[PBreadN](enable,kr,spec_id,adr(name),subindex,adr(data),len,ready,error_nr)

    Parameter Data Types:
    ->  enable    : BIT           The function block is only executed if 
                                  enable = 1.
    ->  kr        : WORD          Communication reference (logical connection
                                  number, see function block @031[PBinfoKR]). Gives
                                  the target station which is to be read from.
    ->  spec_id   : BYTE          The spec_id parameter determines if the name
                                  of a variable or variable list will be entered
                                  for the name parameter:
                                  1 ... Name of a process variable
                                  2 ... Name of a variable list
    ->  name      : BYTE (array)  Name of the process variable (PV name) or name
                                  of the variable list on the target station
                                  (as string).



                                      @081[ Continue ]                      @001[ Overview ]
.81
    PBreadN - Read Variable/Variable List Via Name (continue)

                                  The string can be entered in two different
                                  ways:
                                  adr(name)    Address of the BYTE array
                                               variable which contains the
                                               string
                                  "name"       Constant string (must be entered
                                               in quotation marks!)
    ->  @085[subindex  ]: WORD          Sub-index of the variable to be read
                                  from the target station. The value 0 must
                                  always be entered for the sub-index when
                                  reading variables.
    <-> data      : ALL           Data buffer in which the read data is placed.
    ->  len       : WORD          Size of the data buffer (data) in bytes.
    <-  ready     : BIT           Service is finished.
    <-  @800[error_nr  ]: WORD          Error number (0 = no error).




                                      @082[ Continue ]                      @001[ Overview ]
.82
    PBreadN - Read Variable/Variable List Via Name (continue)

    A variable/variable list can be read from another PROFIBUS station using
    the PBreadN() function. Referencing the variable/variable list takes
    place using the PV name/variable list name.
    The read data is written in the given data buffer ("data"). The "len"
    parameter does not give the length of the data to be read, but the size of
    the local data buffer (the length of the data is determined by the object on
    the target station). The size of the data buffer must be greater than or
    equal to the length of the variable read, otherwise an error occurs!
    This service call is only finished when the output parameter is "ready" = 1
    or an error is reported. This service needs a buffer.

    Only those variables/variable lists whose lengths do not exceed the maximum
    length of a PROFIBUS frame (approx. 230 bytes) can be accessed with this
    function! The @090[PBreadX] function is used for those variables with a length
    greater than 230 bytes.




                                      @083[ Continue ]                      @001[ Overview ]
.83
    PBreadN - Read Variable/Variable List Via Name (continue)

    Note:
    Variable lists can be defined with the functions @190[PBdefVLI] and @200[PBdefVLN]!

    Accessing variables using their PV names is simple but significantly slower
    than accessing using the PROFIBUS index via the @071[PBreadI] function.














                                  @070[ Variable Services ]                 @001[ Overview ]
.85
    PBreadN - Read Variable/Variable List Via Name (continue)

    -> Parameter <subindex  >: WORD

    @400[Sub-Index] of the variable to be read. When reading variable lists, the
    value 0 must always be entered for the sub-index.















                                       @080[ PBreadN ]                      @001[ Overview ]
.90
    PBreadX - Read Variable Extended (longer than a frame)

    @091[PBreadX](enable,kr,offset,adr(name),adr(data),len,ready,error_nr)

    Parameter Data Types:
    ->  enable    : BIT           The function block is only executed if 
                                  enable = 1.
    ->  kr        : WORD          Communication reference (logical connection
                                  number, see function block @031[PBinfoKR]). States
                                  the target station which is to be read from.
    ->  @095[offset    ]: WORD          Offset (in relation to the address of the
                                  variable) which is to be read from.
    ->  name      : BYTE (array)  Name of the process variable (PV name) on the
                                  target station (as string).
                                  






                                      @091[ Continue ]                      @001[ Overview ]
.91
    PBreadX - Read Variable Extended (longer than a frame) (continue)

                                  The string can be entered in two different
                                  ways:
                                  adr(name)    Address of the BYTE array
                                               variable which contains the
                                               string
                                  "name"       Constant string (must be entered
                                               in quotation marks!)
    <-> data      : ALL           Data buffer where the read data is put.
    ->  len       : WORD          Length of the data to be read in bytes.
    <-  ready     : BIT           Service is finished.
    <-  @800[error_nr  ]: WORD          Error number (0 = no error).

    This function enables variables, whose length exceed the maximum possible
    length of a PROFIBUS frame (approx. 230 bytes), to be read. More than one
    access is needed to read the entire variable. However, this is not a problem
    for the user, as the accesses are carried out by the function and are
    acknowledged like a single read when the service is completed.
    The read data is written in the given data buffer ("data"). The parameter
    "len" states the length of the data to be read.
                                      @092[ Continue ]                      @001[ Overview ]
.92
    PBreadX - Read Variable Extended (longer than a frame) (continue)

    This service call is only finished when the output parameter 
    "ready" = 1 or an error is registered. The service needs a buffer.

    Internal Operation of the Function:
    - First, the object description for the desired variable is requested via
      its PV name with the Get OV service. The physical address of the variable
      can be determined in this way. 
    - Then a physical read service is executed beginning at this physical
      address (plus the defined Offset "offset") until the data length "len"
      is read from the data area defined with the data parameter.
    - The Get OV service is only carried out for the first service request. If
      the PV name and the logical connection number do not change for further
      calls, the physical read service will be executed directly.






                                      @093[ Continue ]                      @001[ Overview ]
.93
    PBreadX - Read Variable Extended (longer than a frame) (continue)

    Note:
    The PBreadX() function is not a standard PROFIBUS service, Therefore this
    function can only be used for data exchange between B&R devices!
















                                  @070[ Variable Services ]                 @001[ Overview ]
.95
    PBreadX - Read Variable Extended (longer than a frame) (continue)

    -> Parameter <offset    >: WORD

    The "offset" parameter is meaningful when accessing elements of arrays
    or structures. This parameter indicates the offset (in bytes) which will
    be used when reading the elements of a structure or array variable.
    The value 0 must be entered for the "offset" parameter in order to read the
    entire array or structure!
    Should, for example, an array variable (data type LONG, length 60) be read
    starting with the third element (element with index 2), then the value 8
    (2 LONG = 8 Byte) must be entered for the "offset" parameter!









                                       @090[ PBreadX ]                      @001[ Overview ]
.100
    PBreadP - Read Variable Via Physical Address

    @101[PBreadP](enable,kr,phy_adr,adr(data),len,ready,error_nr)

    Parameter Data Types:
    ->  enable    : BIT           The function block is only executed if 
                                  enable = 1.
    ->  kr        : WORD          Communication reference (logical connection
                                  number, see function block @031[PBinfoKR]). States
                                  the target station which is to be read from.
    ->  @105[phy_adr   ]: LONG          Physical address of the variable on the
                                  target station. 
                                  The physical address can be determined using
                                  the @250[PBgetOVN] function.
    <-> data      : ALL           Data buffer where the read data is placed.






                                      @101[ Continue ]                      @001[ Overview ]
.101
    PBreadP - Read Variable Via Physical Address (continue)

    ->  len       : WORD          Length of the data to be read in bytes. If
                                  the length of the data to be read exceeds
                                  the maximum possible size of a PROFIBUS frame
                                  (approx. 230 bytes), the data is automatically
                                  divided into several transfers.
    <-  ready     : BIT           Service is finished.
    <-  @800[error_nr  ]: WORD          Error number (0 = no error).

    A variable can be read from another PROFIBUS station using the PBreadP()
    function. Referencing the variable occurs via the physical address for
    this variable given in the object description.
    The read data is written in the given data buffer ("data"). The parameter
    "len" states the length of the data to be read.
    The length is not checked on the target station.

    This service call is only finished when the output parameter is 
    "ready" = 1 or an error is registered. The service needs a buffer.


                                  @070[ Variable Services ]                 @001[ Overview ]
.105
    PBreadP - Read Variable Via Physical Address (continue)

    -> Parameter <phy_adr   >: LONG

    Physical address of the data to be read on the target station.
    The physical address can be determined via the PBgetOVN function.
    This function returns the @650[Object Description] for an object on the target
    station. The element "Local Address" (data type LONG) in this object
    description contains the physical address of the variable.












                                       @100[ PBreadP ]                      @001[ Overview ]
.110
    PBrdDPR - Read Memory From The Reserved DPR Area

    @111[PBrdDPR](enable,kr,offset,adr(data),len,ready,error_nr)

    Parameter Data Types:
    ->  enable    : BIT           The function block is only executed if 
                                  enable = 1.
    ->  kr        : WORD          Communication reference (logical connection
                                  number, see function block @031[PBinfoKR]). States
                                  the target station which is to be read from.
    ->  offset    : WORD          Offset in the DPR (Dual Ported RAM) on the
                                  target station.
    <-> data      : ALL           Data buffer where the read data is placed.
    ->  len       : WORD          Length of the data to be read in bytes.
    <-  ready     : BIT           Service is finished.
    <-  @800[error_nr  ]: WORD          Error number (0 = no error).





                                      @111[ Continue ]                      @001[ Overview ]
.111
    PBrdDPR - Read Memory From The Reserved DPR Area (continue)

    Data from the Dual Ported RAM on the network controller with the 
    PBrdDPR() function. This means that this function enables direct access
    to the memory area in the DPR on the network controller, which is available
    to the user. This memory area must be reserved on the target station by
    calling the @021[PBinit] function (then the memory area can be accessed using
    the "memadr" output parameter of the PBinit() function).
    The read data is written in the given data buffer ("data"). The parameter
    "len" states the length of the data to be read.

    This service call is only finished when the output parameter is 
    "ready" = 1 or an error is registered. This service needs a buffer.








                                      @112[ Continue ]                      @001[ Overview ]
.112
    PBrdDPR - Read Memory From The Reserved DPR Area (continue)

    Notes:
    - Data consistency is not guaranteed. This means that the user must 
      ensure that the application on the target station is not accessing the
      data in the DPR during the read operation (the data is copied from the
      DPR by the network controller byte-wise in increasing order, no WORD,
      LONG consistency!).
    - The function PBrdDPR() is not a standard PROFIBUS service; therefore this
      function can only be used for data exchange between two B&R devices!
    - The DPR on the network controller is volatile.










                                  @070[ Variable Services ]                 @001[ Overview ]
.120
    PBrdDVL - Read Variables Via Dynamic Variable List

    @121[PBrdDVL](enable,kr,adr(liste),anzahl,ind_phy,adr(data),len,ready,
            error_nr,rdlen)

    Parameter Data Types:
    ->  enable    : BIT           The function block is only executed if 
                                  enable = 1.
    ->  kr        : WORD          Communication reference (logical connection
                                  number, see function block @031[PBinfoKR]). States
                                  the target station to be read from.
    ->  @125[liste     ]: WORD (array)  Dynamic variable list in the form of an array
                    or            variable. The variables are defined in the
                    LONG (array)  variable list via the PROFIBUS indices
                                  (variable list = WORD array) or via the
                                  physical addresses (variable list =
                                  LONG array).




                                      @121[ Continue ]                      @001[ Overview ]
.121
    PBrdDVL - Read Variables Via Dynamic Variable List (continue)

                                  The PROFIBUS indices or physical addresses
                                  of the variables on the target station
                                  can be determined using the @250[PBgetOVN] function.
    ->  anzahl    : BYTE          Number of variables in the variable list
                                  (liste).
    ->  ind_phy   : BYTE          Access via PROFIBUS index or physical address:
                                  0 ... List with PROFIBUS indices
                                        (variable list = WORD array)
                                  1 ... List with physical addresses
                                        (variable list = LONG array)
    <-> data      : ALL           Data buffer where the read data is placed.
    ->  len       : WORD          Length of the data to be read (in bytes).







                                      @122[ Continue ]                      @001[ Overview ]
.122
    PBrdDVL - Read Variables Via Dynamic Variable List (continue)

    <-  ready     : BIT           Service is finished.
    <-  @800[error_nr  ]: WORD          Error number (0 = no error).
    <-  rdlen     : WORD          Length of the read data (in bytes).

    The PBrdDVL() function enables several variables to be read from a list
    (dynamic variable list). When this function is called, a read instruction
    is sent to the target station in the form of a list of PROFIBUS indices
    or physical addresses. The target station responds with the values of the
    requested variables. The values are written in the given data buffer
    ("data"). The number of variables in the list is limited by the maximum 
    PROFIBUS frame length (approx. 230 bytes). This means that the length of
    the individual variables must be known implicitly by the user.

    This service call is only finished when the output parameter is "ready" = 1
    or an error is registered. The service needs a buffer.




                                      @123[ Continue ]                      @001[ Overview ]
.123
    PBrdDVL - Read Variables Via Dynamic Variable List (continue)

    Note:
    The PBrdDVL() function is not a standard PROFIBUS service, therefore this
    function can only be used for data exchange between two B&R devices!
















                                  @070[ Variable Services ]                 @001[ Overview ]
.125
    PBrdDVL - Read Variables Via Dynamic Variable List (continue)

    -> Parameter <liste     >: WORD (array) or LONG (array)

    Dynamic variable list in the form of an array variable.
    The variables are defined in the dynamic variable list via the PROFIBUS
    indices (variable list = WORD array) or via the physical addresses
    (variable list = LONG array).
    The PROFIBUS indices or physical addresses of the variables on the
    target station can be determined using the @250[PBgetOVN] function. This function
    returns the @650[Object Description] of an object on the target station.
    The "Index" element (data type WORD) in this object description contains the
    PROFIBUS index of the variable, the element "Local Address" (data type LONG)
    contains the physical address of the variable.







                                       @120[ PBrdDVL ]                      @001[ Overview ]
.130
    PBwriteI - Write Variable/Variable List Via Index

    @131[PBwriteI](enable,kr,index,subindex,adr(data),len,ready,error_nr)

    Parameter Data Types:
    ->  enable    : BIT           The function block is only executed if 
                                  enable = 1.
    ->  kr        : WORD          Communication reference (logical connection
                                  number, see function block @031[PBinfoKR]).
    ->  @135[index     ]: WORD          PROFIBUS index of the variable or variable
                                  list to be written on the target station.
                                  The PROFIBUS index can be determined using 
                                  the @250[PBgetOVN] function.
    ->  @136[subindex  ]: WORD          Sub-index of the variable to be written on the
                                  target station. The value 0 must always be
                                  entered when writing variable lists.
    ->  data      : ALL           Data buffer where the data to be written is
                                  entered.



                                      @131[ Continue ]                      @001[ Overview ]
.131
    PBwriteI - Write Variable/Variable List Via Index (continue)

    ->  len       : WORD          Length of data to be written (in bytes).
    <-  ready     : BIT           Service is finished.
    <-  @800[error_nr  ]: WORD          Error number (0 = no error).

    A variable/variable list can be written to another PROFIBUS station
    using the PBwriteI() function. Referencing the variable/variable list
    occurs via the PROFIBUS index for this variable/variable list given
    in the object description.
    The data to be written must be placed in the data buffer "data". The
    "len" parameter states the length of the data to be written. The user
    has to make sure that the given length corresponds to the length of
    the object on the target station! If the given length is larger or smaller
    than the actual length of the object on the target station, an error message
    is given on the target station.

    This service call is only finished when the output parameter is "ready" = 1
    or an error is registered. The service needs a buffer.


                                      @132[ Continue ]                      @001[ Overview ]
.132
    PBwriteI - Write Variable/Variable List Via Index (continue)

    Only those variables/variable lists whose lengths do not exceed the maximum
    length of a PROFIBUS frame (approx. 230 bytes) can be accessed with this
    function! The PBwriteX() function must be used for variables with a length
    greater than 230 bytes.

    Note:
    Variable lists can be defined with the functions @190[PBdefVLI] and @200[PBdefVLN]!












                                  @070[ Variable Services ]                 @001[ Overview ]
.135
    PBwriteI - Write Variable/Variable List Via Index (continue)

    -> Parameter <index     >: WORD

    PROFIBUS index of the variable/variable list to be written on the target 
    station. This index can be determined using the @250[PBgetOVN] function.
    This function returns the @650[Object Description] for an object on the target
    station. The first element (element "Index", data type WORD) in this object
    description contains the index of the variable/variable list.












                                      @130[ PBwriteI ]                      @001[ Overview ]
.136
    PBwriteI - Write Variable/Variable List Via Index (continue)

    -> Parameter <subindex  >: WORD

    @402[Sub-Index] of the variable to be written. The value 0 must always be
    entered for the sub-index when writing variables.















                                      @130[ PBwriteI ]                      @001[ Overview ]
.140
    PBwriteN - Write Variable/Variable List Via Name

    @141[PBwriteN](enable,kr,spec_id,adr(name),subindex,adr(data),len,ready,error_nr)

    Parameter Data Types:
    ->  enable    : BIT           The function block is only executed if
                                  enable = 1.
    ->  kr        : WORD          Communication reference (logical connection
                                  number, see function block @031[PBinfoKR]).
    ->  spec_id   : BYTE          The parameter spec_id determines if the name
                                  of a variable or the name of a variable list
                                  will be entered for the name parameter:
                                  1 ... Name of a process variable
                                  2 ... Name of a variable list
    ->  name      : BYTE (array)  Name of the process variable (PV name) or name
                                  of the variable list on the target station
                                  (as string).




                                      @141[ Continue ]                      @001[ Overview ]
.141
    PBwriteN - Write Variable/Variable List Via Name (continue)

                                  The string can be entered in two different 
                                  ways:
                                  adr(name)    Address of BYTE array variable
                                               which contains the string
                                  "name"       Constant string (must be entered
                                               in quotation marks!)
    ->  @145[subindex  ]: WORD          Sub-index of the variable to be written on the
                                  target station. The value 0 must always be 
                                  entered for the sub-index when writing 
                                  variables.
    ->  data      : ALL           Data buffer where the data to be written
                                  is placed.
    ->  len       : WORD          Length of the data to be written (in bytes).
    <-  ready     : BIT           Service is finished.
    <-  @800[error_nr  ]: WORD          Error number (0 = no error).




                                      @142[ Continue ]                      @001[ Overview ]
.142
    PBwriteN - Write Variable/Variable List Via Name (continue)

    A variable/variable list can be written on another PROFIBUS station using
    the PBwriteN() function. Referencing the variable/variable list occurs 
    via the PV name/variable list name.
    The data to be written must be placed in the data buffer "data".
    The parameter "len" states the length of the data to be written. The
    user must make sure that the given length corresponds to the length of
    the object on the target station! If the given length is larger then
    or smaller than the actual length, an error occurs.
    This service call is only finished when the output parameter is
    "ready" = 1 or an error occurs. This service requires a buffer.

    Only those variables/variable lists whose lengths do not exceed the maximum
    length of a PROFIBUS frame (approx. 230 bytes) can be accessed! The @150[PBwriteX]
    function must be used for variables with a length greater than 230 bytes.





                                      @143[ Continue ]                      @001[ Overview ]
.143
    PBwriteN - Write Variable/Variable List Via Name (continue)

    Note:
    Variable lists can be defined using the functions @190[PBdefVLI] and @200[PBdefVLN]!

    Access to variables via their PV names is easier, but significantly slower
    than accessing via the PROFIBUS index with the @130[PBwriteI] function.














                                  @070[ Variable Services ]                 @001[ Overview ]
.145
    PBwriteN - Write Variable/Variable List Via Name (continue)

    -> Parameter <subindex  >: WORD

    @402[Sub-Index] of the variable to be written. The value 0 must always be
    entered for the sub-index when writing variables.















                                      @140[ PBwriteN ]                      @001[ Overview ]
.150
    PBwriteX - Write Variable Extended (longer than one frame)

    @151[PBwriteX](enable,kr,offset,adr(name),adr(data),len,ready,error_nr)

    Parameter Data Types :
    ->  enable    : BIT           The function block is only executed if
                                  enable = 1.
    ->  kr        : WORD          Communication reference (logical connection
                                  number, see function block @031[PBinfoKR]).
    ->  @155[offset    ]: WORD          Offset (in relation to the address of the
                                  variable) where the write is to begin.
    ->  name      : BYTE (array)  Name of the process variable (PV name) or
                                  name of the variable list on the target 
                                  station (as string).
                                  The string can be entered in two different
                                  ways:
                                  adr(name)    Address of BYTE array variable
                                               which contains the string
                                  "name"       Constant string (must be entered
                                               in quotation marks!)

                                      @151[ Continue ]                      @001[ Overview ]
.151
    PBwriteX - Write Variable Extended (longer than one frame) (continue)

    ->  data      : ALL           Data buffer where the data to be written is
                                  entered.
    ->  len       : WORD          Length of the data to be written (in bytes).
    <-  ready     : BIT           Service is finished.
    <-  @800[error_nr  ]: WORD          Error number (0 = no error).

    The PBwriteX() function enables variables whose length exceeds the maximum
    possible length of a PROFIBUS frame (approx. 230 bytes) to be written. 
    Several accesses are necessary to write the entire variable. This causes no
    problem for the user, as the accesses are carried out by the function, and
    are acknowledged like a single write when the service is completed.
    The data to be written must be placed in the data buffer "data". The
    parameter "len" states the length of the data to be written.

    This service call is only finished when the output parameter is "ready = 1
    or an error occurs. This service needs a buffer.



                                      @152[ Continue ]                      @001[ Overview ]
.152
    PBwriteX - Write Variable Extended (longer than one frame) (continue)

    Internal Operation of the Function:
    - First, the object description for the desired variable is requested via
      its PV name using the Get OV service. The physical address of the 
      variable can be determined in this way. 
    - Then a physical write service is executed, beginning at this physical
      address (plus the defined "offset"), until the given length is written
      to the data.
    - The Get OV service is only carried out for the first service request. If
      the PV name and the logical connection number do not change for further
      calls, the physical write service will be executed directly.

    Note:
    The PBwriteX() function is not a standard PROFIBUS service, therefore this
    function can only be used for data exchange between two B&R devices!





                                  @070[ Variable Services ]                 @001[ Overview ]
.155
    PBwriteX - Write Variable Extended (longer than one frame) (continue)

    -> Parameter <offset    >: WORD

    The "offset" parameter is meaningful when accessing elements of arrays or
    structures. This parameter states from which offset (in bytes) the
    elements of a structure or array variable will be written.
    The "offset" parameter must be given the value 0 to write the entire
    array or structure!
    If, for example, an array variable (data type LONG, length 60) is to be
    written starting with the third element (element with index 2), the value
    8 (2 LONG = 8 Byte) must be entered for the "offset" parameter!









                                      @150[ PBwriteX ]                      @001[ Overview ]
.160
    PBwriteP - Write Variable Via Physical Address

    @161[PBwriteP](enable,kr,phy_adr,adr(data),len,ready,error_nr)

    Parameter Data Types:
    ->  enable    : BIT           The function block is only executed if 
                                  enable = 1.
    ->  kr        : WORD          Communication reference (logical connection
                                  number, see function block @031[PBinfoKR]).
    ->  @165[phy_adr   ]: LONG          Physical address of the variable on the target
                                  station. The physical address can be 
                                  determined using the @250[PBgetOVN] function.
    ->  data      : ALL           Data buffer where the data to be written is
                                  placed.
    ->  len       : WORD          Length of the data to be written (in bytes).
                                  If the length of the data to be written
                                  exceeds the maximum possible size of a 
                                  PROFIBUS frame (approx. 230 bytes), the data
                                  is automatically divided into several
                                  transfers.

                                      @161[ Continue ]                      @001[ Overview ]
.161
    PBwriteP - Write Variable Via Physical Address (continue)

    <-  ready     : BIT           Service is finished.
    <-  @800[error_nr  ]: WORD          Error number (0 = no error).

    A variable on another PROFIBUS station can be written using this function.
    Referencing the variable occurs via the physical address of the variable
    given in the object description.
    The data to be written must be placed in the data buffer "data". The 
    "len" parameter gives the length of the data to be written. The length is
    not tested on the target station.

    This service call is only finished when the output parameter is 
    "ready" = 1 or an error occurs. The service requires a buffer.







                                  @070[ Variable Services ]                 @001[ Overview ]
.165
    PBwriteP - Write Variable Via Physical Address (continue)

    -> Parameter <phy_adr   >: LONG

    Physical address of the variable to be written on the target station.
    The physical address can be determined using the @250[PBgetOVN] function. This
    function returns the @650[Object Description] for an object on the target station.
    The element "Local Address" (data type LONG) in this object description
    contains the physical address of the variable.












                                      @160[ PBwriteP ]                      @001[ Overview ]
.170
    PBwrDPR - Write Memory in the Reserved DPR Area

    @171[PBwrDPR](enable,kr,offset,adr(data),len,ready,error_nr)

    Parameter Data Types:
    ->  enable    : BIT           The function block is only executed if
                                  enable = 1.
    ->  kr        : WORD          Communication reference (logical connection 
                                  number, see function block @031[PBinfoKR]).
    ->  offset    : WORD          Offset in the DPR (Dual Ported RAM) on the
                                  target station.
    ->  data      : ALL           Data buffer where the data to be written
                                  is placed.
    ->  len       : WORD          Length of the data to be written (in bytes).
    <-  ready     : BIT           Service is finished.
    <-  @800[error_nr  ]: WORD          Error number (0 = no error).





                                      @171[ Continue ]                      @001[ Overview ]
.171
    PBwrDPR - Write Memory in the Reserved DPR Area (continue)

    Data can be written to Dual Ported RAM on the network controller with the
    PBwrDPR() function. This means that this function enables direct access to
    the memory area in the DPR on the network controller, which is available to
    the user. This memory area must be reserved on the target station by 
    calling the @021[PBinit] function (then the PBinit() function on this memory area
    can be accessed via the output parameter "memadr").
    The data to be written must be placed in the data buffer "data". The
    "len" parameter gives the length of the data to be written. The length is
    not checked on the target station.

    This service call is only finished when the output parameter is
    "ready" = 1 or an error occurs. This service needs a buffer.







                                      @172[ Continue ]                      @001[ Overview ]
.172
    PBwrDPR - Write Memory in the Reserved DPR Area (continue)

    Notes:
    - Data consistency is not guaranteed. This means that the user must check
      that the application on the target station is not accessing the data in
      the DPR during the write operation (the data is copied from the DPR by
      the network controller byte-wise in increasing order, no WORD, LONG
      consistency.
    - The PBwrDPR() function is not a standard PROFIBUS service, therefore this
      function can only be used for data exchange between two B&R devices!
    - The DPR on the network controller is volatile (not buffered).










                                  @070[ Variable Services ]                 @001[ Overview ]
.180
    PBwrDVL - Write Variables Via Dynamic Variable List

    @181[PBwrDVL](enable,kr,adr(liste),anzahl,ind_phy,adr(data),len,ready,error_nr)

    Parameter Data Types:
    ->  enable    : BIT           The function block is only executed if 
                                  enable = 1.
    ->  kr        : WORD          Communication reference (logical connection 
                                  number, see function block @031[PBinfoKR]).
    ->  @185[liste     ]: WORD (array)  Dynamic variable list in the form of an array
                    or            variable. The variables are defined in the
                    LONG (array)  variable list via the PROFIBUS indices
                                  (variable list = WORD array) or via the
                                  physical addresses (variable list =
                                  LONG array).
                                  The PROFIBUS indices or the physical addresses
                                  of the variables on the target station can be
                                  determined with the @250[PBgetOVN] function.



                                      @181[ Continue ]                      @001[ Overview ]
.181
    PBwrDVL - Write Variables Via Dynamic Variable List (continue)

    ->  anzahl    : BYTE          Number of variables in the variable list
                                  (liste).
    ->  ind_phy   : BYTE          Access via PROFIBUS index or physical address:
                                  0 ... List with PROFIBUS indices
                                        (variable list = WORD array)
                                  1 ... List with physical addresses
                                        (variable list = LONG array)
    ->  data      : ALL           Data buffer where data to be written
                                  is placed.
    ->  len       : WORD          Length of data to be written (in bytes).
    <-  ready     : BIT           Service is finished:
    <-  @800[error_nr  ]: WORD          Error number (0 = no error).







                                      @182[ Continue ]                      @001[ Overview ]
.182
    PBwrDVL - Write Variables Via Dynamic Variable List (continue)

    The PBwrDVL() function enables several variables in a list (dynamic
    variable list) to be written. When this function is called, a write request
    is sent to the target station in the form of a list of PROFIBUS indices or
    physical addresses with the given data (parameter "data"). If the service
    is carried out without error, the target station responds with an
    acknowledgment. If an error occurs, the appropriate error number is
    returned at the "error_nr" output.
    This service call is only finished when the output parameter is "ready" = 1
    or an error occurs. This service requires a buffer.

    Note:
    The PBwrDVL() function is not a standard PROFIBUS service, therefore this
    function can only be used for data exchange between two B&R devices!






                                  @070[ Variable Services ]                 @001[ Overview ]
.185
    PBwrDVL - Write Variables Via Dynamic Variable List (continue)

    -> Parameter <liste     >: WORD (array) or LONG (array)

    Dynamic variable list in the form of an array variable.
    The variables are defined in the dynamic variable list via the PROFIBUS
    indices (variable list = WORD array) or via the physical addresses
    (variable list = LONG array).
    The PROFIBUS indices or physical addresses of the variables on the target
    station can be determined using the @250[PBgetOVN] function. This function returns
    the @650[Object Description] for an object on the target station.
    The element "Index" (data type WORD) in the object description contains the
    PROFIBUS index of the variable, the element "Local Address" (data type LONG)
    contains the physical address of the variable.







                                       @180[ PBwrDVL ]                      @001[ Overview ]
.190
    PBdefVLI - Define Variable List Via Index

    @191[PBdefVLI](enable,kr,adr(liste),anzahl,pw,group,rights,adr(name),ready,
             error_nr,newindex)

    Parameter Data Types:
    ->  enable    : BIT           The function block is only executed if 
                                  enable = 1.
    ->  kr        : WORD          Communication reference (logical connection
                                  number, see function block @031[PBinfoKR]).
    ->  liste     : WORD (array)  Variable list in form of an array variable.
                                  The variables are defined in the variable list
                                  via the PROFIBUS indices (variable list =
                                  WORD array). The PROFIBUS indices of the 
                                  variables on the target station can be 
                                  determined with the @250[PBgetOVN] function.
    ->  anzahl    : BYTE          Number of variables in the variable list
                                  (liste).



                                      @191[ Continue ]                      @001[ Overview ]
.191
    PBdefVLI - Define Variable List Via Index (continue)

    ->  pw        : BYTE          PROFIBUS password ("Password") which the new 
                                  variable list is to have. Default value is 0.
    ->  group     : BYTE          PROFIBUS group ("Access Groups") to which the
                                  new variable list is to belong. Default
                                  value is $FF.
    ->  rights    : WORD          PROFIBUS access rights ("Access Rights") which
                                  the new variable list is to have. Default
                                  value is $33.
    ->  name      : BYTE (array)  Name of  the new variable list (as string).
                                  The string can be entered in two different
                                  ways:
                                  adr(name)    Address of the BYTE array
                                               variable which contains 
                                               the string
                                  "name"       Constant string (must be entered
                                               in quotation marks!)
                                  If the value 0 is entered for adr(name), the
                                  variable list has no name.

                                      @192[ Continue ]                      @001[ Overview ]
.192
    PBdefVLI - Define Variable List Via Index (continue)

    <-  ready     : BIT           Service is finished.
    <-  @800[error_nr  ]: WORD          Error number (0 = no error).
    <-  newindex  : WORD          PROFIBUS index of the new variable list.

    This function creates a new variable list from the given variables
    (via the PROFIBUS indices).

    This service call is only finished when the output parameter is 
    "ready" = 1 or an error occurs. This service requires a buffer.

    All variables in this variable list can then be accessed with a single
    read or write command. When using the @071[PBreadI] and @130[PBwriteI] functions,
    referencing the variable list takes place via the PROFIBUS index 
    (parameter "newindex"). When using the functions @080[PBreadN] and @140[PBwriteN], the
    variable list is referenced via the variable list name ("name" parameter).




                                  @070[ Variable Services ]                 @001[ Overview ]
.200
    PBdefVLN - Define Variable List Via Name

    @201[PBdefVLN](enable,kr,adr(liste),anzahl,pw,group,rights,adr(name),ready,
             error_nr,newindex)

    Parameter Data Types:
    ->  enable    : BIT           The function block is only executed if 
                                  enable = 1.
    ->  kr        : WORD          Communication reference (logical connection
                                  number, see function block @031[PBinfoKR]).
    ->  liste     : LONG (array)  Variable list in the form of an array
                                  variable.
                                  The variables are defined in the list using
                                  a pointer for the process variable name
                                  (PV name). This means that the variable list
                                  is to be given as an array of PV name
                                  pointers. All PV names must be terminated 
                                  with 0.
    ->  anzahl    : BYTE          Number of variables in the variable list
                                  (liste).

                                      @201[ Continue ]                      @001[ Overview ]
.201
    PBdefVLN - Define Variable List Via Name (continue)

    ->  pw        : BYTE          PROFIBUS password ("Password") which the new
                                  variable list is to have. Default value is 0.
    ->  group     : BYTE          PROFIBUS group ("Access Groups") to which the
                                  new variable list is to belong. Default value
                                  is $FF.
    ->  rights    : WORD          PROFIBUS access rights ("Access Rights") which
                                  new variable list is to have. Default value
                                  is $33.
    ->  name      : BYTE (array)  Name of the new variable list (as string).
                                  The string can be entered in two different
                                  ways:
                                  adr(name)    Address of BYTE array variable
                                               which contains the string
                                  "name"       Constant string (must be entered
                                               in quotation marks!)
                                  If the value 0 is given for adr(name), the
                                  variable list has no name.


                                      @202[ Continue ]                      @001[ Overview ]
.202
    PBdefVLN - Define Variable List Via Name (continue)

    <-  ready     : BIT           Service is finished.
    <-  @800[error_nr  ]: WORD          Error number (0 = no error).
    <-  newindex  : WORD          PROFIBUS index of the new variable list.

    This function creates a new variable list from the given variables
    (via the PV name).
    This service call is only finished when the output parameter is "ready" = 1
    or an error occurs. The service needs a buffer.

    All variables in the variable list can then be accessed with a single
    read or write command. When using the @071[PBreadI] and @130[PBwriteI] functions,
    referencing the variable list takes place via the PROFIBUS index 
    (parameter "newindex"). When using the functions @080[PBreadN] and @140[PBwriteN], the
    variable list is referenced via the variable list name ("name" parameter).





                                  @070[ Variable Services ]                 @001[ Overview ]
.210
    PBdelVLI - Delete Variable List Via Index

    @211[PBdelVLI](enable,kr,index,ready,error_nr)

    Parameter Data Types:
    ->  enable    : BIT           The function block is only executed if 
                                  enable = 1.
    ->  kr        : WORD          Communication reference (logical connection
                                  number, see function block @031[PBinfoKR]).
    ->  @215[index     ]: WORD          PROFIBUS index of the variable list which is
                                  to be deleted. The PROFIBUS index for the
                                  variable list can be determined with the
                                  @250[PBgetOVN] function.    
    <-  ready     : BIT           Service is finished.
    <-  @800[error_nr  ]: WORD          Error number (0 = no error).

    The defined variable list is deleted from the target station 
    (via the PROFIBUS index) using the PBdelVLI() function.



                                      @211[ Continue ]                      @001[ Overview ]
.211
    PBdelVLI - Delete Variable List Via Index (continue)

    This service call is only finished when the output parameter is
    "ready" = 1 or an error occurs. This service needs a buffer.

















                                  @070[ Variable Services ]                 @001[ Overview ]
.215
    PBdelVLI - Delete Variable List Via Index (continue)

    -> Parameter <index     >: WORD

    PROFIBUS index of the variable list to be deleted on the target station.
    This index can be determined using the @250[PBgetOVN] function. This function
    returns the @650[Object Description] for an object on the target station.
    The first element (element "Index", data type WORD) of this object 
    description contains the index of the variable list.












                                      @210[ PBdelVLI ]                      @001[ Overview ]
.220
    PBdelVLN - Delete Variable List Via Name

    @221[PBdelVLN](enable,kr,adr(name),ready,error_nr)

    Parameter Data Type:
    ->  enable    : BIT           The function block is only executed if
                                  enable = 1.
    ->  kr        : WORD          Communication reference (logical connection
                                  number, see function block @031[PBinfoKR]).
    ->  name      : BYTE (array)  Name of the variable list to be deleted
                                  (as string). The string can be entered in
                                  two different ways:
                                  adr(name)    Address of BYTE array variable
                                               which contains the string
                                  "name"       Constant string (must be entered
                                               in quotation marks!)
    <-  ready     : BIT           Service is finished.
    <-  @800[error_nr  ]: WORD          Error number (0 = no error).



                                      @221[ Continue ]                      @001[ Overview ]
.221
    PBdelVLN - Delete Variable List Via Name (continue)

    The given variable list is deleted from the target station (via the
    variable list name) with this function.

    This service call is only finished when the output parameter is
    "ready" = 1 or an error occurs. This service requires a buffer.














                                  @070[ Variable Services ]                 @001[ Overview ]
.230
    PROFIBUS Library - Variable Services (example)

    Example of the Variable Services:
    We are using controllers PCC0 (station address 0) and PCC1
    (station address 1). Both connections required (PCC0 and PCC1) are
    defined in the network configuration module NW_S1STD.BR. This network
    configuration module must exist in application ROM on both controllers
    (PCC0 and PCC1).

    Procedure:
    PCC1 makes a connection. Both PCC0 and PCC1 write to and read from a
    variable on the target station. The current status is shown on the CPU
    status display (only System B&R 2010).








                                 @231[ Continue - Example ]                 @001[ Overview ]
.231
    PROFIBUS Library - Variable Services (example - continue)

    INIT SP for the task:
    - The PBinit() function must be called (PROFIBUS initialization) in the
      INIT SP of the task.
    - The connection number (kr) for the symbolic connection name is then
      determined in the INIT SP. The station address is determined and
      depending on this, connection PCC0 or PCC1 is used.

      ; PROFIBUS Initialization
      okay = 0
      rw_var = 0            ; for write/read operation from the other station
      PBinit(1,10,1000,0,inierr,memadr)
      if inierr = 0 then
          ; PROFIBUS functions are correctly initialized!
          ; Determine the individual station address and
          ; at the same time the kr for "PCC0"
          PBinfoKR(1,"PCC0",adr(kr_info),err,kr)



                                 @232[ Continue - Example ]                 @001[ Overview ]
.232
    PROFIBUS Library - Variable Services (example - continue)

          if err = 0 then
              src_adr = kr_info.src_adr
              if src_adr = 0 then
                  ; Own station address is 0
                  ; Use connection "PCC1", determine kr
                  PBinfoKR(1,"PCC1",0,err,kr)
                  if err = 0 then
                      okay = 1    ; everything OK
                  endif
              else if src_adr = 1 then
                  ; Own station address is 1
                  ; Make connection to station 0
                  ; kr was already established above "PCC0"
                  en_con = 1
                  okay = 1
              endif
          endif
      endif

                                 @233[ Continue - Example ]                 @001[ Overview ]
.233
    PROFIBUS Library - Variable Services (example - continue)

    Cyclic Section of the Task:
    - Connection construction must be carried out before the actual data
      transfer can begin. A connection from PCC1 to PCC0 is created 
      (see INIT SP, en_con=1).
    - The rest of the program is started after checking if the connection
      is established (rdycon=1).
    - The PBstatKR() function checks if the connection has already been made.
      If yes, the write service is executed immediately.
    - After a successful write, the same variable is read with the read service
      and compared with the value which was written. If the values do not agree,
      the application stops and gives an error message (on the CPU status
      display.
    - If an error occurs while the data is transferred, or the connection is 
      broken (unplugged bus connector), a message is given by the read or write
      functions. The procedure is restarted by the connection status request
      with the PBstatKR() function.



                                 @234[ Continue - Example ]                 @001[ Overview ]
.234
    PROFIBUS Library - Variable Services (example - continue)

    - The number of read/write cycles as well as any errors which occurred
      are shown on the CPU status display.

      if (okay = 1) and (en_con = 1) then
          ; Make connection to station 0
          ; PBautoKR() must be called cyclically until rdycon=1
          PBautoKR(en_con,kr,1,rdycon,err)
          if rdycon = 1 then
              en_con = 0
          else if err <> 0 then
              en_con = 0
              okay = 0
          endif
      endif
      if okay = 1 then
          if (en_wrn = 0) AND (en_rdn = 0) then
              ; Check connection status
              ; If OK, start en_wrn

                                 @235[ Continue - Example ]                 @001[ Overview ]
.235
    PROFIBUS Library - Variable Services (example - continue)

              PBstatKR(1,kr,err,krstat)
              if krstat = $FF then
                  en_wrn = 1
                  ; Connection to partner station is established
                  DIS_str(0,0,"CONN. OK")
              else
                  DIS_str(0,0,"NO-CONN!")
              endif
          endif
          ; Execute service. A Write per Name and a Read per Name
          ; will be carried out in alternating order on the partner station
          PBwriteN(en_wrn,kr,1,"rw_var",0,adr(wr_var),2,rdy_wrn,err_wrn)
          if rdy_wrn = 1 then
              en_wrn = 0
              en_rdn = 1
          else if err_wrn <> 0 then
              en_wrn = 0
              wrerr_ctr = wrerr_ctr + 1

                                 @236[ Continue - Example ]                 @001[ Overview ]
.236
    PROFIBUS Library - Variable Services (example - continue)

              if wrerr_ctr > 9999 then
                  wrerr_ctr = 0
              endif
              DIS_str(1,0,"WE:    ")
              itoa(err_wrn,adr(disports))
              DIS_str(1,4,adr(disports))
          endif
          PBreadN(en_rdn,kr,1,"rw_var",0,adr(rd_var),2,rdy_rdn,err_rdn)
          if rdy_rdn = 1 then
              en_rdn = 0
              if rd_var <> wr_var then
                  DIS_str(0,0,"ERROR    ")
              else
                  itoa(wr_var,adr(disports))
                  DIS_str(1,0,"V:    ")
                  DIS_str(1,2,adr(disports))
                  wr_var = wr_var + 1
                  en_wrn = 1
              endif
                                 @237[ Continue - Example ]                 @001[ Overview ]
.237
    PROFIBUS Library - Variable Services (example - continue)

              en_rdn = 0
              rderr_ctr = rderr_ctr + 1
              if rderr_ctr > 9999 then
                  rderr_ctr = 0
              endif
              DIS_str(1,0,"RE:    ")
              itoa(err_rdn,adr(disports))
              DIS_str(1,4,adr(disports))
          endif
      else
          itoa(err,adr(disports))
          DIS_str(0,0,"IE: ")
          DIS_str(1,4,adr(disports))
      endif





                                  @070[ Variable Services ]                 @001[ Overview ]
.240
    PROFIBUS Library - Object Directory Management (OV Management) 

    Object descriptions for objects on another PROFIBUS station can
    be requested with the functions in this group:

    @241[PBgetOVI] Get object description via index
    @250[PBgetOVN] Get object description via name
    @260[PBgetOVM] Get object description for multiple object













                                                                      @001[ Overview ]
.241
    PBgetOVI - Get Object Description Via Index

    @242[PBgetOVI](enable,kr,index,long_ver,adr(data),len,ready,error_nr,obj_len)

    Parameter Data Types:
    ->  enable    : BIT           The function block is only executed if 
                                  enable = 1.
    ->  kr        : WORD          Communication reference (logical connection
                                  number, see function block @031[PBinfoKR]). States
                                  the target station from where an object 
                                  description is to be read.
    ->  @245[index     ]: WORD          PROFIBUS index for the object description,
                                  which is to be read from the target station.
    ->  @246[long_ver  ]: BYTE          There are two object description formats to
                                  choose from:
                                  0 ... Short version
                                  1 ... Long version
    <-> data      : ALL           Data buffer where the read data (object
                                  description) is placed
    ->  len       : WORD          Size of the data buffer (data) in bytes.

                                      @002[ Continue ]                      @001[ Overview ]
.242
    PBgetOVI - Get Object Description Via Index (continue)

    <-  ready     : BIT           Service is finished.
    <-  @800[error_nr  ]: WORD          Error number (0 = no error).
    <-  obj_len   : BYTE          Length of the read data (object description)
                                  in bytes.

    The object description for an object on the target station can be 
    requested with the PBgetOVI() function. Referencing the object occurs via 
    the PROFIBUS index of this object, given in the object description.
    The read data from the object description is written in the given data
    buffer ("data"). The structure and the individual components (elements)
    of an object description are described in the appendix @650[Object Description].








                                      @002[ Continue ]                      @001[ Overview ]
.243
    PBgetOVI - Get Object Description Via Index (continue)

    Attention!
    An object description cannot be accessed with a structure since the 
    individual elements are not WORD aligned (WORD or LONG elements can begin
    on an odd address). Accessing an object description e.g. with a BYTE array
    is possible.

    This service call is only finished when the output parameter is
    "ready" = 1 or an error occurs. This service requires a buffer.











                                    @240[ OV Management ]                   @001[ Overview ]
.245
    PBgetOVI - Get Object Description Via Index (continue)

    -> Parameter <index     >: WORD

    PROFIBUS index for the object description which is to be read from the
    target station. This index can be determined via the @250[PBgetOVN] function.















                                      @241[ PBgetOVI ]                      @001[ Overview ]
.246
    PBgetOVI - Get Object Description Via Index (continue)

    -> Parameter <long_ver  >: BYTE

    There are two possible formats for the object description:

    Long version .... All information available for an object is transferred.
    Short version ... Only the most important object information is transferred.

    You can find detailed information on "Long/Short Versions" in the 
    @650[Object Description] appendix.










                                      @241[ PBgetOVI ]                      @001[ Overview ]
.250
    PBgetOVN - Get Object Description Via Name

    @251[PBgetOVN](enable,kr,spec_id,adr(name),long_ver,adr(data),len,ready,
             error_nr,obj_len)

    Parameter Data Types:
    ->  enable    : BIT           The function block is only executed if 
                                  enable = 1.
    ->  kr        : WORD          Communication reference (logical connection
                                  number, see function block @031[PBinfoKR]). States
                                  the target station from which the object
                                  description is to be read.
    ->  @255[spec_id   ]: BYTE          The parameter spec_id determines the object
                                  group of the object (whose description is to
                                  be read). This means that this parameter 
                                  indicates if the name of a variable, variable
                                  list etc. will be entered for this parameter:




                                      @002[ Continue ]                      @001[ Overview ]
.251
    PBgetOVN - Get Object Description Via Name (continue)

                                  1 ... Name of a process variable
                                  2 ... Name of a variable list
                                  3 ... Domain name
                                  4 ... Program invocation name
                                  5 ... Event name    
    ->  name      : BYTE (array)  Name of the object on the target station (as
                                  string). The string can be entered in two 
                                  different ways:
                                  adr(name)    Address of the BYTE array 
                                               variable containing the string
                                  "name"       Constant string (must be entered
                                               in quotation marks!)
    ->  @256[long_ver  ]: BYTE          There are two object description formats to 
                                  choose from:
                                  0 ... Short version
                                  1 ... Long version
    <-> data      : ALL           Data buffer where the read data (object
                                  description) is placed.

                                      @002[ Continue ]                      @001[ Overview ]
.252
    PBgetOVN - Get Object Description Via Name (continue)

    ->  len       : WORD          Size of data buffer (data) in bytes.
    <-  ready     : BIT           Service is finished.
    <-  @800[error_nr  ]: WORD          Error number (0 = no error).
    <-  obj_len   : BYTE          Length of read data (object description)
                                  in bytes.

    The object description for an object on the target station can be 
    requested with the PBgetOVN() function. Referencing the object occurs
    using the name of this object.
    The data read from the object description is written in the given data
    buffer ("data"). The structure and the individual components (elements)
    of an object description are described in the @650[Object Description] appendix.







                                      @002[ Continue ]                      @001[ Overview ]
.253
    PBgetOVN - Get Object Description Via Name (continue)

    Attention!
    An object description cannot be accessed with a structure since the 
    individual elements are not WORD aligned (WORD or LONG elements can begin
    on an odd address). Accessing an object description e.g. with a BYTE array
    is possible.

    This service call is only finished when the output parameter is
    "ready" = 1 or an error occurs. This service requires a buffer.











                                    @240[ OV Management ]                   @001[ Overview ]
.255
    PBgetOVN - Get Object Description Via Name (continue)

    -> Parameter <spec_id   >: BYTE

    The object group to which the desired object belongs must be defined with
    the "spec_id" parameter, since all object names are only unique in one
    object group.














                                      @250[ PBgetOVN ]                      @001[ Overview ]
.256
    PBgetOVN - Get Object Description Via Name (continue)

    -> Parameter <long_ver  >: BYTE

    There are two different object description formats to choose from:

    Long version .... All information available for an object is transferred.
    Short version ... Only the most important object information is transferred.

    You can find detailed information on "Long/Short Versions" in the 
    @650[Object Description] appendix.










                                      @250[ PBgetOVN ]                      @001[ Overview ]
.260
    PBgetOVM - Get Object Descriptions for Several Objects

    @261[PBgetOVM](enable,kr,startind,adr(ovliste),maxobj,long_ver,adr(data),len,
             ready,error_nr,obj_cnt,morefoll)

    Parameter Data Types:
    ->  enable    : BIT           The function block is only executed if 
                                  enable = 1.
    ->  kr        : WORD          Communication reference (logical connection
                                  number, see function block @031[PBinfoKR]). States
                                  the target station from where an object
                                  description is to be read.
    ->  startind  : WORD          PROFIBUS index to begin reading the object
                                  description on the target station.
    <-> @265[ovliste   ]: array of      List of structures which show the individual 
                    structures    read object descriptions. The array is
                                  written by the function as soon as the 
                                  response for the service is given.    



                                      @002[ Continue ]                      @001[ Overview ]
.261
    PBgetOVM - Get Object Descriptions for Several Objects (continue)

    ->  maxobj    : BYTE          Maximum number of object descriptions which
                                  are allowed to be read (list is not longer!).
    ->  @266[long_ver  ]: BYTE          There are two different object description
                                  formats to choose from:
                                  0 ... Short version
                                  1 ... Long version
    <-> data      : ALL           Data buffer where the read data (object
                                  description) is placed.
                                  Make sure enough memory is stored. The maximum
                                  size of the data buffer is only limited by the
                                  maximum length of a PROFIBUS frame 
                                  (approx. 230 bytes).
    ->  len       : WORD          Size of data buffer (data) in bytes.
    <-  ready     : BIT           Service is finished.
    <-  @800[error_nr  ]: WORD          Error number (0 = no error).
    <-  obj_cnt   : BYTE          Number of objects read.
    <-  morefoll  : BYTE          More objects are still available.


                                      @002[ Continue ]                      @001[ Overview ]
.262
    PBgetOVM - Get Object Descriptions for Several Objects (continue)

    Multiple object descriptions are requested from the target station 
    starting with the given PROFIBUS index ("startind"), with this function.
    The read object description data is written in the given data buffer 
    ("data"). The structure and the individual components (elements) of an
    object description are described in the @650[Object Description] appendix.

    This service call is only finished when the output parameter is 
    "ready" = 1 or an error occurs.

    Note:
    The PBgetOVM() function is not a standard PROFIBUS service, therefore this
    function can only be used for B&R devices!







                                    @240[ OV Management ]                   @001[ Overview ]
.265
    PBgetOVM - Get Object Descriptions for Several Objects (continue)

    <-> Parameter <ovliste   >: Array of structures

    Array (list) of structures containing the individual read object 
    descriptions. The structure array is written by the function as soon as
    the response for the service is received. Each element of the structure
    array contains a pointer for an object description and the length of that
    object description.
    Format of the Structure:

    ptr        : LONG    Pointer to the data (object description)
    len        : BYTE    Length of this data (in bytes)
    reserve    : BYTE    Reserve (for WORD alignment)







                                      @260[ PBgetOVM ]                      @001[ Overview ]
.266
    PBgetOVM - Get Object Descriptions for Several Objects (continue)

    -> Parameter <long_ver  >: BYTE

    There are two different formats for the object description:

    Long version .... All information for an object is transferred.
    Short version ... Only the most important object information is transferred.

    You can find detailed information on the topic "Long/Short Version" in the
    @650[Object Description] appendix.










                                      @260[ PBgetOVM ]                      @001[ Overview ]
.270
    PROFIBUS Library - Receive

    This function group contains a function block for receiving telegrams:

    @271[PBrec] Receive telegrams
















                                                                      @001[ Overview ]
.271
    PBrec - Receive Telegrams

    @272[PBrec](enable,adr(par_ptr),ready,error_nr,dat_ptr)

    Parameter Data Types:
    ->  enable    : BIT           The function block is only executed if
                                  enable = 1.
    <-> @275[par_ptr   ]: par structure Structure where the parameters of the
                                  received services are placed.
    <-  ready     : BIT           0 ... The FBK is not yet finished (or 
                                        error occurred).
                                  1 ... The FBK carried out the instruction
                                        without error.
    <-  @800[error_nr  ]: WORD          Error number (0 = no error).
    <-  @277[dat_ptr   ]: LONG          Pointer to the data received with the service.

    The PROFIBUS services can be received using this function. From version 2.00
    of the PROFIBUS library (see also appendix @900[History]) onwards, layer2 services
    can be received as well as layer7 services.


                                      @272[ Continue ]                      @001[ Overview ]
.272
    PBrec - Receive Telegrams (continue)

    It can be determined whether a Layer7 or a Layer2 service was received
    by using the "service_id" element of the "@275[par]" structure.

    The PBrec() function waits to receive a PROFIBUS service and returns
    a pointer to the received data. The received information is evaluated
    in two parts:

    - Parameter (input/output parameter "@275[par_ptr]")
    - Data (output parameter "@277[dat_ptr]")










                                      @273[ Continue ]                      @001[ Overview ]
.273
    PBrec - Receive Telegrams (continue)

    Notes:
    - The received data must be evaluated before the function block is next
      activated ("enable" = 1). When the function block is next activated, this
      data is deleted, and the function block is switched back to receive!
    - No memory needs to be available for the received data, as the output
      parameter "dat_ptr" points directly to the appropriate data in the DPR
      of the network controller.
    - Data access is read only!
    - If necessary, several function blocks can be received at the same time.










                                       @270[ Receive ]                      @001[ Overview ]
.275
    PBrec - Receive Telegrams (continue)

    <-> Parameter <par_ptr   >: par structure

    The parameters for the received service are placed in the structure "par".
    The values for the structure elements "sa", "service_id", "ssap",
    "dsap", "prio" and "rec_len" are only valid when the output parameter is
    "ready" = 1. Elements for the Structure "par":

    mod_nr     : BYTE   Module number of the PROFIBUS network module
    sa         : BYTE   Address of the sender
    service_id : BYTE   ID number of the received service
    ssap       : BYTE   Source SAP. Service Access Point (SAP) on the local
                        station.
    dsap       : BYTE   Destination SAP. Service Access Point (SAP) on the
                        target station.
    prio       : BYTE   Priority (0=LOW, 1=HIGH) of the service
    send_len   : BYTE   Always 0
    rec_len    : BYTE   Length of the received data


                                      @276[ Continue ]                      @001[ Overview ]
.276
    PBrec - Receive Telegrams (continue)

    Elements for the Structure "par" (continue):

    dummy1     : BYTE   not used
    dummy2     : BYTE   not used
    dummy3     : BYTE   not used
    dummy4     : BYTE   not used
    dummy5     : BYTE   not used
    dummy6     : BYTE   not used
    dummy7     : BYTE   not used
    dummy8     : BYTE   not used









                                        @271[ PBrec ]                       @001[ Overview ]
.277
    PBrec - Receive Telegrams (continue)

    <- Parameter <dat_ptr   >: LONG

    The output parameter "dat_ptr" refers to the data which was received with
    the service. Pointer directly to the DPR (Dual Ported RAM) of the network
    controller.

    Attention!
    The DPR of the network controller is volatile!











                                        @271[ PBrec ]                       @001[ Overview ]
.280
    PROFIBUS Library - Send

    This function group contains a function block for sending telegrams:

    @281[PBsend] Send Telegrams
















                                                                      @001[ Overview ]
.281
    PBsend - Send Telegrams

    @282[PBsend](enable,adr(par_ptr),adr(send_ptr),ready,error_nr,rec_ptr)

    Parameter Data Types:
    ->  enable    : BIT           The function block is only executed if
                                  enable = 1.
    ->  @285[par_ptr   ]: par structure The parameters for the service must be entered
                                  in this structure.
    ->  send_ptr  : LONG          Send data. If no send data is available, the
                                  value 0 can be given.
    <-  ready     : BIT           0 ... The FBK is not yet finished (or
                                        errors occurred).
                                  1 ... The FBK carried out the instruction
                                        without error.
    <-  @800[error_nr  ]: WORD          Error number (0 = no error).
    <-  rec_ptr   : LONG          Pointer to receive data (if the activated
                                  service returns any).



                                      @282[ Continue ]                      @001[ Overview ]
.282
    PBsend - Send Telegrams (continue)

    The function block PBsend() activates a Layer2 service. The function
    block must be called until the output is "ready" = 1 (instruction 
    successfully carried out) or an error number is returned on the "error_nr"
    output.
    The function block sends the Layer2 request and must then be polled
    until it has received the Layer2 confirmation. This returns, e.g. in the
    case of the SRD service, response data, which can be directly accessed.

    Layer2 management services, which enable e.g. the Life List to be read,
    can also be activated with the function block.









                                      @283[ Continue ]                      @001[ Overview ]
.283
    PBsend - Send Telegrams (continue)

    Note:
    The precise meaning of the individual parameters and all possible
    services are as follows:

    @290[SAP_ACTIVATE    ] Service Access Point Activate
    @300[SDA             ] Send Data with Acknowledge
    @310[SDN             ] Send Data with no Acknowledge
    @320[SRD             ] Send and Request Data
    @330[REPLY_UPDATE    ] Reply Update
    @340[LIFE_LIST_CREATE] Life List Create









                                        @280[ Send ]                        @001[ Overview ]
.285
    PBsend - Send Telegrams (continue)

    -> Parameter <par_ptr   >: par structure

    The parameters for the received services are placed in the structure "par".
    Elements for the structure "par":

    mod_nr     : BYTE   Module number of the PROFIBUS network module
    da         : BYTE   Address of the target station
    service_id : BYTE   ID number of the desired service
    ssap       : BYTE   Source SAP. Service Access Point (SAP) on the
                        local station.
    dsap       : BYTE   Destination SAP. Service Access Point (SAP) on the
                        target station.
    prio       : BYTE   Priority (0=LOW, 1=HIGH) of the service
    send_len   : BYTE   Length of the send data
    rec_len    : BYTE   Length of the received data




                                       @281[ PBsend ]                       @001[ Overview ]
.290
    SAP_ACTIVATE - Service Access Point Activate

    PBsend(enable,adr(par_ptr),adr(send_ptr),ready,error_nr,rec_ptr)

    Parameter Data Types:
    ->  enable    : BIT           The function block is only executed if
                                  enable = 1.
    ->  @295[par_ptr   ]: par structure The parameters for the service must be entered
                                  in this structure.
    ->  send_ptr  : LONG          The value 0 must be given here for the
                                  SAP_ACTIVATE service.
    <-  ready     : BIT           0 ... The FBK is not yet finished (or
                                        errors occurred).
                                  1 ... The FBK carried out the instruction
                                        error free.
    <-  @299[error_nr  ]: WORD          Error number (0 = no error).
    <-  rec_ptr   : LONG          This service does not return receive data.

    This call activates a Layer2 SAP (SAP = Service Access Point) for
    accessing remote stations or for processing send services.

                                      @291[ Continue ]                      @001[ Overview ]
.291
    SAP_ACTIVATE - Service Access Point Activate (continue)

    If no SAP is configured, then no data exchange is possible with a remote
    station. All service calls are rejected with an error message.
    Which services are to be processed with this SAP can be entered in the
    SAP configuration. The send and receive direction can be entered separately.
    If, for example, a SAP is only prepared for sending, telegrams which are
    sent from a remote station to the local station, are already rejected in
    Layer2.












    @281[ PBsend ]                        @290[ SAP_ACTIVATE ]                    @001[ Overview ]
.295
    SAP_ACTIVATE - Service Access Point Activate (continue)

    -> Parameter <par_ptr   >: par structure

    The parameters for the service must be entered in this structure.
    Elements of the structure "par":

    mod_nr     : BYTE   Module number of the PROFIBUS network module
    da         : BYTE   Access protection:
                        $7F ......... All remote stations can access this SAP.
                        0 to 126 ...  Only the current station is allowed to
                                      access this SAP.
    service    : BYTE   SAP_ACTIVATE = 1
    ssap       : BYTE   MSAP         = 1
    dsap       : BYTE   SAP to be activated.
    @296[prio       ]: BYTE   Entry of the services which can be processed via this
                        Layer2 SAP.
    send_len   : BYTE   0
    rec_len    : BYTE   0


    @298[ Example ]                       @290[ SAP_ACTIVATE ]                    @001[ Overview ]
.296
    SAP_ACTIVATE - Service Access Point Activate (continue)

    The allowed services are set via the "prio" element:

    BIT  7 6 5 4 3 2 1 0
        ฺฤยฤยฤยฤยฤยฤยฤยฤฟ
        ณxณ0ณxณxณxณxณxณxณ
        ภฤมฤมฤมฤมฤมฤมฤมฤู
         ณ   ณ ณ ณ ณ ณ ภฤฤฤฤ Send SDA        (1=enabled, 0=disabled)
         ณ   ณ ณ ณ ณ ภฤฤฤฤฤฤ Receive SDA     (1=enabled, 0=disabled)
         ณ   ณ ณ ณ ภฤฤฤฤฤฤฤฤ Send SDN        (1=enabled, 0=disabled)
         ณ   ณ ณ ภฤฤฤฤฤฤฤฤฤฤ Receive SDN     (1=enabled, 0=disabled)
         ณ   ณ ภฤฤฤฤฤฤฤฤฤฤฤฤ Send SRD        (1=enabled, 0=disabled)
         ณ   ภฤฤฤฤฤฤฤฤฤฤฤฤฤฤ Receive SRD     (1=enabled, 0=disabled)
         ภฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ @297[SRD BUFFER Mode] (1=on, 0=off)

    An access protection which only allows one remote station to access this
    local SAP, can also be brought into action using the "da" element. 
    If the value $7F is entered for the "da" element, all remote stations are
    allowed to access this SAP.

                                        @295[ Back ]                        @001[ Overview ]
.297
    SAP_ACTIVATE - Service Access Point Activate (continue)

    SRD BUFFER Mode:
    1=on .... A received SRD service is not read via the PBrec() FBK, but is
              temporarily stored on the PROFIBUS network module (SAP), and can
              then be read using the REPLY UPDATE service. If a new SRD service
              arrives before the last was picked up, the new SRD service
              replaces the old one.
    0=off ... Service is brought to the FBK PBrec() like all other services.












                                        @296[ Back ]                        @001[ Overview ]
.298
    SAP_ACTIVATE - Service Access Point Activate (continue)

    Example:

       mod_nr   = 1
       da       = $7F
       service  = 1     (Service Access Point Activate)
       ssap     = 1
       dsap     = 50
       prio     = $3F   ($3F = 00111111)
       send_len = 0
       rec_len  = 0

    A call with these values activates SAP 50, allows all remote stations to
    access this SAP and enables the SDA, SDN and SRD services for sending
    and receiving.





                                        @295[ Back ]                        @001[ Overview ]
.299
    SAP_ACTIVATE - Service Access Point Activate (continue)

    <- Parameter <error_nr  >: WORD

    Error Numbers:
    0       Service successfully processed
    4923    Parameter invalid
    4926    SAP is already configured













                                    @290[ SAP_ACTIVATE ]                    @001[ Overview ]
.300
    SDA - Send Data with Acknowledge

    PBsend(enable,adr(par_ptr),adr(send_ptr),ready,error_nr,rec_ptr)

    Parameter Data Types:
    ->  enable    : BIT           The function block is only executed if
                                  enable = 1.
    ->  @305[par_ptr   ]: par structure The parameters for this service must be 
                                  entered in this structure.
    ->  send_ptr  : LONG          Send data
    <-  ready     : BIT           0 ... The FBK is not yet finished (or
                                        errors occurred).
                                  1 ... The FBK carried out the instruction 
                                        error free.
    <-  @307[error_nr  ]: WORD          Error number (0 = no error).
    <-  rec_ptr   : LONG          This service does not return receive data.

    This call triggers a SDA service to be sent.



                                      @301[ Continue ]                      @001[ Overview ]
.301
    SDA - Send Data with Acknowledge (continue)

    The element "ssap" for the structure "par" gives the local SAP, with which
    the service is to be processed (this SAP must first be activated for the
    service Send SDA with the service SAP_ACTIVATE).
    The element "dsap" gives the SAP on the remote station (via which the 
    service is to be directed). This SAP must already be activated for the 
    service Receive SDA on the remote station.
    This service sends a frame, which is acknowledged by Layer2 of the remote
    station. If there is no acknowledgment by this remote station, then the
    service is repeated by the local station (the number of retries can be
    set with the Layer2 bus parameters).
    The "error_nr" output for the SDA service indicates if the frame was sent
    successfully or not.







    @281[ PBsend ]                             @300[ SDA ]                        @001[ Overview ]
.305
    SDA - Send Data with Acknowledge (continue)

    -> Parameter <par_ptr   >: par structure

    The parameters for the service must be entered in this structure.
    Elements of the structure "par":

    mod_nr     : BYTE   Module number of the PROFIBUS network module
    da         : BYTE   Address of the remote station
    service    : BYTE   SDA = 48
    ssap       : BYTE   Source SAP. Service Access Point (SAP) on the
                        local station.
    dsap       : BYTE   Destination SAP. Service Access Point (SAP) on the
                        target station.
    prio       : BYTE   0 = PRIO_LOW
                        1 = PRIO_HIGH
    send_len   : BYTE   Length of the send data
    rec_len    : BYTE   0



    @306[ Example ]                            @300[ SDA ]                        @001[ Overview ]
.306
    SDA - Send Data with Acknowledge (continue)

    Example:

       mod_nr   = 1
       da       = 3
       service  = 48    (Send Data with Acknowledge)
       ssap     = 50
       dsap     = 50
       prio     = 0
       send_len = 3
       rec_len  = 0

    A call with these values sends a SDA service with low priority and 3 bytes
    of send data to station 3 (via the local SAP 50 to the remote SAP 50).






                                        @305[ Back ]                        @001[ Overview ]
.307
    SDA - Send Data with Acknowledge (continue)

    <- Parameter <error_nr  >: WORD

    Error Numbers:
    0       Service processed successfully
            (Acknowledge received from remote station)
    4923    Value for element "da" not valid
            Value for element "dsap" not valid
            Value for element "ssap" not valid
            Value for element "send_len" too large
    4925    Source SAP (local SAP) is not configured for the service Send SDA
    4927    The local station is not in the logical token ring
    4928    No, or no plausible remote station reaction
    4931    Negative acknowledgment (remote user/FDL interface error)
    4932    Negative acknowledgment (operating equipment for the remote FDL
            controller not available, or not adequate)
    4933    Service or remote address for destination SAP (remote SAP) not
            activated


                                         @300[ SDA ]                        @001[ Overview ]
.310
    SDN - Send Data with no Acknowledge

    PBsend(enable,adr(par_ptr),adr(send_ptr),ready,error_nr,rec_ptr)

    Parameter Data Types:
    ->  enable    : BIT           The function block is only executed if 
                                  enable = 1.
    ->  @315[par_ptr   ]: par structure The parameters of the service must be
                                  entered in this structure.
    ->  send_ptr  : LONG          Send data
    <-  ready     : BIT           0 ... The FBK is not yet finished (or
                                        errors occurred).
                                  1 ... The FBK carried out the instruction
                                        error free.
    <-  @316[error_nr  ]: WORD          Error number (0 = no error).
    <-  rec_ptr   : LONG          This service does not return receive data.

    This call triggers an SDN service to be sent.



                                      @311[ Continue ]                      @001[ Overview ]
.311
    SDN - Send Data with no Acknowledge (continue)

    The element "ssap" for the structure "par" gives the local SAP, which
    is to be used to process the service (this SAP must first be
    activated for the service Send SDN with the service SAP_ACTIVATE).
    The element "dsap" gives the SAP on the remote station (via which
    the service is to be directed). This SAP for the service must already 
    be activated for the service Receive SDN on the remote station.
    This service sends a frame which is not acknowledged by Layer2 of the
    remote station. There is no guarantee that the service has been received.
    The SDN service is the only Layer2 service which is allowed to be sent in
    broadcast or multicast.

    Multicast: By entering da=127 and dsap=xxx, the SDN service is sent to all
               other stations which have SAP xxx activated for Receive SDN.
    Broadcast: This is a special type of multicast for which dsap=63 is given.





    @281[ PBsend ]                             @310[ SDN ]                        @001[ Overview ]
.315
    SDN - Send Data with no Acknowledge (continue)

    -> Parameter <par_ptr   >: par structure

    The parameters for this service must be entered in this structure.
    Elements of the structure "par":

    mod_nr     : BYTE   Module number of the PROFIBUS network module
    da         : BYTE   Address of the remote station
    service    : BYTE   SDN = 49
    ssap       : BYTE   Source SAP. Service Access Point (SAP) on the
                        local station.
    dsap       : BYTE   Destination SAP. Service Access Point (SAP) on the
                        target station.
    prio       : BYTE   0 = PRIO_LOW
                        1 = PRIO_HIGH
    send_len   : BYTE   Length of the send data
    rec_len    : BYTE   0



                                         @310[ SDN ]                        @001[ Overview ]
.316
    SDN - Send Data with no Acknowledge (continue)

    <- Parameter <error_nr  >: WORD

    Error Numbers:
    0       Service sent successfully
    4923    Value for element "da" not valid
            Value for element "dsap" not valid
            Value for element "ssap" not valid
            Value for element "send_len" too large
    4925    Source SAP (local SAP) is not configured for the service Send SDA
    4927    The local station is not in the logical token ring









                                         @310[ SDN ]                        @001[ Overview ]
.320
    SRD - Send and Request Data

    PBsend(enable,adr(par_ptr),adr(send_ptr),ready,error_nr,rec_ptr)

    Parameter Data Types:
    ->  enable    : BIT           The function block is only executed if
                                  enable = 1.
    ->  @325[par_ptr   ]: par structure The parameters for this service must be
                                  entered in this structure.
    ->  send_ptr  : LONG          Send data
    <-  ready     : BIT           0 ... The FBK is not yet finished (or
                                        error occurred).
                                  1 ... The FBK carried out the instruction 
                                        error free.
    <-  @326[error_nr  ]: WORD          Error number (0 = no error).
    <-  rec_ptr   : LONG          Pointer to the received data.

    This call triggers a SRD service to be sent.



                                      @321[ Continue ]                      @001[ Overview ]
.321
    SRD - Send and Request Data (continue)

    The "ssap" element for the structure "par" states the local SAP, which
    is to be used to process the service (this SAP must first be activated
    with the SAP_ACTIVATE service for the Send SRD service).
    The "dsap" element states the SAP on the remote station (from which the
    receive data is to be read). This SAP must be already be activated for the
    service Receive SRD on the remote station. Furthermore, data must (can) 
    already be prepared for collection with the REPLY UPDATE service on the
    remote station. This service sends a frame which is acknowledged by
    Layer2 of the remote station (data can be transferred with the
    acknowledgment). If the remote station doesn't acknowledge, the service
    is repeated by the local station (the number of retries can be set via
    the Layer2 bus parameters). The "error_nr" output of the SRD service
    indicates if the data was successfully sent or not.
    Data can be sent and received in a message cycle using this Layer2 service.





    @281[ PBsend ]                             @320[ SRD ]                        @001[ Overview ]
.325
    SRD - Send and Request Data (continue)

    -> Parameter <par_ptr   >: par structure

    The parameters for the service must be entered in this structure.
    Elements of the Structure "par":

    mod_nr     : BYTE   Module number of the PROFIBUS network module
    da         : BYTE   Address of the remote station
    service    : BYTE   SRD = 50
    ssap       : BYTE   Source SAP. Service Access Point (SAP) on the
                        local station.
    dsap       : BYTE   Destination SAP. Service Access Point (SAP) on the
                        target station.
    prio       : BYTE   0 = PRIO_LOW
                        1 = PRIO_HIGH
    send_len   : BYTE   Length of send data
    rec_len    : BYTE   Length of receive data



                                         @320[ SRD ]                        @001[ Overview ]
.326
    SRD - Send and Request Data (continue)

    <- Parameter <error_nr  >: WORD

    Error Numbers:
    0       Service handled successfully
            Acknowledge from remote station received:
            "rec_len" = 0 ................ Transmit data OK, no response data
                                           available
            "rec_len" <> 0, "prio" = 0 ... Transmit data OK, response data with
                                           low priority available
            "rec_len" <> 0, "prio" = 1 ... Transmit data OK, response data with
                                           high priority available
    4923    Value for element "da" not valid
            Value for element "dsap" not valid
            Value for element "ssap" not valid
            Value for element "send_len" too large
    4925    Source SAP (local SAP) is not configured for the Send SRD service
    4927    The local station is not in the logical token ring


                                      @327[ Continue ]                      @001[ Overview ]
.327
    SRD - Send and Request Data (continue)

    4928    No, or no plausible reaction from the remote station
    4931    Negative acknowledgment (remote user/FDL interface error)
    4932    Negative acknowledgment (operating equipment for the remote FDL
            controller not available or not adequate)
    4933    Service or remote address for destination SAP (remote SAP) not
            activated
    4939    Positive acknowledgment for send data; negative acknowledgment
            for receive data (remote station not available)
    4942    Negative acknowledgment for send data (as operating equipment
            for remote station not available or not adequate); low priority
            receive data available
    4942    Negative acknowledgment for send data (as operating equipment
            for the remote station is not available or not adequate); high
            priority receive data available





                                         @320[ SRD ]                        @001[ Overview ]
.330
    REPLY_UPDATE - Reply Update

    PBsend(enable,adr(par_ptr),adr(send_ptr),ready,error_nr,rec_ptr)

    Parameter Data Types:
    ->  enable    : BIT           The function block is only executed if
                                  enable = 1.
    ->  @335[par_ptr   ]: par structure The parameters for the service must be
                                  entered in this structure.
    ->  send_ptr  : LONG          Transmit data.
    <-  ready     : BIT           0 ... The FBK is not yet finished (or
                                        error occurred).
                                  1 ... The FBK carried out the instruction 
                                        error free.
    <-  @336[error_nr  ]: WORD          Error number (0 = no error).
    <-  rec_ptr   : LONG          If the SAP is configured for the
                                  @296[SRD BUFFER Mode] (see SAP_ACTIVATE service) 
                                  and a SRD service was received, the rec_ptr 
                                  output has a pointer to the received data
                                  after the REPLY_UPDATE call.

                                      @331[ Continue ]                      @001[ Overview ]
.331
    REPLY_UPDATE - Reply Update (continue)

    This service puts new send data in the reply buffer of the given SAP,
    and collects receive data (if the SAP is configured for the
    @296[SRD BUFFER Mode]). The placed send data can be read by a remote
    station with the SRD service.
    The "ssap" element for the "par" structure gives the local SAP, whose
    buffer is to be updated (this SAP must be activated for the Receive SRD
    with the SAP_ACTIVATE service).

    With REPLY_UPDATE_SINGLE, the data buffer is transferred to be read one
    time by the remote station. No more response data is transferred when
    the remote station accesses this SAP again (by the SRD service).
    With REPLY_UPDATE_MULTIPLE, the data buffer is transferred to be read
    repeatedly by the remote station. Data is transferred again each time
    the remote station accesses this SAP again (by the SRD service).





                                      @332[ Continue ]                      @001[ Overview ]
.332
    REPLY_UPDATE - Reply Update (continue)

    Note:
    Only low priority telegrams can be given to a SAP using the 
    REPLY_UPDATE service. 
















    @281[ PBsend ]                        @330[ REPLY_UPDATE ]                    @001[ Overview ]
.335
    REPLY_UPDATE - Reply Update (continue)

    -> Parameter <par_ptr   >: par structure

    The parameters for the service must be entered in this structure.
    Elements of the Structure "par":

    mod_nr     : BYTE   Module number of the PROFIBUS network module
    da         : BYTE   0 (not used)
    service    : BYTE   REPLY_UPDATE_SINGLE = 54
                        REPLY_UPDATE_MULTIPLE = 55
    ssap       : BYTE   Source SAP. Service Access Point (SAP) on the
                        local station.
    dsap       : BYTE   0 (not used)
    prio       : BYTE   0
    send_len   : BYTE   Length of send data
    rec_len    : BYTE   Length of receive data




                                    @330[ REPLY_UPDATE ]                    @001[ Overview ]
.336
    REPLY_UPDATE - Reply Update (continue)

    <- Parameter <error_nr  >: WORD

    Error Numbers:
    0       Service successfully processed
    4923    Value for the "ssap" element not valid
            Value for the "send_len" element too large
    4925    Source SAP (local SAP) is not configured for the Receive SRD service












                                    @330[ REPLY_UPDATE ]                    @001[ Overview ]
.340
    LIFE_LIST_CREATE - Life List Create

    PBsend(enable,adr(par_ptr),adr(send_ptr),ready,error_nr,rec_ptr)

    Parameter Data Types:
    ->  enable    : BIT           The function block is only executed if
                                  enable = 1.
    ->  @345[par_ptr   ]: par structure The parameters of the service must be
                                  entered in the structure.
    ->  send_ptr  : LONG          BYTE array which contains the station numbers
                                  whose Life Status is to be determined.
    <-  ready     : BIT           0 ... The FBK is not yet finished (or
                                        error occurred).
                                  1 ... The FBK carried out the instruction
                                        error free.
    <-  @346[error_nr  ]: WORD          Error number (0 = no error).





                                      @341[ Continue ]                      @001[ Overview ]
.341
    LIFE_LIST_CREATE - Life List Create (continue)

    <-  rec_ptr   : LONG          Pointer to a BYTE array which contains the
                                  status of the respective stations (see
                                  input parameter send_ptr). Send_len status 
                                  bytes are entered.

    This service determines the Life Status of the stations (given by the
    station numbers). The output rec_ptr points to a BYTE array, which
    contains information (one BYTE per station) about the given stations:

    0 ..... Passive station
    1 ..... Active station not ready
    2 ..... Active station ready for the logical token ring
    3 ..... Active station in the logical token ring
    $80 ... Station not available





    @281[ PBsend ]                      @340[ LIFE_LIST_CREATE ]                  @001[ Overview ]
.345
    LIFE_LIST_CREATE - Life List Create (continue)

    -> Parameter <par_ptr   >: par structure

    The parameters for the service must be entered in this structure.
    Elements of the Structure "par":

    mod_nr     : BYTE   Module number of the PROFIBUS network module
    da         : BYTE   0
    service    : BYTE   LIFE_LIST_CREATE = 26
    ssap       : BYTE   MSAP = 1
    dsap       : BYTE   0
    prio       : BYTE   0
    send_len   : BYTE   Length of the BYTE array "send_ptr" (number of 
                        stations whose Life Status is to be determined)
    rec_len    : BYTE   Length of receive data





                                  @340[ LIFE_LIST_CREATE ]                  @001[ Overview ]
.346
    LIFE_LIST_CREATE - Life List Create (continue)

    <- Parameter <error_nr  >: WORD

    Error Numbers:
    0       Service successfully processed
    4923    Value for element "ssap" not valid
    4924    Operating equipment for the local FDL controller not available
            or not adequate












                                  @340[ LIFE_LIST_CREATE ]                  @001[ Overview ]
.400
    PROFIBUS Library - Information Report

    This function group contains a function for sending data telegrams:

    @401[PBirepI] Information Report per Index
















                                                                      @001[ Overview ]
.401
    PBirepI - Information Report per Index

    @402[PBirepI](enable,kr,index,subindex,adr(data),len,ready error_nr)

    Parameter Data Types:
    ->  enable    : BIT           The function block is only executed if
                                  enable = 1.
    ->  kr        : WORD          Communication reference (logical connection
                                  number, see function block @031[PBinfoKR]) of the
                                  target station.
    ->  @405[index     ]: WORD          PROFIBUS index of the variable to be sent out.
                                  The PROFIBUS index can be determined with the 
                                  @250[PBgetOVN] function.
    ->  @406[subindex  ]: WORD          Sub-index of the variable to be sent.
    ->  data      : ALL           Variable to be sent.
    ->  len       : WORD          Length of the data (data) in bytes.
    <-  ready     : BIT           Service is finished.
    <-  @800[error_nr  ]: WORD          Error number (0 = no error).



                                      @402[ Continue ]                      @001[ Overview ]
.402
    PBirepI - Information Report per Index (continue)

    An information report service (per PROFIBUS index) can be sent via the
    logical connection number "kr" with the PBirepI() function. This means
    that the PBirepI() function enables data telegrams to be sent to the defined
    PROFIBUS station (parameter "kr"). The data to be sent must be placed in the
    data buffer "data". The "len" parameter indicates the length of the data.

    This service call is only finished when the output parameter is
    "ready" = 1 or an error occurs. This service requires a buffer.











                                 @400[ Information Report ]                 @001[ Overview ]
.405
    PBirepI - Information Report per Index (continue)

    -> Parameter <index     >: WORD

    This index can be determined using the @250[PBgetOVN] function.
    This function returns the @650[Object Description] of an object on the target
    station. The first element (element "Index", data type WORD) of this object
    description contains the index for the object.













                                       @401[ PBirepI ]                      @001[ Overview ]
.406
    PBirepI - Information Report per Index (continue)

    -> Parameter <subindex  >: WORD

    @542[Sub-Index] of the variable to be sent.
















                                       @401[ PBirepI ]                      @001[ Overview ]
.410
    PROFIBUS Library - Send Status

    This function group contains a function for sending a status telegram:

    @411[PBustat] Send Status Telegram
















                                                                      @001[ Overview ]
.411
    PBustat - Send Status Telegram

    @412[PBustat](enable,kr,log_stat,phy_stat,adr(ld_ptr),ready,error_nr)

    Parameter Data Types:
    ->  enable    : BIT           The function block is only executed if
                                  enable = 1.
    ->  kr        : WORD          Communication reference (logical connection
                                  number, see function block @031[PBinfoKR]) on the
                                  target station.
    ->  log_stat  : BYTE          Logical status
    ->  phy_stat  : BYTE          Physical status
    ->  ld_ptr    : BYTE (array)  Local detail (detail information). Detail
                                  information with a length of three bytes
                                  is expected. If the value 0 is entered for
                                  adr(ld_ptr), no detail information is sent.
    <-  ready     : BIT           Service is finished.
    <-  @800[error_nr  ]: WORD          Error number (0 = no error).



                                      @412[ Continue ]                      @001[ Overview ]
.412
    PBustat - Send Status Telegram (continue)

    An unsolicited status service is sent to the respective connection
    using the PBustat() function.

    This service call is only finished when the output parameter is
    "ready" = 1 or an error occurs. This service requires a buffer.














                                     @410[ Send Status ]                    @001[ Overview ]
.420
    PROFIBUS Library - Download Service

    B&R modules can be transferred to another PROFIBUS station using the
    functions of the function group Download Service:

    @421[PBdlI] Download per Index
    @430[PBdlN] Download per Name














                                                                      @001[ Overview ]
.421
    PBdlI - Download per Index

    @422[PBdlI](enable,kr,index,modptr,modlen,ready,error_nr)

    Parameter Data Types:
    ->  enable    : BIT           The function block is only executed if
                                  enable = 1.
    ->  kr        : WORD          Communication reference (logical connection
                                  number, see function block @031[PBinfoKR]). 
                                  Indicates the target station where the
                                  B&R module is to be loaded.
    ->  @425[index     ]: WORD          PROFIBUS index for the memory area (domain)
                                  on the target station where the B&R module
                                  is to be downloaded.
    ->  modptr    : LONG          Physical address of the B&R module
                                  (program module or data module) which is to
                                  loaded to the target station. The physical
                                  address of a B&R module can be determined,
                                  e.g. using the MO_list() function 
                                  (see B&R TRAP library).

                                      @422[ Continue ]                      @001[ Overview ]
.422
    PBdlI - Download per Index (continue)

    ->  modlen    : LONG          Total length of the B&R module in bytes.
    <-  ready     : BIT           Service is finished.
    <-  @800[error_nr  ]: WORD          Error number (0 = no error).

    A B&R module can be downloaded to the target station using the PBdlI() 
    function. Referencing the memory area (domain) on the target station
    where the B&R module will be downloaded takes place via the PROFIBUS 
    index for this memory area.

    A "domain" is an object which contains a logically connected memory area
    with a set maximum length. The memory area can either contain data or 
    programs.







                                      @423[ Continue ]                      @001[ Overview ]
.423
    PBdlI - Download per Index (continue)

    For data modules, the physical address ("modptr" parameter) and the
    total length ("modlen" parameter) can be determined e.g. using the 
    functions DA_ident() and DA_info() from the B&R TRAP library:

      Err_Id = DA_ident(adr(Name),0,adr(Ident))
      Err_In = DA_info(Ident,adr(D_Adr),adr(D_Len),adr(Typ))
      ; D_Adr - $50 (for module header) = physical address of the data module
      modptr = D_Adr - $50
      ; D_Len + $50 (for module header) = total length of the data module
      modlen = D_Len + $50

    This service call is only finished when the output parameter is
    "ready" = 1 or an error occurs. This service requires a buffer.






                                  @420[ Download Services ]                 @001[ Overview ]
.425
    PBdlI - Download per Index (continue)

    -> Parameter <index     >: WORD

    PROFIBUS index for the memory area (domain), where the B&R module will
    be downloaded. This index can be determined using the @250[PBgetOVN] function.















                                        @421[ PBdlI ]                       @001[ Overview ]
.430
    PBdlN - Download per Name

    @431[PBdlN](enable,kr,adr(modname),modptr,modlen,ready,error_nr)

    Parameter Data Types:
    ->  enable    : BIT           The function block is only executed if
                                  enable = 1.
    ->  kr        : WORD          Communication reference (logical connection
                                  number, see function block @031[PBinfoKR]). Gives
                                  the target station where the B&R module is to
                                  be loaded.
    ->  @435[modname   ]: BYTE (array)  PROFIBUS name of the memory area (domain)
                                  on the target station, where the B&R module
                                  is to be downloaded.
    ->  modptr    : LONG          Physical address of the B&R module
                                  (program module or data module) to be loaded
                                  on the target station. The physical address of
                                  a B&R module can be determined e.g. using the
                                  MO_list() function (see B&R TRAP library).


                                      @431[ Continue ]                      @001[ Overview ]
.431
    PBdlN - Download per Name (continue)

    ->  modlen    : LONG          Total length of the B&R module in bytes.
    <-  ready     : BIT           Service is finished.
    <-  @800[error_nr  ]: WORD          Error number (0 = no error).

    A B&R module can be downloaded to the target station with the PBdlN() 
    function. Referencing the memory area (domain) onto the target station
    where the B&R module will be downloaded, occurs using the PROFIBUS 
    name of this memory area.

    A "Domain" is an object, which contains a logically connected memory
    area with a set maximum length. The memory area can either contain
    data or programs.







                                      @432[ Continue ]                      @001[ Overview ]
.432
    PBdlN - Download per Name (continue)

    For data modules, the physical address ("modptr" parameter) and the
    total length ("modlen" parameter) can be determined with e.g. the 
    functions DA_ident() and DA_info() of the B&R TRAP library:

      Err_Id = DA_ident(adr(Name),0,adr(Ident))
      Err_In = DA_info(Ident,adr(D_Adr),adr(D_Len),adr(Typ))
      ; D_Adr - $50 (for module header) = physical address of the data module
      modptr = D_Adr - $50
      ; D_Len + $50 (for module header) = total length of the data module
      modlen = D_Len + $50

    This service call is only finished when the output parameter is 
    "ready" = 1 or an error occurs. The service requires a buffer.






                                  @420[ Download Services ]                 @001[ Overview ]
.435
    PBdlN - Download per Name (continue)

    -> Parameter <modname   >: BYTE (array)

    PROFIBUS name of the memory area (Domain), where the B&R module will be
    downloaded. This name can be determined, for example, with the @241[PBgetOVI]
    function.














                                        @430[ PBdlN ]                       @001[ Overview ]
.440
    PROFIBUS Library - Event Services

    This function group contains event management services:

    @441[PBevnotI] Event notification per index
    @450[PBackevI] Acknowledge event notification per index
    @460[PBaltevI] Alter event condition monitoring per index














                                                                      @001[ Overview ]
.441
    PBevnotI - Event Notification per Index

    @442[PBevnotI](enable,kr,index,ev_nr,adr(data),len,ready,error_nr)

    Parameter Data Types:
    ->  enable    : BIT           The function block is only executed if
                                  enable = 1.
    ->  kr        : WORD          Communication reference (logical connection
                                  number, see function block @031[PBinfoKR]) of the
                                  target station.
    ->  @445[index     ]: WORD          PROFIBUS index of the event object to be sent.
    ->  ev_nr     : BYTE          Event number
    ->  data      : ALL           Event information to be sent.
    ->  len       : WORD          Length of the event information in bytes.
    <-  ready     : BIT           Service is finished.
    <-  @800[error_nr  ]: WORD          Error number (0 = no error).





                                      @442[ Continue ]                      @001[ Overview ]
.442
    PBevnotI - Event Notification per Index (continue)

    An event notification service (per PROFIBUS service) can be sent via the
    logical connection number "kr" using this function. The data to be sent must
    be placed in the data buffer "data". The parameter "len" indicates the
    length of the data.

    This service call is only finished when the output parameter is
    "ready" = 1 or an error occurs. This service requires a buffer.












                                   @440[ Event Services ]                   @001[ Overview ]
.445
    PBevnotI - Event Notification per Index (continue)

    -> Parameter <index     >: WORD

    PROFIBUS index of the event object. This index can be determined using
    the @250[PBgetOVN] function.















                                      @441[ PBevnotI ]                      @001[ Overview ]
.450
    PBackevI - Acknowledge Event Notification per Index

    @450[PBackevI](enable,kr,index,ev_nr,ready,error_nr)

    Parameter Data Types:
    ->  enable    : BIT           The function block is only executed if
                                  enable = 1.
    ->  kr        : WORD          Communication reference (logical connection
                                  number, see function block @031[PBinfoKR]).
    ->  @455[index     ]: WORD          PROFIBUS index of the event object.
    ->  ev_nr     : BYTE          Event number
    <-  ready     : BIT           Service is finished.
    <-  @800[error_nr  ]: WORD          Error number (0 = no error).

    An event notification service per PROFIBUS index is acknowledged with 
    this function.

    This service call is only finished when the output parameter is
    "ready" = 1 or an error occurs. The service requires a buffer.


                                   @440[ Event Services ]                   @001[ Overview ]
.455
    PBackevI - Acknowledge Event Notification per Index (continue)

    -> Parameter <index     >: WORD

    PROFIBUS index of the event object. This index can be determined using
    the @250[PBgetOVN] function.















                                      @450[ PBackevI ]                      @001[ Overview ]
.460
    PBaltevI - Alter Event Condition Monitoring per Index

    @461[PBaltevI](enable,kr,index,ev_en,ready,error_nr)

    Parameter Data Types:
    ->  enable    : BIT           The function block is only executed if 
                                  enable = 1.
    ->  kr        : WORD          Communication reference (logical connection
                                  number, see function block @031[PBinfoKR]).
    ->  @465[index     ]: WORD          PROFIBUS index of the event object.
    ->  ev_en     : BYTE          Event enable:
                                  $FF ... Event enable
                                  $00 ... Event disable
    <-  ready     : BIT           Service is finished.
    <-  @800[error_nr  ]: WORD          Error number (0 = no error).

    An alter event condition monitoring service (service to enable/disable
    an event) is sent per PROFIBUS index with this function.



                                      @461[ Continue ]                      @001[ Overview ]
.461
    PBaltevI - Alter Event Condition Monitoring per Index (continue)

    This service call is only finished if the output parameter is 
    "ready" = 1 or an error occurs. This service requires a buffer.

















                                   @440[ Event Services ]                   @001[ Overview ]
.465
    PBaltevI - Alter Event Condition Monitoring per Index (continue)

    -> Parameter <index     >: WORD

    PROFIBUS index of the event object. This index can be determined using
    the @250[PBgetOVN] function.















                                      @460[ PBaltevI ]                      @001[ Overview ]
.470
    PROFIBUS Library - Services for C110

    This function group contains functions for communication with the C110
    slave controller module:

    @490[PBkeyena] Enable key stroke message
    @500[PBkeyon ] Call key status

    In order to send a sequence of data to the C110 controller, the PROFIBUS
    standard service @401[PBirepI] is used. This function sends an information
    report service to the C110 controller. The data content for this call
    is transferred as a string to the C110 (see C110 Controller description).
    Access occurs via the constant index $FE04.
    In order to receive the key stroke message sent by the C110 controller,
    the PROFIBUS standard service @271[PBrec] is used. This function allows the panel
    messages to be received. If a message arrives from a C110 controller, 
    (key = pressed), this can be evaluated by the PBrec() function.
    The PBkeyena() function can be separately determined if each key will give
    a message with the PBrec() FBK or it will only be entered in the key flag 
    image.
    
                                      @471[ Continue ]                      @001[ Overview ]
.471
    PROFIBUS Library - Services for C110 (continue)

    Here is a description of the communication between a PCC (SYSTEM 2000) and
    a C110 controller:

    The C110 is a slave controller and only provides one communication
    object. The strings sent to this object are interpreted as screen sequences
    (on VT100) by the C110. The string is addressed via the fixed index $FE04.
    The only possible service is the Information Report service. Only one
    @474[Connection], via which the communication is handled, can be made to the C110.
    Therefore, only one station can communicate with the C110. 

    Transferring the key presses also occurs via Information Report services.
    Therefore two types can be combined for the key call:

    @472[< Key Image   >] ... in a BIT array in the DPR of the network controller
    @473[< Key Code    >] ... through code sequences from the pressed keys




                                      @472[ Continue ]                      @001[ Overview ]
.472
    PROFIBUS Library - Services for C110 (continue)

    Key Image:

    The sent C110 information is evaluated so that a image of the
    individual keys is entered in the DPR of the network controller. If a
    key press follows, it is reported by the C110 controller to the PCC
    and the corresponding bit is set in the DPR. The status of all C110
    controller keys can be requested with the @500[PBkeyon] FBK.

    The connection to the C110 controller is constantly monitored. If it is
    broken, the key flags in the DPR are set to 0.









                                      @473[ Continue ]                      @001[ Overview ]
.473
    PROFIBUS Library - Services for C110 (continue)

    Key Codes:

    In addition, each key press can be evaluated using the key code message. 
    It can also be individually set for each key whether a key press is to be
    reported to the PCC, or whether the appropriate bit is just to be set in
    the DPR. Therefore you can specifically react to an individual key press
    or directly link the status of the key.

    Enabling or disabling keys occurs by using the @490[PBkeyena] FBK.
    Here is only set which keys are registered. The message itself must be
    received by the @271[PBrec] FBK. Here it is important that the messages for
    the enabled keys are really received by calling the PBrec() FBK. In this
    case, a positive receive acknowledgment only occurs when the data is
    received by the application software.





                                      @474[ Continue ]                      @001[ Overview ]
.474
    PROFIBUS Library - Services for C110 (continue)

    Establishing the Connection:

    Each C110 controller has an open connection.
    To be able to make a connection from a PCC to a controller, a
    corresponding connection must be entered on the PCC. To do this, either
    the standard configuration module NW_PLC16.BR or a network configuration
    module created with the network configurator can be used.
    The values of the parameters for this connection are to be entered
    as follows corresponding to the menu in the network configurator:

        Name    :       C110_AUTO         Code            :       Default
        Type    :       MMAZ              vb_ci           :       1000
        mul     :       0                 profile_nr      :       0
        ci      :       300





                                      @475[ Continue ]                      @001[ Overview ]
.475
    PROFIBUS Library - Services for C110 (continue)

                                  Initiator                     Responder

        Attribute               : Defined                       Open
        Establish               : Auto                          Auto
        max SCC                 : 0                             0
        max SAC                 : 8                             8
        spdu_high               : 240                           240
        spdu_low                : 240                           240
        ClientService[0]        : $00                           $00
        ClientService[1]        : $00                           $00
        ClientService[2]        : $80                           $80
        pw                      : 0                             0
        group                   : $ff                           $ff
        rsap                    : 128                           128





                                      @476[ Continue ]                      @001[ Overview ]
.476
    PROFIBUS Library - Services for C110 (continue)

    For the entry of the C110 stations, these are to be entered in the
    "Hardware" entry with "PB_BTCTR" .
    As there is only one connection on the C110 controller, only one PCC can
    ever take up the connection with the C110 controller at one time.
    "4" must be set for the Destination SAP (DSAP) for these connections, as
    this channel on the C110 controller is reserved for this purpose.

    Note:
    The current version of the network configurator doesn't yet fully
    support the configuration of the C110 connection. For this reason, the
    generated configuration module must be adjusted with the program "cv_nwkfg".
    For this, the option "-t" must be entered.

    Call: cv_nwkfg   -t   -p.\   cfgmodul.nwm

    For this, the compiled configuration module "cfgmodul.br" is placed
    on the directory ".\br". This is to be loaded to the controller.


                                      @477[ Continue ]                      @001[ Overview ]
.477
    PROFIBUS Library - Services for C110 (continue)

    Example of Communication with the C110:

    The example program determines the communication reference (logical
    connection number) of the connection to the C110 controller from the
    network configuration module. The connection is called "C110_x" (with x
    corresponding to the station number) in the standard configuration module.
    Automatic connection establishing must be configured for this connection.
    The message bit is switched on for each controller key. In the main program,
    the flag image is placed in an array, arriving telegrams are evaluated and
    data is displayed on the connected controller.

    If the connection is broken, the PBkeyon() FBK returns error 4012 
    (connection is inactive). If the connection is re-established, it
    participates in data exchange again.





                                      @478[ Continue ]                      @001[ Overview ]
.478
    PROFIBUS Library - Services for C110 (continue)

    INIT SP of the task:

      ; PROFIBUS initialization
      initok = 0
      PBinit(1,10,0,0,inierr,memadr)
      ; 10 buffers are reserved (so 10 FBK calls are possible)

      ; Name of C110 connections in the standard configuration module
      ; C110_0, C110_1, ... to C110_15

      ; Determine KR of station 0
      if inierr = 0 then
          PBinfoKR(1,"C110_0",0,error,kr)
          if error = 0 then
              initok = 1
                 .
                 .
                 .

                                      @479[ Continue ]                      @001[ Overview ]
.479
    PROFIBUS Library - Services for C110 (continue)

                 .
                 .
                 .
              ; enable all keys (3 key modules)
              ena_key[0] = $FFFF
              ena_key[1] = $FFFF
              ena_key[2] = $FFFF
              PBkeyena(1,kr,adr(ena_key),sizeof(ena_key),error)
              if error <> 0 then
                  initok = 0
              endif
          else
              initok = 0
          endif
      endif




                                      @480[ Continue ]                      @001[ Overview ]
.480
    PROFIBUS Library - Services for C110 (continue)

    Cyclic part of the task:

      ; Request connection status 
      if initok = 1 then
          ; Request connection status with station 0
          PBstatKR(1,kr,error,kr_stat)
          if error = 0 then
              if kr_stat = $FF then
                  conn_on = 1
              else
                  ; Switch over connection to automatic mode
                  ; (establish connection automatically)
                  PBautokr(1,kr,1,ready,error)
              endif
          endif
      endif



                                      @481[ Continue ]                      @001[ Overview ]
.481
    PROFIBUS Library - Services for C110 (continue)

      ; Data exchange: Send data to display, if "send" is set
      if conn_on = 1 then
          if send = 1 then
              PBirepI(1,kr,$FE04,0,adr(outdata[0]),len,ready,error)
              if error <> 0 then
                  error_nr = error_nr + 1
              endif
              if ready <> 0 then
                  send = 0
              endif
          endif
      endif







                                      @482[ Continue ]                      @001[ Overview ]
.482
    PROFIBUS Library - Services for C110 (continue)

      ; Request states of all keys
      if conn_on = 1 then
          PBkeyon(1,kr,adr(keys),sizeof(keys),error)      ; Key status image
      endif

      ; Receive key code
      PBrec(1,adr(par_struct),ready,error,dataptr)        ; Key codes
      if ready = 1 then
          incount = incount + 1
          if par_struct.kr = kr then
              loop i = 0 to par_struct.len - 1 do
                  datacopy access (dataptr + i)
                  indata[i] = datacopy
              endloop
          endif
      endif



                                  @470[ Services For C110 ]                 @001[ Overview ]
.490
    PBkeyena - Enable Key Stroke Message

    @491[PBkeyena](enable,kr,adr(ena_ptr),len,error_nr)

    Parameter Data Types:
    ->  enable    : BIT           The function block is only executed if
                                  enable = 1.
    ->  kr        : WORD          Communication reference (logical connection
                                  number, see function block @031[PBinfoKR]).
    ->  ena_ptr   : BYTE (array)  Each bit in this BYTE array is assigned to a
                                  key and indicates if the key status is to be
                                  sent with the @271[PBrec] FBK:
                                  Bit = 1 ... Send key status to the PCC
                                  Bit = 0 ... Only save key status in the flag
                                  image






                                      @491[ Continue ]                      @001[ Overview ]
.491
    PBkeyena - Enable Key Stroke Message (continue)

    ->  len       : WORD          Length of the BYTE array ena_ptr.
                                  The length len should always be an even 
                                  number, as two bytes are reserved for each
                                  key block by the C110 controller.    
    <-  @800[error_nr  ]: WORD          Error number (0 = no error).

    This function can determine which keys on a C110 controller will send a
    message to the PCC.
    If a key is pressed on a C110 controller, this is entered in the key flag
    image (in the DPR) on the network controller as bit = 1. If this key is 
    released, the key flag bit is set to 0. With the function PBkeyena(), you
    can determine if a message is being sent to the PCC for each key, in
    addition to the flag image in the DPR. Therefore, each key is assigned a
    bit in the BYTE array "ena_ptr". If a key is pressed and the respective
    bit in the BYTE array "ena_ptr" is 1, the key stroke causes a message to
    be sent to the application via the @271[PBrec] function. Otherwise, the key 
    status is only stored in the flag image.


                                      @492[ Continue ]                      @001[ Overview ]
.492
    PBkeyena - Enable Key Stroke Message (continue)

    The PBkeyena() function only accesses the memory area in the DPR on the
    network controller, and so doesn't need a buffer.

















                                  @470[ Services for C110 ]                 @001[ Overview ]
.500
    PBkeyon - Call Key Status

    @501[PBkeyon](enable,kr,adr(key_ptr),len,error_nr)

    Parameter Data Types:
    ->  enable    : BIT           The function block is only executed if
                                  enable = 1.
    ->  kr        : WORD          Communication reference (logical connection
                                  number, see function block @031[PBinfoKR]).
    <-> key_ptr   : BYTE (array)  Each bit in this BYTE array is assigned to a
                                  key and indicates if this key is pressed or 
                                  not:
                                  Bit = 1 ... Key is pressed
                                  Bit = 0 ... Key is not pressed
    ->  len       : WORD          Length of the BYTE array key_ptr.
                                  The length len should always be an even 
                                  number, as two bytes are reserved for each
                                  key block by the C110 controller.    
    <-  @800[error_nr  ]: WORD          Error number (0 = no error).


                                      @501[ Continue ]                      @001[ Overview ]
.501
    PBkeyon - Call Key Status (continue)

    You can request the keys which are being pressed on a C110 controller
    with this function. The status of the keys is then saved in a BYTE 
    array with each bit assigned to a key.
    If a key is pressed on the C110 controller, the appropriate bit is set 
    in the key flag image. If the key is then released, the key flag is 
    reset. If the connection to the C110 broken, the appropriate error number
    is given on the "error_nr" output and the key flags are set to 0.

    The PBkeyon() function only accesses the memory area in the DPR on the
    network controller and so does not require a buffer.









                                  @470[ Services for C110 ]                 @001[ Overview ]
.540
    PROFIBUS Library - Sub-Index for Read Services

    The sub-index is needed when accessing elements of arrays or structures:

    - Simple Data Type Variables:
      For variables with simple data types, (BIT, INT8, INT16, INT32, BYTE, 
      WORD, LONG and FLOAT), the value 0 must always entered for the "subindex"
      parameter!

    - Array Elements:
      To be able to access a single array element, the number of this array
      variable must be entered for the "subindex" parameter. If, for example
      you want to read the fourth element (element with index 3) of an array
      variable, you must enter the value 4 for the "subindex" parameter.
      To read the entire array, the "subindex" parameter must be 0!






                                      @541[ Continue ]                      @001[ Overview ]
.541
    PROFIBUS Library - Sub-Index for Read Services (continue)

    - Structure Elements:
      Elements of a structure variable cannot be identified by their names. To
      access a single element of a structure, the number of the element in the
      structure (beginning with 1) must be entered for the "subindex" parameter.
      If, for example, you have a structure variable with elements X, Y and Z,
      element Z will be addressed with sub-index 3.
      To read the entire structure, the "subindex" parameter must be 0!












                                                                      @001[ Overview ]
.542
    PROFIBUS Library - Subindex for Write Services

    The sub-index is needed when accessing elements of arrays or structures:

    - Simple Data Type Variables:
      For variables with simple data types, (BIT, INT8, INT16, INT32, BYTE, 
      WORD, LONG and FLOAT), the value 0 must always entered for the "subindex"
      parameter!

    - Array Elements:
      To be able to access a single array element, the number of this array
      element must be entered for the "subindex" parameter. If, for example
      you want to write the fourth element (element with index 3) of an array
      variable, you must enter the value 4 for the "subindex" parameter.
      To write the entire array, the "subindex" parameter must be 0!
      





                                      @543[ Continue ]                      @001[ Overview ]
.543
    PROFIBUS Library - Sub-Index for Write Services (continue)

    - Structure Elements:
      Elements of a structure variable cannot be identified by their names. To
      access a single element of a structure, the number of the element in the
      structure (beginning with 1) must be entered for the "subindex" parameter.
      If, for example, you have a structure variable with elements X, Y and Z,
      element Z will be addressed with sub-index 3.
      To write the entire structure, the "subindex" parameter must be 0!












                                                                      @001[ Overview ]
.550
    APPENDIX : LIBRARY Information


    @551[< General Information   >]     Requirements etc.
    @560[< Guidelines            >]     PROFIBUS Library Applications
    @600[< Server Functions      >]     Server Functions and Programming the PCC
    @610[< Network Configuration >]     Network Configuration Module
    @620[< PROFIBUS FDL          >]     Sending/Receiving Layer2 Services
    @650[< Object Directory      >]     Object Directory and Object Descriptions
    @700[< PROFIBUS Indices      >]     PROFIBUS Indices in SYSTEM 2000
    @750[< Syntax                >]     Syntax for Function Explanations
    @800[< Error Numbers         >]     Summary of all Error Numbers
    @900[< History               >]     New Functionalities and Version Changes








                                                                      @001[ Overview ]
.551
    PROFIBUS Library : General Information

    Data from a PROFIBUS atation can be read, or data can be sent to a PROFIBUS
    station using the PROFIBUS library functions.
    You can find detailed information on the topic "PROFIBUS Network" in the
    "PROFIBUS User's Manual".

    Notes:
    - Before you can use the PROFIBUS library functions in your project, you
      must import the library into the appropriate project data bank.

    - As the PROFIBUS library contains AVT functions, these library functions
      can only be used if the Library Runtime Module (B&R module PB_LIB.BR)
      exists on the CPU (application ROM)!

    - All PROFIBUS library functions return an @800[Error Number] if an error occurs.





                                      @552[ Continue ]                      @001[ Overview ]
.552
    PROFIBUS Library : General Information (continue)

    Almost all PROFIBUS library functions have the following input and output
    parameters:

    Input Parameter "enable":
    This input enables the function block (FBK). The "enable" input must
    remain active for the whole time that the service is processed! This means
    that the "enable" input must remain set to 1 until the service is 
    finished (output "ready" = 1 or output "error_nr" <> 0).

    Output Parameter "ready":
    Service is finished. This output is only set to 1 when the service was
    completed without error. The "ready" output will be reset in the next cycle.

    Output Parameter "error_nr":
    If the service was not responded to, or an error occurred, the appropriate
    error number is returned at the "error_nr" output. In this case, the 
    "ready" output is not reset.


                                      @553[ Continue ]                      @001[ Overview ]
.553
    PROFIBUS Library : General Information (continue)

    If there is no "ready" output for a function block, it is a function block
    which provides the response as soon as it has been called (these function
    blocks do not allocate a structure in the DPR of the network controller).
    All othe function blocks need several task cycles until the response is
    made available.

    The following graphic shows the cyclic process of a FBK call:

    If error-free:

    Cycle:        1      2      3      4      5      6      7      8
                                                            
                  ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฟ
    "enable"   ฤฤฤู                              ภฤฤฤฤฤฤฤฤฤฤฤฤฤฤ
                                               ฺฤฤฤฤฟ
    "ready"    ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤู    ภฤฤฤฤฤฤฤฤฤฤฤ

    "error_nr" ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

                                      @554[ Continue ]                      @001[ Overview ]
.554
    PROFIBUS Library : General Information (continue)

    If error occurs:

    Cycle:        1      2      3      4      5      6      7      8
                                                            
                  ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฟ
    "enable"   ฤฤฤู                              ภฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

    "ready"    ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ
                                               ฺฤฤฤฤฟ
    "error_nr" ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤู    ภฤฤฤฤฤฤฤฤฤฤฤ









                                      @555[ Continue ]                      @001[ Overview ]
.555
    PROFIBUS Library : General Information (continue)

    Notes:
    The PROFIBUS library function blocks encode a service request, send the
    service and wait for the response from the other station. No other 
    services can be sent via this function block while the response is still
    outstansding. After the service response, the "ready" output reports that
    the service was responded to ("ready" = 1), and that if necessary, data is
    available. The "ready" output is reset in the next cycle.
    If the service was not responded to or if another error occurred, the
    function block reports the appropriate error. The function block is only
    ready for a new service when the old service is finished ("ready" = 1) or
    when an error was registered.
    Some function blocks do not send messages via the bus. Instead they are only
    called for exchanging status information. These function blocks must only be
    called once and return the response immediately (function blocks without
    "ready" output).




                                      @556[ Continue ]                      @001[ Overview ]
.556
    PROFIBUS Library : General Information (continue)

    If messages are sent from a function block, a temporary memory buffer is
    needed until the service has been completely responded to. These
    temporary memory buffers already apply at initialization, via the
    PBinit() function. The number of necessary buffers is to be entered as a
    parameter. Whether a FBK needs a buffer or not is given in the function
    description for each FBK.













                                      @550[ APPENDIX ]                      @001[ Overview ]
.560
1    PROFIBUS Library : Guidelines

    In the following section, you will see what you need to pay attention
    to when using PROFIBUS functions. Several typical applications for the
    PROFIBUS library are also described in this section.

    Read/Write Variables:
    A variable can be read or written under an index entry (function PBreadI()
    and PBwriteI()) or name (function PBreadN() and PBwriteN()) from the target
    station. Arrays, array elements or structures can also be accessed.
    However the length of the data is not allowed to exceed the maximum
    length of a PROFIBUS frame (approx. 230 bytes)!

    Read/Write Variable Area:
    Arrays or structures which exceed the size of a PROFIBUS frame cannot be
    accessed using the normal Read/Write services. To enable easy access to
    these arrays or structures, the functions PBreadX() and PBwriteX() were
    added.



                                      @561[ Continue ]                      @001[ Overview ]
.561
    PROFIBUS Library : Guidelines (continue)

    PROFIBUS Variable Lists:
    Variables can be summarized in lists using the functions PBdefVLI()
    and PBdefVLN(). These variable lists can be read/written with the normal
    read/write services (restriction is again the PROFIBUS frame length).

    B&R Variable Lists:
    More than one variable can be accessed with a service using the functions
    PBrdDVL() and PBwrDVL() (also without first having to define a variable
    list)!
    The functions PBrdDVL() and PBwrDVL() are B&R specific, therefore they can
    only be used for data exchange between two B&R devices!








                                      @562[ Continue ]                      @001[ Overview ]
.562
    PROFIBUS Library : Guidelines (continue)

    Read/Write Memory Area:
    A memory block, which can be read/written via the network, can be reserved
    in the DPR of the network controller using the PBinit() function (for 
    restrictions, see descriptions of the functions PBrdDPR() or PBwrDPR()).
    A variable (structure, array) from a task can be placed in this memory area
    with the access operator.
    Attention: data consistancy is not guaranteed (the area is volatile).
    The advantage of this type of accessing is that responses to the read/write
    services are carried out directly from the network controller, and so
    no system time (CPU time) is needed on the target station.
    Service responses are also faster and the data length is not limited to the
    maximum length of a PROFIBUS frame.







                                      @563[ Continue ]                      @001[ Overview ]
.563
    PROFIBUS Library : Guidelines (continue)

    Broadcast/Multicast Data Traffic:
    A message can be sent in broadcast or multicast using the PBirepI() 
    function. The included given connection must be a broadcast or multicast
    connection! Such messages can be received and evaluated using the PBrec()
    function.
    A message can also be sent on a standard connection using the PBirepI()
    function (message only goes to a controller). This message can also be
    received and evaluated using the PBrec() function.

    Sending Layer2 Services and Receiving Layer2/Layer7 Services:
    Sending Layer2 services is possible using the PBsend() function block.
    PROFIBUS services (both Layer7 and Layer2 services) can be received
    using the function block PBrec().






                                      @564[ Continue ]                      @001[ Overview ]
.564
    PROFIBUS Library : Guidelines (continue)

    Synchronizing PCCs via the Network:
    A message can be sent from a PCC to all the others via the PBirepI()
    service.
    All receive stations can be synchronized by receiving this message. For
    this purpose, the connection on which the message is to be received must
    be stated when the PBsyncKR() function block is called. This function block
    returns a counter which is incremented each time a telegram is received on
    the connection. The precision of the time synchronization can be determined
    with the call rate of the function block PBsyncKR().
    Incrementing the counter occurs (simultaneously) on all stations immediately
    the last character of the telegram was received.
    The sending stations can also be synchronized via the function block 
    PBsyncKR().






                                      @565[ Continue ]                      @001[ Overview ]
.565
PROFIBUS Library : Guidelines (continue)

    Connection Management:
    A setting can be made so that a connection is established by the network
    configuration. In this way, the user does not
    need to worry about establishing the connection. Broadcast or multicast
    connections are always established!
    Connections which are not configured automatically can be switched to
    automatic using the PBautoKR() function.
    The current connection status can be requested using the PBstatKR() 
    function (connection made/not made).
    The accompanying communication reference (logical connection number) can
    be designated to a connection name using the PBinfoKR() function.
    Additional information about the connection can also be called with this
    function.






                                      @550[ APPENDIX ]                      @001[ Overview ]
.600
    PROFIBUS Library : Server Functions and Programming the PCC

    Server functions are implemented on the PCCSo that service requests can
    be sent to a PCC. A request is received by the PROFIBUS 
    network module, sent to the CPU where it is processed and responded to
    by a server task. The server routines are integrated into the operating
    system, and do not need to be implemented by the user.
    Not only variable access is possible using these routines, all
    necessary services for programming the PCC are also available.












                                      @550[ APPENDIX ]                      @001[ Overview ]
.610
    PROFIBUS Library : Network Configuration Module

    A so-called network configuration module, in which all necessary
    configuration data for the respective station is contained, is created
    for each station in the PROFIBUS network.

    Both standard configuration modules and special configurations created
    by the network configurator can be used for the network configuration.
    You can find detailed information on this topic in the "PROFIBUS User's
    Manual".

    For some function blocks, it is enough to enter the communication reference
    (logical connection number), to clearly address one station. The logical
    connection number can be determined using the PBinfoKR() function block.







    @611[ Continue ]                        @550[ APPENDIX ]                      @001[ Overview ]
.611
    PROFIBUS Library : Network Configuration Module (continue)

    Which connections are to be established automatically (parameter vb_info
    of KBL, see "PROFIBUS User's Manual") can be entered in the network 
    configuration. In addition, a connection for which no automatic connection
    is configured, can be switched to automatic connection (automatic mode) with
    the PBautoKR() function block. This is necessary for standard configuration
    modules, for example.
    If a connection with make connection automatic is broken by interference on
    the network (e.g. bus connector unplugged), the network controller 
    independently tries to re-make the connection (in definable intervals).
    This means that the user does not need to worry about making/breaking
    connections.








                                      @550[ APPENDIX ]                      @001[ Overview ]
.620
    PROFIBUS Library : PROFIBUS FDL

    It is possible to communicate with other PROFIBUS stations via PROFIBUS FDL
    on a Layer2 basis. All PROFIBUS products from Siemens (SINEC-L2), for
    example, are based on the standardized PROFIBUS Layer2 and are only 
    different regarding the form of Layer7. :

    - FMS ................. according to PROFIBUS standard
    - L2-DP ............... according to PROFIBUS standard
    - L2-TF ............... Siemens-specific
    - L2-interfaces ....... Siemens-specific
      There are different types of "data transfer types" for the 
      SINEC-L2 system:
       - Standard connection
       - AGAG connection
       - Cyclic periphery (ZP)
       - Layer2 access FDL




                                      @621[ Continue ]                      @001[ Overview ]
.621
    PROFIBUS Library : PROFIBUS FDL (continue)

    All PROFIBUS products used by B&R are based on PROFIBUS Layer2 + FMS.
    Layer2 is used via function blocks for connecting with SINEC L2 FDL.
    Furthermore, communication can also occur via FMS at the same time.
    Here, there is the problem that direct assigning to a receiving station
    for received telegrams must be found. This station is either the FMS or the
    Layer2 receive FBK. Assigning is carried out based on the following
    principles:

    - Before Layer2 services can be called, a @625[Layer2 SAP] (SAP = Service
      Access Point) must be configured for it.
    - A @625[Layer2 SAP] which is configured for receiving services, directs all
      receive telegrams to the Layer2 receive FBK.
    - Attention: When operating both FMS and FDL, the user must ensure that no
      Layer2 services are processed via SAPs which are used by Layer7.





                                      @622[ Continue ]                      @001[ Overview ]
.622
    PROFIBUS Library : PROFIBUS FDL (continue)

    The following limitations must be noted:

    - The maximum baudrate of 500 KBit/sec (given by existing hardware).
    - The @627[Layer2 Timing Parameters] must be correctly set.
    - PROFIBUS firmware V2.00 is required for using the Layer2 FBKs
      (the PROFIBUS firmware must exist on the module NW100 or NW150).













                                      @623[ Continue ]                      @001[ Overview ]
.623
    PROFIBUS Library : PROFIBUS FDL (continue)

    The PB_LIB.BR library is also to be used to operate the FDL functions
    (also for FMS). This permits FMS and FDL services to be used from version
    2.00 onwards.
    Sending Layer2 services is possible via the PBsend() FBK. The PBrec() FBK
    enables Layer7 and Layer2 services to be received.
    Initialization using the PBinit() FBK is necessary for operating the
    Layer2 function blocks (also for FMS operation). 
    The PBsend() FBK is equipped with a version check. This checks if the
    network card in question has firmware version V2.00 or higher. If this is
    not the case, the FBK immediately registers an error. 
    The Layer2 differentiates between three service components:

    - Request
    - Confirm
    - Indication




                                      @624[ Continue ]                      @001[ Overview ]
.624
    PROFIBUS Library : PROFIBUS FDL (continue)

    The request sent is acknowledged by the confirmation. It can also directly
    return receive data (SRD service).
    For reasons of ease, the request and confirmation are covered by one FBK
    (function block PBsend()). If the function block returns the "ready" signal,
    confirmation has already happened. The user can then directly access the
    response data or the response status, without having to especially collect
    the confirmation and then assign it to the request.












                                      @625[ Continue ]                      @001[ Overview ]
.625
    PROFIBUS Library : PROFIBUS FDL (continue)

    Layer2 SAPs:

    Now, the meaning and use of Layer2 SAPs is to be described in more detail.
    A Layer2 SAP can be understood as a logical channel, via which a FMS
    connection is run or a FDL service is processed.

    There are 64 Layer2 SAPs, of which some are reserved:
       SAP = 1 ........... for management purposes 
       SAP = 63 .......... global SAP for broadcasts

    The following SAPs are reserved for PROFIBUS DP:
       SAP = 54 to 62
       SAP = NIL ......... Default SAP






                                      @626[ Continue ]                      @001[ Overview ]
.626
    PROFIBUS Library : PROFIBUS FDL (continue)

    All other SAPs can be used freely. However, the following procedure is
    recommended:

    - As a rule, the SAPs 0, 2 to 33 are used for FMS connections.
      These SAPs should not be configured for FDL services (one SAP is needed
      per FMS connection).
    - If you can't avoid using these SAPs for FDL services, it must be 
      guaranteed that no FMS connections are configured for these SAPs!
    - If using the standard network configuration modules "NW_PLC32.BR"
      or "NW_PLC16.BR", the SAPs 0, 2 to 33, 62 and 63 are filled with FMS 
      connections!








                                      @627[ Continue ]                      @001[ Overview ]
.627
    PROFIBUS Library : PROFIBUS FDL (continue)

    Layer2 Bus Parameters:

    When connecting PROFIBUS with other stations, you must pay attention that
    you have the correct Layer2 bus parameter settings! The following 
    observations also apply for a baudrate of 500 KBit.
    For example, the set ASICs for the new Siemens switching devices allow for
    very fast bus timing. So that these switching devices can be communicated
    with, the Layer2 bus parameters must be set correctly on both sides. The
    following times are of fundamental importance:

       TSET
       min_TSDR
       max_TSDR
       Tsl





                                      @628[ Continue ]                      @001[ Overview ]
.628
    PROFIBUS Library : PROFIBUS FDL (continue)

    There are two types of connections between other station/B&R station:
    1. B&R with standard configuration module:
        - The Layer2 bus parameters are pre-defined by the configuration module
        - The following values are to be set on the other station:
          TSET     = 255
          min_TSDR = 255
          max_TSDR = 1000
          Tsl      = 3000
    2. B&R freely-configured (the Layer2 bus parameters can be set as desired):
        - The following limits apply to the B&R switching device:
          TSET     = 150
          min_TSDR = 350
          max_TSDR = 400
          Tsl      = 2000
        - The following is to be set on the other station:
          TSET     = 150
          min_TSDR = 255 (usually largest possible value!)
          max_TSDR = 400
          Tsl      = 2000
                                      @629[ Continue ]                      @001[ Overview ]
.629
    PROFIBUS Library : PROFIBUS FDL (continue)

    Notes:
    The parameter TSET is not evaluated for B&R switching devices. The timing
    setting is carried out via min_TSDR and max_TSDR.
    All times must (as far as possible) have the same settings on both stations!
    As a rule, the setting for Tqui can be ignored (normally Tqui = 0).
    The TTR setting does not affect the correct Layer2 interplay of the 
    individual stations, but a "large enough" value must be selected.
    Enough time per token cycle must remain for processing Layer2 services.











                                      @550[ APPENDIX ]                      @001[ Overview ]
.650
    PROFIBUS Library : Object Directory

    So that the stations in a PROFIBUS network can communicate, each station
    must make a description of its objects available to all other stations
    (called "Object Descriptions").
    All object descriptions for a station are summarized in the object 
    directory. Access to individual objects is possible using this object
    directory. Only with this object directory can all bus stations make the
    meaning and structure of their local objects available on a station.
    You can find detailed information on the topic "Object Directory" in the
    "PROFIBUS User's Manual".
    The object descriptions for a station can be read by other stations using
    the PROFIBUS service Get OV. There are two object description formats 
    to chose from:

    @660[Long Version ] ... All information which is available about an object is
                      transferred.
    @680[Short Version] ... Only the most important object information is transferred.



                                      @651[ Continue ]                      @001[ Overview ]
.651
    PROFIBUS Library : Object Directory (continue)

    The object description cannot be accessed via a structure, as the 
    individual elements are not WORD aligned (WORD or LONG elements begin
    at an odd address)! Accessing an object description is possible via
    e.g. a BYTE array.

    If the object description from index 0 is requested, one receives global
    information about all objects on the other station. For the element
    "name length" of this object description, care is advised.
    This element states the length of the symbolic name of the variable on the
    target station. If the symbolic variable name is shorter than the length
    given under "Name Length", empty spaces must be added, to fill out the
    given length under "name length".







                                      @550[ APPENDIX ]                      @001[ Overview ]
.660
    PROFIBUS Library : Long Version of the Object Description

    Individual objects of a station are summarized in object groups (domain,
    program invocation, event, data type, etc.). The object description is
    constructed differently for each object group:

    @663[Domain                         ] Description of Memory Areas
    @664[Program Invocation             ] Program Descriptions
    @665[Event                          ] Event Descriptions
    @666[Data Type                      ] Data Type Descriptions
    @667[Data Type Structure Description] Structure Description of Data Types
    @668[Simple Variable                ] Variable Descriptions
    @669[Array                          ] Description of Arrays
    @670[Record                         ] Descriptions of Records
    @671[Variable List                  ] Variable List Descriptions

    Each object group is assigned an "Object Code" for identification. The
    object code for an object is contained in the element "Object Code" of the
    object description. This means that the object group (domain, program 
    invocation, event, data type, etc.) of an object can be determined using the
    element "Object Code".
                                      @661[ Continue ]                      @001[ Overview ]
.661
    PROFIBUS Library : Long Version of the Object Description (continue)

    If the object description from index 0 (@662[Object Index 0]) is requested, one
    receives global information about all objects on the other station.
    For the element "name length" of this object description, care is advised.
    This element states the length of the symbolic name of the variable on the
    target station. If the symbolic variable name is shorter than the length
    given under "Name Length", empty spaces must be added, to fill out the
    given length under "name length".












    @650[ Object Directory ]                @550[ APPENDIX ]                      @001[ Overview ]
.662
    PROFIBUS Library : Object Index 0 (Long Version)

    Offset in Bytes   Length of Information   Information
            0                  WORD           Index
            2                  BYTE           RAM/ROM Flag
            3                  BYTE           Name-Length (abbr. "NL")
            4                  BYTE           Access-Protection-Supported
            5                  WORD           Version-OV
            7                  LONG           Local-Address-OV-OB
           11                  WORD           ST-OV-Length
           13                  LONG           Local-Address-ST-OV
           17                  WORD           First-Index-S-OV
           19                  WORD           S-OV-Length
           21                  LONG           Local-Address-S-OV
           25                  WORD           First-Index-DV-OV
           27                  WORD           DV-OV-Length
           29                  LONG           Local-Address-DV-OV
           33                  WORD           First-Index-DP-OV
           35                  WORD           DP-OV-Length
           37                  LONG           Local-Address-DP-OV

    @660[ Long Version ]                @650[ Object Directory ]                  @001[ Overview ]
.663
    PROFIBUS Library : Domain (Long Version)

    Object-Code: 2

    Offset in Bytes   Length of Information   Information
            0                  WORD           Index
            2                  BYTE           Object-Code
            3                  WORD           Max-Octets
            5                  BYTE           Password
            6                  BYTE           Access-Groups
            7                  WORD           Access-Rights
            9                  LONG           Local-Address
           13                  BYTE           Domain-State
           14                  BYTE           Upload-State
           15                  BYTE           Counter
           16                  BYTE           Name [NL]
           16+NL               BYTE           ext_len
           17+NL               BYTE           ext [ext_len]

    NL = Name Length

    @660[ Long Version ]                @650[ Object Directory ]                  @001[ Overview ]
.664
    PROFIBUS Library : Program-Invocation (Long Version)

    Object-Code: 3

    Offset in Bytes   Length of Information   Information
            0                  WORD           Index
            2                  BYTE           Object-Code
            3                  BYTE           Number-Of-Domains (abbr. "ND")
            4                  BYTE           Password
            5                  BYTE           Access-Groups
            6                  WORD           Access-Rights
            8                  BYTE           Deleteable
            9                  BYTE           Reusable
           10                  BYTE           PI-State
           11                  WORD           domain_index [ND]
           11+ND*2             BYTE           Name [NL]
           11+ND*2+NL          BYTE           ext_len
           12+ND*2+NL          BYTE           ext [ext_len]

    ND = Number-of-Domains, NL = Name Length

    @660[ Long Version ]                @650[ Object Directory ]                  @001[ Overview ]
.665
    PROFIBUS Library : Event (Long Version)

    Object-Code: 4

    Offset in Bytes   Length of Information   Information
            0                  WORD           Index
            2                  BYTE           Object-Code
            3                  WORD           Index-Event-Data
            5                  BYTE           Length
            6                  BYTE           Password
            7                  BYTE           Access-Groups
            8                  WORD           Access-Rights
           10                  BYTE           Enabled
           11                  BYTE           Name [NL]
           11+NL               BYTE           ext_len
           12+NL               BYTE           ext [ext_len]

    NL = Name Length



    @660[ Long Version ]                @650[ Object Directory ]                  @001[ Overview ]
.666
    PROFIBUS Library : Data Type (Long-Version)

    Object-Code: 5

    Offset in Bytes   Length of Information   Information
            0                  WORD           Index
            2                  BYTE           Object-Code
            3                  BYTE           Name [NL]

    NL = Name Length

    PROFIBUS provides standard data types. The user can also make a new data
    structure from these standard data types, i.e. to define his own data type.








    @660[ Long Version ]                @650[ Object Directory ]                  @001[ Overview ]
.667
    PROFIBUS Library : Data Type Structure Description (Long Version)

    Object-Code: 6

    Offset in Bytes   Length of Information   Information
            0                  WORD           Index
            2                  BYTE           Object-Code
            3                  BYTE           Number-Of-Elements
            4                  WORD           Data-Type-Index(1)
            6                  BYTE           Length(1)
            7                  WORD           Data-Type-Index(2)
            9                  BYTE           Length(2)
           ...                 ...            ...
           3*NE+1              WORD           Data-Type-Index(NE)
           3*NE+3              BYTE           Length(NE)

    NE = Number-Of-Elements




    @660[ Long Version ]                @650[ Object Directory ]                  @001[ Overview ]
.668
    PROFIBUS Library : Simple Variable (Long Version)

    Object-Code: 7

    Offset in Bytes   Length of Information   Information
            0                  WORD           Index
            2                  BYTE           Object-Code
            3                  WORD           Data-Type-Index
            5                  BYTE           Length
            6                  BYTE           Password
            7                  BYTE           Access-Groups
            8                  WORD           Access-Rights
           10                  LONG           Local-Address
           14                  BYTE           Name [NL]
           14+NL               BYTE           ext_len
           15+NL               BYTE           ext [ext_len]

    NL = Name Length



    @660[ Long Version ]                @650[ Object Directory ]                  @001[ Overview ]
.669
    PROFIBUS Library : Array (Long Version)

    Object-Code: 8

    Offset in Bytes   Length of Information   Information
            0                  WORD           Index
            2                  BYTE           Object-Code
            3                  WORD           Data-Type-Index
            5                  BYTE           Length
            6                  BYTE           Number-Of-Elements
            7                  BYTE           Password
            8                  BYTE           Access-Groups
            9                  WORD           Access-Rights
           11                  LONG           Local-Address
           15                  BYTE           Name [NL]
           15+NL               BYTE           ext_len
           16+NL               BYTE           ext [ext_len]

    NL = Name Length


    @660[ Long Version ]                @650[ Object Directory ]                  @001[ Overview ]
.670
    PROFIBUS Library : Record (Long Version)

    Object-Code: 9

    Offset in Bytes   Length of Information   Information
            0                  WORD           Index
            2                  BYTE           Object-Code
            3                  WORD           Data-Type-Index
            5                  BYTE           Password
            6                  BYTE           Access-Groups
            7                  WORD           Access-Rights
            9                  BYTE           Name [NL]
           9+NL                BYTE           ext_len
           10+NL               BYTE           ext [ext_len]
           10+NL+EL            LONG           local-Address [number of
                                              components]

    NL = Name Length, EL = ext_len
    If the record components lie one after the other, only the "local-Address"
    of the first component is transferred. Otherwise the "Number of Components"
    must be known implicitly.
    @660[ Long Version ]                @650[ Object Directory ]                  @001[ Overview ]
.671
    PROFIBUS Library : Variable List (Long Version)

    Object-Code: 10

    Offset in Bytes   Length of Information   Information
            0                  WORD           Index
            2                  BYTE           Object-Code
            3                  BYTE           Number-Of-Elements (abbr. "NE")
            4                  BYTE           Password
            5                  BYTE           Access-Groups
            6                  WORD           Access-Rights
            8                  BYTE           Deleteable
            9                  WORD           Element-Index [NE]
           9+NE*2              BYTE           Name [NL]
           9+NE*2+NL           BYTE           ext_len
           12+NE*2+NL          BYTE           ext [ext_len]

    NE = Number-Of-Elements, NL = Name Length



    @660[ Long Version ]                @650[ Object Directory ]                  @001[ Overview ]
.680
    PROFIBUS Library : Short Version of the Object Description

    The individual objects of a station are summarized in object groups (domain,
    program invocation, event, data type, etc.). The object description is
    constructed differently for each object group:

    @683[Domain                         ] Memory Area Descriptions
    @684[Program Invocation             ] Program Descriptions
    @685[Event                          ] Event Descriptions
    @686[Datentyp                       ] Data Type Descriptions
    @687[Data Type Structure Description] Structure Description of Data Types
    @688[Simple Variable                ] Variable Descriptions
    @689[Array                          ] Descriptions of Aarrays
    @690[Record                         ] Descriptions of Records
    @691[Variable List                  ] Descriptions of Variable Lists

    Each object group is assigned an "Object Code" for identification. The
    object code for an object is contained in the element "Object Code" of the
    object description. This means that the object group (domain, program 
    invocation, event, data type, etc.) of an object can be determined using the
    element "Object Code".
                                      @681[ Continue ]                      @001[ Overview ]
.681
    PROFIBUS Library : Short Version of the Object Description (continue)

    If the object description for index 0 (@682[Object Index 0]) is requested, one
    receives global information about all objects on the other station.
    For the element "name length" of this object description, care is advised.
    This element states the length of the symbolic name of the variable on the
    target station. If the symbolic variable name is shorter than the length
    given under "Name Length", empty spaces must be added, to fill out the
    given length under "name length".












    @650[ Object Directory ]                @550[ APPENDIX ]                      @001[ Overview ]
.682
    PROFIBUS Library : Object Index 0 (Short Version)

    Offset in Bytes   Length of Information   Information
            0                  WORD           Index
            2                  BYTE           RAM/ROM-Flag
            3                  BYTE           Name-Length (abbr. "NL")
            4                  BYTE           Access-Protection-Supported
            5                  WORD           Version-OV













    @680[ Short Version ]               @650[ Object Directory ]                  @001[ Overview ]
.683
    PROFIBUS Library : Domain (Short Version)

    Object-Code: 2

    Offset in Bytes   Length of Information   Information
            0                  WORD           Index
            2                  BYTE           Object-Code
            3                  WORD           Max-Octets













    @680[ Short Version ]               @650[ Object Directory ]                  @001[ Overview ]
.684
    PROFIBUS Library : Program Invocation (Short Version)

    Object-Code: 3

    Offset in Bytes   Length of Information   Information
            0                  WORD           Index
            2                  BYTE           Object-Code
            3                  BYTE           Number-Of-Domains (abbr. "ND")













    @680[ Short Version ]               @650[ Object Directory ]                  @001[ Overview ]
.685
    PROFIBUS Library : Event (Short Version)

    Object-Code: 4

    Offset in Bytes   Length of Information   Information
            0                  WORD           Index
            2                  BYTE           Object-Code
            3                  WORD           Index-Event-Data
            5                  BYTE           Length












    @680[ Short Version ]               @650[ Object Directory ]                  @001[ Overview ]
.686
    PROFIBUS Library : Data Type (Short Version)

    Object-Code: 5

    Offset in Bytes   Length of Information   Information
            0                  WORD           Index
            2                  BYTE           Object-Code

    PROFIBUS provides standard data types. The user can also construct a new
    data structure from this standard data types, i.e. define his own data type.











    @680[ Short Version ]               @650[ Object Directory ]                  @001[ Overview ]
.687
    PROFIBUS Library : Data Type Structure Description (Short Version)

    Object-Code: 6

    Offset in Bytes   Length of Information   Information
            0                  WORD           Index
            2                  BYTE           Object-Code
            3                  BYTE           Number-Of-Elements
            4                  WORD           Data-Type-Index(1)
            6                  BYTE           Length(1)
            7                  WORD           Data-Type-Index(2)
            9                  BYTE           Length(2)
           ...                 ...            ...
           3*NE+1              WORD           Data-Type-Index(NE)
           3*NE+3              BYTE           Length(NE)

    NE = Number-Of-Elements




    @680[ Short Version ]               @650[ Object Directory ]                  @001[ Overview ]
.688
    PROFIBUS Library : Simple Variable (Short Version)

    Object-Code: 7

    Offset in Bytes   Length of Information   Information
            0                  WORD           Index
            2                  BYTE           Object-Code
            3                  WORD           Data-Type-Index
            5                  BYTE           Length












    @680[ Short Version ]               @650[ Object Directory ]                  @001[ Overview ]
.689
    PROFIBUS Library : Array (Short Version)

    Object-Code: 8

    Offset in Bytes   Length of Information   Information
            0                  WORD           Index
            2                  BYTE           Object-Code
            3                  WORD           Data-Type-Index
            5                  BYTE           Length
            6                  BYTE           Number-Of-Elements











    @680[ Short Version ]               @650[ Object Directory ]                  @001[ Overview ]
.690
    PROFIBUS Library : Record (Short Version)

    Object-Code: 9

    Offset in Bytes   Length of Information   Information
            0                  WORD           Index
            2                  BYTE           Object-Code
            3                  WORD           Data-Type-Index













    @680[ Short Version ]               @650[ Object Directory ]                  @001[ Overview ]
.691
    PROFIBUS Library : Variable List (Short Version)

    Object-Code: 10

    Offset in Bytes   Length of Information   Information
            0                  WORD           Index
            2                  BYTE           Object-Code
            3                  BYTE           Number-Of-Elements (abbr. "NE")













    @680[ Short Version ]               @650[ Object Directory ]                  @001[ Overview ]
.700
    PROFIBUS Library : PROFIBUS Indices in SYSTEM 2000

    Accessing variables using PROFIBUS can occur using different types of 
    addressing. "via Name", "via Index" or "via physical Address" can also be
    accessed. It is assumed that a single object of a certain type is found 
    after the given address parameter when addressing.

    Programming SYSTEM 2000 is done on a symbolic level. All variables used in
    application tasks can be addressed as communication objects. As soon as a
    task is loaded on the controller, all of the variables used can be addressed
    as PROFIBUS objects via the network. However, the respective indices are 
    assigned by the PCC when an object is created.

    The problem with this is that an object index cannot be pre-defined as it
    depends on certain factors.






    @701[ Continue ]                        @550[ APPENDIX ]                      @001[ Overview ]
.701
    PROFIBUS Library : PROFIBUS Indices in SYSTEM 2000 (continue)

    In general, the index can be determined using a Get-OV service. PANELWARE
    and INTERACT, for example, work in this way. This is not possible for all
    systems, as the Get-OV service is not always implemented. The Read-per-Name
    service is not always available either. It needs more time to respond, and 
    uses up the system resources of the controller more intensly.

    So that access per Index is still possible in this case, the algorithms used
    to assign the indices must be known. In this way, the respective index can
    be determined for each variable.










    @702[ Continue ]                        @550[ APPENDIX ]                      @001[ Overview ]
.702
    PROFIBUS Library : PROFIBUS Indices in SYSTEM 2000 (continue)

    Start Index for Variables:

    The variables are all in a certain pre-defined area in the object directory.
    This area is characterized by a start index and an end index (see object
    directory SYSTEM 2000). 
    A variable is assigned a specific index, and always one from this area. If
    all indices are assigned, object descriptions cannot be given for other
    variables. These variables can no longer be addressed via the network.

    The start index for the "Process Variable" area is set to $0B00 by default.
    This value can be changed using the PCC configurator (with the menu item
    <I/O><Network>). The index area for variables can be set with the 
    parameters for "Process Variable".






    @703[ Continue ]                        @550[ APPENDIX ]                      @001[ Overview ]
.703
    PROFIBUS Library : PROFIBUS Indices in SYSTEM 2000 (continue)

    Assigning the Index Area for Tasks:

    First, 256 indices are reserved for each task. If this is not enough,
    another 256 indices are given until all variables are assigned. The order
    in which the tasks were installed is decisive when assigning the index area.
    The first task has indices $0B00 to $0BFF, the second $0C00 to $0CFF etc.
    If the tasks are already on the PCC, and are restarted with an INIT or
    TOTALINIT, then the order depends on the start numbers set in the task
    parameters. If downloading occurs, then the tasks are started in the
    download order.









    @704[ Continue ]                        @550[ APPENDIX ]                      @001[ Overview ]
.704
    PROFIBUS Library : PROFIBUS Indices in SYSTEM 2000 (continue)

    Assigning Indices for Variables in a Task:

    The variables are put in order according to a certain algorithm within
    the 256 or more byte index area. The following rules apply:

    - The variables are put in order according to name lengths. Longer names
      come before shorter names.

    - Names with the same lengths are put in reverse alphabetical order. This
      means that the variable BB comes before variable AA.

    - Exactly one index is assigned to each individual variable. Two indices
      are assigned for structures and arrays.






    @705[ Continue ]                        @550[ APPENDIX ]                      @001[ Overview ]
.705
    PROFIBUS Library : PROFIBUS Indices in SYSTEM 2000 (continue)

    Procedure in PG2000:

    All variables which are necessary for communication are to be found in
    a task. The order for the index assignments can be set by their names. Value
    1 is to be entered for the start number in the task parameters (object
    parameters). In this way, this task will be started first when the PCC is
    booted, and always contains the indices from $0B00 upwards. You also have to
    guarantee that this task is always started first after a download. In this
    way, the indices can be determined with the algorithms given above. If the
    variables in the task are later changed, please note that the indices can
    shift according to the names selected.








                                      @550[ APPENDIX ]                      @001[ Overview ]
.750
    PROFIBUS Library : Syntax Description

    Data Types:
    Certain groups of data types are allowed for more than one function.
    So that not all alowed data types have to be stated in the function 
    description, the following group descriptions are given:
    ษออออออออหอออออออัอออออออัอออออออัอออออออัอออออออัอออออออัอออออออัอออออออป
    บ Group  บ  BIT  ณ INT8  ณ BYTE  ณ INT16 ณ WORD  ณ INT32 ณ LONG  ณ FLOAT บ
    ฬออออออออฮอออออออุอออออออุอออออออุอออออออุอออออออุอออออออุอออออออุอออออออน
    บ BASIS  บ       ณ   x   ณ   x   ณ   x   ณ   x   ณ   x   ณ   x   ณ       บ
    วฤฤฤฤฤฤฤฤืฤฤฤฤฤฤฤลฤฤฤฤฤฤฤลฤฤฤฤฤฤฤลฤฤฤฤฤฤฤลฤฤฤฤฤฤฤลฤฤฤฤฤฤฤลฤฤฤฤฤฤฤลฤฤฤฤฤฤฤถ
    บ NOT    บ   x   ณ   x   ณ   x   ณ   x   ณ   x   ณ   x   ณ   x   ณ       บ
    บ FLOAT  บ       ณ       ณ       ณ       ณ       ณ       ณ       ณ       บ
    วฤฤฤฤฤฤฤฤืฤฤฤฤฤฤฤลฤฤฤฤฤฤฤลฤฤฤฤฤฤฤลฤฤฤฤฤฤฤลฤฤฤฤฤฤฤลฤฤฤฤฤฤฤลฤฤฤฤฤฤฤลฤฤฤฤฤฤฤถ
    บ ALL    บ   x   ณ   x   ณ   x   ณ   x   ณ   x   ณ   x   ณ   x   ณ   x   บ
    วฤฤฤฤฤฤฤฤืฤฤฤฤฤฤฤลฤฤฤฤฤฤฤลฤฤฤฤฤฤฤลฤฤฤฤฤฤฤลฤฤฤฤฤฤฤลฤฤฤฤฤฤฤลฤฤฤฤฤฤฤลฤฤฤฤฤฤฤถ
    บ ARRAY  บ  [x]  ณ  [x]  ณ  [x]  ณ  [x]  ณ  [x]  ณ  [x]  ณ  [x]  ณ  [x]  บ
    ศออออออออสอออออออฯอออออออฯอออออออฯอออออออฯอออออออฯอออออออฯอออออออฯอออออออผ
      x  Data type is allowed
     [x] Data type is allowed as array variable or character string

                                      @751[ Continue ]                      @001[ Overview ]
.751
    PROFIBUS Library : Syntax Description (continue)

    Arrows:
    Arrows are used to show input and output parameters. The following
    arrangement applies:
    ษอออออออออหออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
    บ  Arrow  บ  Meaning                                                     บ
    ฬอออออออออฮออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออน
    บ   ->    บ  Input parameter                                             บ
    วฤฤฤฤฤฤฤฤฤืฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤถ
    บ   <->   บ  Input/output parameter. Functionally it is an output        บ
    บ         บ  parameter. Normally loaded with specific information before บ
    บ         บ  the function is called (e.g. an address). The address of a  บ
    บ         บ  variable is generally terminated with adr() [PL2000] or a   บ
    บ         บ  ladder diagram [LAD]                                        บ
    วฤฤฤฤฤฤฤฤฤืฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤถ
    บ   <-    บ  Output parameter                                            บ
    ศอออออออออสออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ



                                      @752[ Continue ]                      @001[ Overview ]
.752
    PROFIBUS Library : Syntax Description (continue)

    Function Blocks:
    Function blocks are not graphically displayed in this Online Help.
    You can find all the relevant information on function blocks, like
    input parameters (->), input/output parameters (<->) and output
    parameters(<-) in the Online Help.














                                      @550[ APPENDIX ]                      @001[ Overview ]
.800
    PROFIBUS Library : Error Numbers

    The following list is a summary of all possible PROFIBUS library error
    messages:

    4000    Device number does not exist
    4002    No buffer free for function ("srv_cnt" too low in PBinit()). This
            error can also occur when reloading a BR module with PROFIBUS
            functions (solution: trigger INIT).
    4011    Connection number does not exist
    4012    Connection is inactive
    4014    Connection cannot be contacted
    4801    Incorrect connection number
    4855    INIT occurred
    4860    Error 1 during service processing
    4861    Error 2 during service processing
    4862    Error 3 during service processing
    4863    Error 4 during service processing
    4864    Received data length is larger than the reserved data buffer
    4865    Error response was received

                                      @801[ Continue ]                      @001[ Overview ]
.801
    PROFIBUS Library : Error Numbers (continue)

    4866    Incorrect "spec_id" from the user
    4867    Service is not supported
    4868    Error occurred when sending an unconfirmed service
    4869    A PROFIBUS function was called, although no PBinit call had
            previously been carried out
    4870    Service management error 1 occured
    4871    Service management error 2 occured
    4872    Service management error 3 occured
    4873    Service management error 4 occured
    4874    Not enough array elements were given with PBgetOVM()
    4875    Connection is not VB orientated (error with PBconn)
    4876    A connect or abort was carried out on an AUTO connection
    4877    Connection is already set to AUTO
            (another connect was triggered)
    4878    Connection is not established and connect call was made
    4879    Invalid command was given
    4880    PBinit() was called twice


                                      @802[ Continue ]                      @001[ Overview ]
.802
    PROFIBUS Library : Error Numbers (continue)

    4881    PBinit() does not support additional parameters at the moment 
    4882    Connection cannot be used for PROFIBUS functions (incorrect device)
    4883    Specified connection is for another device
    4884    A function was called although PBinit() was not active
    4885    Given name is too long
    4886    PBinit(): Configuration module contains no network device
    4887    Error when requesting a buffer
    4888    Rsync or Ssync Ptr is a NULL pointer
    4889    Reject: Too many parallel services were activated on one connection
    4890    Only one download is allowed to be handled on a connection at any
            one time (if a second download is called while the first is still
            active, this error message is returned)
    4891    Error processing a download; (DL state maschine does not wait for a
            TERMDL_response)
    4892    Download is currently active! TerminateDL is sent
    4893    State conflict during download
    4894    An invalid service was received with PBrec()


                                      @803[ Continue ]                      @001[ Overview ]
.803
    PROFIBUS Library : Error Numbers (continue)

    4895    Incorrect length given for a download
    4896    Terminate download received during download process
    4897    Other station reports: Final Result 0 (=Error)
    4923    PBsend(): Parameter invalid
    4924    PBsend(): Operating equipment for the local FDL controller is not
            available or not adequate
    4925    PBsend(): Source SAP (local SAP) is not configured for the desired
            service
    4926    PBsend(): SAP is already configured
    4927    PBsend(): The locale station is not in the logical token ring
    4928    PBsend(): No, or no plausible reaction from the remote station
    4931    PBsend(): Negative acknowledgement (remote user/FDL interface error)
    4932    PBsend(): Negative acknowledgement (operating equipment for the
            remote FDL controller not available or not adequate)
    4933    PBsend(): Service or remote address not activated for 
            destination SAP (remote SAP)
    4939    PBsend(): Positive acknowledgement for send data; negative
            acknowledgement for receive data (as not available for remote 
            station)
                                      @804[ Continue ]                      @001[ Overview ]
.804
    PROFIBUS Library : Error Numbers (continue)

    4942    PBsend(): Negative acknowledgement for send data (as operating
            equipment for the remote station is not available or not adequate)

















                                      @550[ APPENDIX ]                      @001[ Overview ]
.900
    PROFIBUS Library : History - Version Changes

  ษอออออออออออออออออัอออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ V2.00 -> V2.01  ณ CURRENT VERSION: new functionalities/error correction   บ
  วฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤมฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤถ
  บ - PROFIBUS FDL services implemented.                                      บ
  บ - The following errors have been corrected:                               บ
  บ    - Error 4926 not documented                                            บ
  บ    - Reply Update Docu                                                    บ
  บ    - Error 4855 ambiguous                                                 บ
  บ - No L7 services possible after an L2 service on the same APB (this       บ
  บ   applies both for the PC firmware and the NW100/NW150 firmware).         บ
  ศอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ








                                      @901[ Continue ]                      @001[ Overview ]
.901
    PROFIBUS Library : History - Version Changes (continue)

  ษอออออออออออออออออัอออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ V1.10 -> V2.00  ณ OLDER VERSIONS                                          บ
  วฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤมฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤถ
  บ PROFIBUS FDL services implemented.                                        บ
  ฬอออออออออออออออออัอออออออออออออออออออออออออออออออออออออออออออออออออออออออออน
  บ V1.10           ณ OLDER VERSIONS                                          บ
  วฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤมฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤถ
  บ First version of the PROFIBUS library.                                    บ
  ศอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ










                                      @550[ APPENDIX ]                      @001[ Overview ]

.End
